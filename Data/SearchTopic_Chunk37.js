define({"2656":{i:5.50327019655568E-05,u:"../Content/Objects/Color_in_Object_Graphics.htm",a:"Color in an Object Graphics display is the result of interaction between the color model defined for the destination object (e.g. window or printer), the destination object’s inherent color model, and the color assigned to any visualization objects (e.g. plot, text or image objects) being displayed. ...",t:"Color in Object Graphics"},"2657":{i:0.000282225676408828,u:"../Content/Objects/Color_and_Destination_Ob.htm",a:"Each destination object has one of the two color models associated with it (an Indexed Color Model, and the RGB Color Model), shown in the following table.Once a destination object has been created, you cannot change the associated color model. You can, however, create destination objects that use ...",t:"Color and Destination Objects"},"2658":{i:6.67271579572477E-05,u:"../Content/Objects/Palette_Objects.htm",a:"Objects of the IDLgrPalette class are used to create color lookup tables. Color lookup tables assign individual numerical values to color values; this allows you to specify the color of a graphic object with a single number (a color index) rather than explicitly providing the red, green, and blue ...",t:"Palette Objects"},"2659":{i:6.67271579572477E-05,u:"../Content/Objects/Specifying_Object_Color.htm",a:"The color of most graphic objects are specified by the COLOR property of that object. (The IDLgrImage object has a PALETTE property, not a COLOR property. See IDLgrPalette::Init for examples.) In IDL Object Graphics, colors used for drawing visualization objects (such as an IDLgrText object) are ...",t:"Specifying Object Color"},"2660":{i:0.000186673370718489,u:"../Content/Objects/How_IDL_Interprets_Color.htm",a:"IDL determines colors to display differently based on whether the destination object uses an Indexed or RGB color model, and on whether the physical destination device supports an Indexed or RGB color model. Indexed Color Model If the destination object uses an Indexed color model, the color ...",t:"How IDL Interprets Color Values"},"2661":{i:6.51173110557678E-05,u:"../Content/Objects/Rendering_Objects.htm",a:"In Object Graphics, rendering occurs when the Draw method of a destination object is called. A scene, viewgroup, or view is typically provided as the argument to this Draw method. This argument represents the root of a graphics hierarchy. When the destination’s Draw method is called, the graphics ...",t:"Rendering Objects"},"2662":{i:5.50327019655568E-05,u:"../Content/Objects/Controlling_the_Depth_of.htm",a:"In graphics rendering, the depth buffer is an array of depth values maintained by a graphics device, one value per pixel, to record the depth of primitives rendered at each pixel. It is usually used to prevent the drawing of objects located behind other objects that have already been drawn in order ...",t:"Controlling the Depth of Objects in a View"},"2663":{i:0.00242089357149943,u:"../Content/Objects/Controlling_Object_Trans.htm",a:"Co ntrolling Object Transparency IDL objects which support an alpha channel are: IDLgrAxis IDLgrContour IDLgrImage IDLgrPlot IDLgrPolygon IDLgrPolyline IDLgrROI IDLgrSurface IDLgrSymbol IDLgrText IDLgrVolume  The transparency of an IDLgrImage object can be defined using a band of data defining the ...",t:"Controlling Object Transparency"},"2664":{i:0.000110382450400424,u:"../Content/Objects/Performance_Tuning_Objec.htm",a:"The Object Graphics subsystem is designed to provide a rich set of graphical functionality that can be displayed in reasonable time. This section offers suggestions on how to adjust your system and programs to achieve the best rendering performance. Hardware vs. Software Rendering The RENDERER ...",t:"Performance Tuning Object Graphics"},"2665":{i:0.000402551909226654,u:"../Content/Objects/Object_Operator_Overload.htm",a:"Combining routines and code in objects can be a powerful programming technique, but sometimes it is convenient to treat objects like basic types. For example, to add the properties of two objects, object-oriented programming requires you to call the property access methods, add the returned values, ...",t:"Operator Overloading Summary"},"2666":{i:0.000232967100497487,u:"../Content/Objects/Overloadable_Operators.htm",a:"The following table describes IDL’s operators and provides information on the object method you must implement in order to override each for a custom object class. Operator Non-Overloaded Operation Operator Type Object Method Name Function or Procedure ++ Increment Unary Not overloadable N/A -- ...",t:"Overloadable Operators"},"2667":{i:5.50327019655568E-05,u:"../Content/Objects/Overloaded_Operator_Prec.htm",a:"For binary operators, if the first operand is an object reference that subclasses from IDL_Object, the overloaded method of that object’s class will be called with that object as the implicit self argument. If the first argument is not a subclass of IDL_Object but the second operand is, the ...",t:"Overloaded Operator Precedence"},"2668":{i:0.000120174466722701,u:"../Content/Objects/Overloading_the_Array_In.htm",a:"IDL arrays can have up to eight dimensions, so IDL’s [] (array indexing) operator allows you to specify a maximum of eight indices or subscript ranges. The same limit of eight index values applies when overloading the [] operator for an object class. See Multiple Dimensions for details. Values ...",t:"Overloading the Array Indexing Operator"},"2669":{i:8.05698547922844E-05,u:"../Content/Objects/Example__Overloading_Arr.htm",a:"This example demonstrates a simple use of operator overloading with the [] (array indexing) operator. We create an object class (hexRGB_doc) whose only purpose is to provide an easy way to convert web-style hexadecimal color specifications to three-element RGB vectors. The hexRGB_doc object ...",t:"Example: Overloading Array Indexing Syntax"},"2670":{i:5.50327019655568E-05,u:"../Content/Objects/Creating_Operator_Overlo.htm",a:"To overload an object operator: Enable operator overloading for the class by inheriting the IDL_Object class. Refer to IDL_Object for more information. Add an _overload* method to the object that redefines the operator behavior. The valid overloaded operator method names are listed in Overloaded ...",t:"Creating Operator Overloading Methods"},"2671":{i:8.665846406232E-05,u:"../Content/Objects/Replicating_Non_Overload.htm",a:"The IDL_Object class includes standard object methods that implement default behavior for each operator that may be overloaded. These default methods are included to simplify your overload method code, and you are free to call them inside your operator overload method. For example, imagine that you ...",t:"Replicating Non-Overloaded Behavior in Overloaded Operator Methods"},"2672":{i:5.50327019655568E-05,u:"../Content/Objects/Returning_Object_Instanc.htm",a:"When creating an object method that overloads one of IDL’s standard operators, you might want to return an object instance that replaces the value on the left-hand side of the equals sign. In this situation, you have two options for coding your method: creating and returning a new object instance, ...",t:"Returning Object Instances from Overloaded Methods"},"2673":{i:0.00145602274721117,u:"../Content/Objects/Overloading_the_HELP_and.htm",a:"If a scalar object that inherits from IDL_Object is entered on the IDL command line, then the Implied Print functionality will call the object’s _overloadImpliedPrint function method, which can return a variable of any type that is used as the output. The default behavior for ...",t:"Overloading the Help and Print Procedures"},"2674":{i:0.00129296423130052,u:"../Content/Objects/Example__Overloading_the2.htm",a:"In this example, we create the spaceCraftObject_doc class, which stores a spacecraft’s name and mass. We overload the class’s _overloadHelp, _overloadImpliedPrint, and _overloadPrint methods, so that calling the help or print procedures with this class of object results in the output we desire. The ...",t:"Example: Overloading the Help and Print Procedures"},"2675":{i:0.000988386817297821,u:"../Content/Objects/Overloading_the_SIZE_and.htm",a:"If N_ELEMENTS or SIZE is called with a scalar object that inherits from the IDL_Object class, these routines will call the overloaded function method MyOperator::_overloadSize , which returns a vector containing one element per “dimension” of the object. (You can define what constitutes a dimension ...",t:"Overloading the SIZE and N_ELEMENTS Functions"},"2676":{i:0.000926612003470412,u:"../Content/Objects/Example__Overloading_the1.htm",a:"In this example, we create the MyArrayOper class, which merely wraps a pointer to an externally-created array. We overload the class’ _overloadSize , _overloadBracketsLeftSide , and _overloadBracketsRightSide methods. The MyArrayOper_doc object definition and operator overloading code listed in this ...",t:"Example: Overloading the SIZE and N_ELEMENTS Functions"},"2677":{i:5.50327019655568E-05,u:"../Content/Objects/Example__Modifying_an_Ob.htm",a:"This example demonstrates a use of operator overloading with the [] (array indexing) operator. We create an object class (store_array_doc) that includes in its member data a 100-element floating-point array, initially populated with random values. The object class’ overloaded array indexing ...",t:"Example: Modifying an Object Data Array using Operator Overloading"},"2678":{i:5.50327019655568E-05,u:"../Content/Objects/Example__Adding_Object_C.htm",a:"The colorCircle_doc object definition and operator overloading code listed in this section is contained in the procedure file colorcircle_doc__define.pro , and is located in the examples/doc/objects subdirectory of the IDL distribution. To view the file in an IDL editor window, enter .EDIT ...",t:"Example: Adding Object Color Values"},"2679":{i:5.50327019655568E-05,u:"../Content/Objects/ShaderObjects/ShaderTOC.htm",a:"Shader Objects in IDL ",t:"Shader Objects in IDL"},"2680":{i:5.50327019655568E-05,u:"../Content/Objects/ShaderObjects/ShadersOverview.htm",a:"The shader functionality provides access to the advantages of the hardware-based, OpenGL Shading Language (GLSL). Using a shader, computationally-intensive image processing operations can be off-loaded to the graphics card, making the time and processing resources of the host computer available to ...",t:"Overview of Shader Objects"},"2681":{i:5.50327019655568E-05,u:"../Content/Objects/ShaderObjects/IntroShaders.htm",a:"A shader program is a user-defined program written in OpenGL Shading Language (GLSL) that is executed by the graphics processing unit (GPU) of the graphics card. This topic provides an overview of the process of using shader programs with IDL. Your graphics card must support OpenGL 2.0 functionality ...",t:"Introduction to Shader Objects"},"2682":{i:5.50327019655568E-05,u:"../Content/Objects/ShaderObjects/ShaderPerformance.htm",a:"Using a shader lets you take advantage of the processing power of the graphics card processing unit (GPU) instead of relying solely on the system CPU.  Also, the GPU can operate on multiple data streams simultaneously. For example, some GPUs can execute a fragment shader on up to 24 fragments ...",t:"How Shaders Enhance Performance"},"2683":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Program Control.htm",a:"Program Control ",t:"Program Control"},"2684":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Application Programming/Overview_of_Program_Cont.htm",a:"IDL contains various program control constructs for controlling the flow of program execution, such as conditional expressions and looping mechanisms. These constructs include the following. Compound Statements Use BEGIN and END to create a block of statements, which is simply a group of statements ...",t:"Overview of Program Control"},"2685":{i:0.000130022404468249,u:"../Content/Creating IDL Programs/Application Programming/Definition_of_True_and_F.htm",a:"A predicate expression is an expression that is evaluated as being “true” or “false” as part of a statement that controls program execution. IDL evaluates predicate expressions in the following contexts: IF...THEN...ELSE statements ? : inline conditional expressions WHILE...DO statements ...",t:"Definition of True and False"},"2686":{i:0.000105049638229711,u:"../Content/Creating IDL Programs/Application Programming/CASE_Versus_SWITCH.htm",a:"The CASE and SWITCH statements are similar in function, but differ in the following ways: Execution exits the CASE statement at the end of the matching statement. By contrast, execution within a SWITCH statement falls through to the next statement. The following table illustrates this difference: ...",t:"CASE Versus SWITCH"},"2687":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Application Programming/Jump_Statements.htm",a:"Jump statements can be used to modify the behavior of conditional and iterative statements. Jump statements allow you to exit a loop, start the next iteration of a loop, or explicitly transfer program control to a specified location in your program. Statement Labels Labels are the destinations of ...",t:"Jump Statements"},"2688":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Application Programming/Compound_Statements.htm",a:"Many of the language constructs that we will discuss in this chapter evaluate an expression, then perform an action based on whether the expression is true or false, such as with the IF statement: IF expression THEN statement For example, we would say “If X equals 1, then set Y equal to 2” as ...",t:"Compound Statements"},"2689":{i:0.000313490745036732,u:"../Content/Creating IDL Programs/Components of the IDL Language/Static_Methods_Using.htm",a:"This document describes how to use static methods and attributes. Also see: Creating Static Methods List of Static Methods and Attributes Using Variable Attributes All IDL variables can use the dot \".\" operator to access various attributes that describe the variable. All variables have special ...",t:"Static Methods and Attributes"},"2690":{i:0.000240061240849946,u:"../Content/Creating IDL Programs/Components of the IDL Language/Static_Methods_Creating.htm",a:"This document describes how to create static methods. Also see: Using Static Methods and Attributes List of Static Methods and Attributes Static Class Inheritance You can create your own static methods for any IDL data type (except structures and objects). The static classes have the following ...",t:"Creating Static Methods"},"2691":{i:0.00047898392087516,u:"../Content/Reference Material/Static Methods/Variable Attributes.htm",a:"All IDL variables have special attributes that return information about the variable. These attributes are equivalent to calling the N_ELEMENTS , SIZE , or TYPENAME functions. The following variable attributes are available: Attribute Definition DIM An array giving the dimensions (0 for scalars). ...",t:"Variable Attributes"},"2692":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Widget Application Techniques.htm",a:"Widget Application Techniques ",t:"Widget Application Techniques"},"2693":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/User_Interface_Options_i.htm",a:"When creating a user-interface in IDL, you have several choices. In order of increasing complexity, you can use any of the following: IDL command-line interface — using the IDL command line as a non-graphical user interface to display graphics visualizations, or data in the IDL output log. Existing ...",t:"User Interface Options in IDL "},"2694":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Application Programming/Creating Widget Applications.htm",a:"Creating Widget Applications ",t:"Creating Widget Applications"},"2695":{i:0.000418917855141691,u:"../Content/Creating IDL Programs/Creating Applications in IDL/About_Widgets.htm",a:"IDL allows you to construct and manipulate graphical user interfaces using widgets . Widgets (or controls , in the terminology of some development environments) are simple graphical objects such as pushbuttons or sliders that allow user interaction via a pointing device (usually a mouse) and a ...",t:"About Widgets"},"2696":{i:0.000850542681481103,u:"../Content/Creating IDL Programs/Creating Applications in IDL/About_Widget_Application.htm",a:"The flow of control in a widget application is fundamentally different than in other IDL programs. A program written to be used from the IDL command line generally accepts its inputs when the program is invoked. The program then proceeds in a well-defined order to process those inputs and provide ...",t:"About Widget Applications"},"2697":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Types_of_Widgets.htm",a:"IDL supports several types of widgets and widget-like interface elements that can be used in your widget application: Type Descriptions Widget Primitives Widget primitives are the base interface elements used to create widget applications. They are used to display visualizations, to allow the user ...",t:"Types of Widgets"},"2698":{i:0.000114047198523794,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Widget_Programming_Conce.htm",a:"This section discusses some basic ideas and concepts that are central to the process of writing IDL widget applications. Widget Values Many widget primitives and compound widgets have widget values associated with them. Depending on the type of widget, the widget value may represent a static item ...",t:"Widget Programming Concepts"},"2699":{i:0.000100270180621976,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Example__A_Simple_Widget.htm",a:"The following example demonstrates the simplicity of widget programming. The example program creates a base widget containing a single button, labelled “Done.” When you position the mouse cursor over the button and click, the widget is destroyed. If you are new to IDL widget programming, don’t be ...",t:"Example: A Simple Widget Application"},"2700":{i:6.26388529835927E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Widget_Application_Lifec.htm",a:"When you create and use a widget application, you do the following things: Construct the Widget Hierarchy Provide an Event-Handling Routine Realize the Widgets Register the Program with the XMANAGER Interact with the Application Destroy the Widgets Construct the Widget Hierarchy You must first build ...",t:"Widget Application Lifecycle"},"2701":{i:9.59343758196685E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Manipulating_Widgets.htm",a:"IDL provides several routines that allow you to manipulate and manage widgets programmatically: WIDGET_CONTROL allows you to realize widget hierarchies, manipulate them, and destroy them. WIDGET_EVENT allows you to process events generated by a specific widget hierarchy. WIDGET_INFO allows you to ...",t:"Manipulating Widgets"},"2702":{i:8.83282248016325E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Working_With_Widget_IDs.htm",a:"Any widget application capable of doing real work will include one or more routines that are separate from the routine that creates the widget hierarchy, designed to handle and respond to user-generated events. Event processing routines — the routines that process information contained in widget ...",t:"Working With Widget IDs"},"2703":{i:0.000120960723753821,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Widget_User_Values.htm",a:"Every widget primitive and compound widget can carry a user-specified value of any IDL data type and organization; that is, every widget contains a variable that can store arbitrary information. This value is ignored by the widget and is for the programmer’s convenience only. The initial user value ...",t:"Widget User Values"},"2704":{i:0.000284914628780406,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Widget_Event_Processing.htm",a:"The concepts of events and event processing underlie every aspect of widget programming. It is important to understand how IDL handles widget events in order to use widgets effectively. This section discusses the following topics: What are Widget Events? Structure of Widget Events Managing Widget ...",t:"Widget Event Processing"},"2705":{i:0.000106441047505758,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Example__Event_Processin.htm",a:"The following example demonstrates how user values can be used to simplify event processing and to pass values between routines. It creates a base widget with three buttons and a text field that reports which button was pressed. If you are new to IDL widget programming, don’t be worried if parts of ...",t:"Example: Event Processing and User Values\n        "},"2706":{i:0.00019420786299377,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Managing_Application_Sta.htm",a:"A widget application is usually divided into at least two separate routines, one that creates and realizes the application and another that handles events. These multiple routines need shared access to certain types of information, such as the widget IDs of the application’s widgets and data being ...",t:"Managing Application State"},"2707":{i:0.000285536570431515,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Creating_a_Compound_Widg.htm",a:"Widget primitives can be used to construct many varied user interfaces, but complex programs written with them suffer the following drawbacks: Large widget applications become difficult to maintain. As an application grows, it becomes more difficult to properly write and test. The resulting program ...",t:"Creating a Compound Widget"},"2708":{i:0.00037808326415073,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Example__Compound_Widget.htm",a:"The following example incorporates ideas from the previous sections to show how you might approach the task of writing a compound widget. The widget is called CW_DICE, and it simulates a single six-sided die. The figure below shows the appearance of XDICE, an application that uses two instances of ...",t:"Example: Compound Widget"},"2709":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Debugging_Widget_Applica.htm",a:"In addition to the “normal” debug ging tasks associated with any IDL program, widget applications also require you to debug errors in the widget event loop. If your widget application experiences errors in an event handling routine, keep the following points in mind: By default, XMANAGER catches ...",t:"Debugging Widget Applications"},"2710":{i:0.000886271788072494,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Working_with_Widget_Even.htm",a:"Widget events and the process of establishing a widget event loop for your application are described in Widget Event Processing . This section discusses additional topics that may be useful when creating event-driven applications, including: Interrupting the Event Loop Identifying Widget Type from ...",t:"Working with Widget Events"},"2711":{i:0.000138387633835077,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Using_Multiple_Widget_Hi.htm",a:"Using widgets, you can create IDL applications with graphical user interfaces. Although widget applications are running “inside” IDL, a well-designed program can behave and appear just like a stand-alone application. While a simple application may consist of a single widget hierarchy headed by a ...",t:"Using Multiple Widget Hierarchies"},"2712":{i:0.00130758759562625,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Creating_Menus.htm",a:"Menus allow a user to select one or more options from a list of options. IDL widgets allow you to build a number of different types of menus for your widget application. This section discusses the following different types of menus: Button Groups Lists Pulldown Menus Menus on Top-Level Bases ...",t:"Creating Menus"},"2713":{i:0.000366875705816166,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Tips_on_Creating_Widget.htm",a:"The following are some ideas to keep in mind when writing widget applications in IDL. When writing new applications, decompose the problem into sub-problems and write reusable compound widgets to implement them. In this way, you will build a collection of reusable widget solutions to general ...",t:"Tips on Creating Widget Applications"},"2714":{i:0.00717821075557913,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Enhancing_Widget_Applica.htm",a:"Implementing features such as tabbing and keyboard accelerators into applications that require extensive user-interaction with widget elements can improve application usability. This allows power-users to quickly make selections and initiate actions using the keyboard instead of the mouse. See the ...",t:"Enhancing Widget Application Usability"},"2715":{i:0.00012825721393891,u:"../Content/Creating IDL Programs/Creating Applications in IDL/About_Button_Widgets.htm",a:"Button widgets allow users to respond to “yes-or-no” type questions via the widget interface. While button widgets are generally fairly simple to understand and use, there are numerous options that allow you to fine-tune the appearance and behavior of buttons in your interface. This section ...",t:"About Button Widgets"},"2716":{i:7.68366586426135E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Bitmap_Button_Labels.htm",a:"In addition to setting the VALUE of a button widget to a text string, you can use a bitmap image as the label for the button. To us a bitmap image, set VALUE to one of the following: The path to a bitmap image file, if the BITMAP keyword is also specified. An n x m byte array converted to a bitmap ...",t:"Bitmap Button Labels"},"2717":{i:7.68366586426135E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Tooltips.htm",a:"You can specify a “ tooltip” — a short text string that will appear when the mouse pointer hovers over a button widget — by specifying the string as the value of the TOOLTIP keyword to WIDGET_BUTTON. Tooltips cannot be created for menu sub-items. The topmost button of a pulldown menu can, however, ...",t:"Tooltips"},"2718":{i:7.68366586426135E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Exclusive_and_Non_Exclus.htm",a:"By default, when a user clicks on a button widget, the button appears to be depressed while the user holds down the mouse button, but the button returns to the undepressed appearance when the user releases the mouse button. While such “normal” buttons visually reflect the state of the button ...",t:"Exclusive and Non-Exclusive Buttons"},"2719":{i:9.24747147181407E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/About_Draw_Widgets.htm",a:"Draw wi dgets are graphics windows that appear as part of a widget hierarchy rather than appearing as an independent window. Like other graphics windows, draw widgets can be created to use either Direct or Object graphics. Draw widgets allow designers of IDL graphical user interfaces to take ...",t:"About Draw Widgets"},"2720":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Using_Direct_Graphics_in.htm",a:"",t:"Using_Direct_Graphics_in"},"2721":{i:0.00010181052593232,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Using_Object_Graphics_in.htm",a:"To create a draw widget that uses Object graphics, set the GRAPHICS_LEVEL keyword to WIDGET_DRAW equal to two. Once created, draw widgets using Object graphics are used in the same way as standard IDLgrWindow objects. All IDL Object graphics windows (that is, IDLgrWindow objects) are referred to by ...",t:"Using Object Graphics in Draw Widgets"},"2722":{i:9.24747147181407E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Scrolling_Draw_Widgets.htm",a:"Another difference between a draw widget and either a graphics window created with the WINDOW procedure or an IDLgrWindow object is that draw widgets can include scroll bars. Setting the APP_SCROLL keyword or the SCROLL keyword to the WIDGET_DRAW function causes scrollbars to be attached to the ...",t:"Scrolling Draw Widgets"},"2723":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Context_Events_in_Draw_W.htm",a:"The WIDGET_DRAW function does not have a CONTEXT_EVENTS keyword to specify that context menu events be generated when the user clicks the right mouse button over a drawable area. Instead, the event structure generated by draw widgets when the BUTTON_EVENTS keyword is set includes the PRESS and ...",t:"Context Events in Draw Widgets"},"2724":{i:0.00013873697994194,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Draw_Widget_Example.htm",a:"The following example program creates a small widget application consisting of a draw widget and a droplist menu. One of three plots is displayed in the draw widget depending on the selection made from the droplist. To add to dynamic behavior, we will use timer events to change the color table used ...",t:"Draw Widget Example"},"2725":{i:9.24747147181407E-05,u:"../Content/Creating IDL Programs/Creating Applications in IDL/Accessing_Draw_Widget_Ev.htm",a:"To go beyond merely displaying an image in a draw widget and allow the user to interact in some way with the displayed image, you must configure the draw widget to generate either button , motion , wheel , or keyboard events: Button events are enabled by setting the BUTTON_EVENTS keyword to ...",t:"Accessing Draw Widget Events"},});