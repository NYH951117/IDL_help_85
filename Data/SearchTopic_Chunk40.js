define({"2854":{i:0.000224730262127995,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/InitializingTheIDL-JavaBridge.htm",a:"The IDL-Java bridge must be configured before Java objects can be created and used within IDL. IDL initializes the bridge when it first attempts to create an instance of IDLjavaObject. Initializing the bridge involves starting the Java Virtual Machine and creating any internal Java bridge objects ...",t:"Initializing The IDL-Java Bridge"},"2855":{i:0.000241650491950044,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/TheIDLJavaBridgeSessionObject.htm",a:"Java exceptions are handled within IDL through an IDL-Java bridge session object, IDLJavaBridgeSession. This Java object can be queried to determine the status of the bridge, including information on any exceptions. For example, one important Java object available through the session object is the ...",t:"The IDL Java Bridge Session Object"},"2856":{i:0.000172158237396587,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/CreatingIDL-JavaObjects.htm",a:"As with all IDL objects, a Java object is created using the IDL OBJ_NEW function. Keying off the provided Java class name, the underlying implementation uses the IDL Java subsystem to call the constructor on the desired Java object. The following line of code demonstrates the basic syntax for ...",t:"Creating IDL-Java Objects"},"2857":{i:8.98354002780658E-05,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/DestroyingIDL-JavaObjects.htm",a:"The OBJ_DESTROY routine is used to destroy instances of IDLjavaObject. When OBJ_DESTROY is called with a Java-based object as an argument, IDL releases the underlying Java object and frees IDL resources relating to that object. Destruction of the IDL object does not automatically cause the ...",t:"Destroying IDL-Java Objects"},"2858":{i:0.000212779857535076,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/IDL-JavaBridgeDataTypeMapping.htm",a:"When data moves between IDL and a Java object, IDL automatically converts variable data types. The following table maps how Java data types correlate to IDL data types. Java Type (# bytes) IDL Type Notes boolean (1) Integer True becomes 1, false becomes 0 byte (1) Byte  char (2) Byte The bridge ...",t:"IDL-Java Bridge Data Type Mapping"},"2859":{i:0.000172158237396587,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/ManagingIDL-JavaObjectProperties.htm",a:"Property names and arguments are also passed to the IDL Java subsystem and are used in conjunction with the Java Reflection API to construct and access public data members on the underlying object. These public data members (known as properties in IDL) are identified through arguments to the ...",t:"Managing IDL-Java Object Properties"},"2860":{i:9.899062932407E-05,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/MethodCallsOnIDL-JavaObjects.htm",a:"When a method is called on a Java-based IDL object, the method name and arguments are passed to the IDL-Java subsystem and the Java Reflection API to construct and invoke the method call on the underlying object. IDL handles conversion between IDL and Java data types. Any results are returned in IDL ...",t:"Method Calls On IDL-Java Objects"},"2861":{i:5.54698778904798E-05,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/ShowingIDL-JavaOutputInIDL.htm",a:"By default, IDL prints the output from Java (the System.out and System.err output streams). For example, given the following Java code: public class helloWorld { // ctor public helloWorld() { System.out.println(\"helloWorld ctor\"); } public void sayHello() { System.out.println(\"Hello! (from the ...",t:"Showing IDL-Java Output In IDL"},"2862":{i:5.54698778904798E-05,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/JavaExceptions.htm",a:"During the operation of the bridge, an error may occur when initializing the bridge, creating an IDLjavaObject , calling methods, setting properties, or getting properties. Typically, these errors will be fixed by changing your IDL or Java code (or by changing the bridge configuration). Java bridge ...",t:"Java Exceptions"},"2863":{i:5.54698778904798E-05,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/IDL-JavaBridgeExamples.htm",a:"The following examples demonstrate how to access data through the IDL-Java bridge: Accessing Arrays Example Accessing URLs Example Accessing Grayscale Images Example Accessing RGB Images Example If IDL is not able to find any Java class associated with these examples, make sure your IDL-Java bridge ...",t:"IDL-Java Bridge Examples"},"2864":{i:6.48997626444826E-05,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/AccessingArraysExample.htm",a:"This example creates a two-dimensional array within a Java class, which is contained in a file named array2d.java . IDL then accesses this data through the ArrayDemo routine, which is in a file named arraydemo.pro . These files are located in the resource/bridges/import/java/examples directory of ...",t:"Accessing Arrays Example"},"2865":{i:6.48997626444826E-05,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/AccessingGrayscaleImagesExample.htm",a:"This example creates a a grayscale ramp image within a Java class, which is contained in a file named GreyBandsImage.java . IDL then accesses this data through the ShowGreyImage routine, which is in the showgreyimage.pro file. These files are located in the resource/bridges/import/java/examples ...",t:"Accessing Grayscale Images Example"},"2866":{i:6.48997626444826E-05,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/AccessingRGBImagesExample.htm",a:"This example imports an RGB (red, green, and blue) image from the IDL distribution into a Java class. The image is in the glowing_gas.jpg file, which is in the examples/data directory of the IDL distribution. The Java class also displays the image in a Java Swing user-interface. Then, the image is ...",t:"Accessing RGB Images Example"},"2867":{i:6.48997626444826E-05,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/AccessingURLsExample.htm",a:"This example finds and reads a given URL, which is contained in a file named URLReader.java . IDL then accesses this data through the URLRead routine, which is in a file named urlread.pro . These files are located in the resource/bridges/import/java/examples directory of the IDL distribution. Run ...",t:"Accessing URLs Example"},"2868":{i:6.4625106936484E-05,u:"../Content/Connectivity Bridges/ImportToIDL - Java Objects/TroubleshootingYourBridgeSession.htm",a:"The IDL-Java bridge provides error messages for specific types of operations. These messages can be used to determine when these errors occur, how these errors happen, and what solutions can be applied. The following sections pertain to these error messages and their possible solutions for each type ...",t:"Troubleshooting Your Bridge Session"},"2869":{i:0.000111256473599902,u:"../Content/Connectivity Bridges/Python/Python.htm",a:"Overview Examples Installation IDL to Python bridge Python to IDL bridge IDL IPython Notebook Kernel Overview The Python Bridge consists of two components: the IDL to Python bridge and the Python to IDL bridge . The bridge has the following features: Works with Python 2 and Python 3 Access to all ...",t:"Python Bridge"},"2870":{i:0.000109070723917073,u:"../Content/Connectivity Bridges/Python/IDLToPython.htm",a:"The PYTHON class provides a bridge from IDL to Python. The class contains a set of static methods that allow you to initialize and interact with the Python interpreter. In addition, each object passed back from Python is wrapped in an instance of the PYTHON class; you can then call methods on the ...",t:"IDL to Python Bridge"},"2871":{i:0.000109070723917073,u:"../Content/Connectivity Bridges/Python/PythonToIDL.htm",a:"The Python to IDL bridge provides a mechanism for calling IDL code from Python. The IDL module contains a set of methods that allow you to initialize and interact with the IDL interpreter. In addition, each object passed back from IDL is wrapped in an instance of the IDL class; you can then call ...",t:"Python to IDL Bridge"},"2872":{i:0.000130250206426216,u:"../Content/DevelopmentEnvironment/IDLWorkbenchGuide.htm",a:"The IDL Workbench Guide ",t:"The IDL Workbench Guide"},"2873":{i:0.00047799103763904,u:"../Content/DevelopmentEnvironment/QuickReference/IDLDEOverview.htm",a:"The IDL Workbench is a graphical user interface (GUI) based on the Eclipse open-source framework (http://www.eclipse.org). The Workbench provides editing and debugging tools in an interface that looks and behaves the same way on all platforms supported by IDL. Full documentation of the underlying ...",t:"The IDL Workbench - Overview"},"2874":{i:0.000497363374220475,u:"../Content/DevelopmentEnvironment/QuickReference/MenubarToolbar.htm",a:"This topic is a quick reference guide to the Menubar and Toolbar of the IDL Workbench. The Menubar The Menubar for the IDL Workbench contains standard dropdown menu controls as outlined below. This list describes the items  in the Menubar view as they appear on Microsoft Windows. There are some ...",t:"Menubar and Toolbar Reference"},"2875":{i:0.000498280467989782,u:"../Content/DevelopmentEnvironment/QuickReference/EditorView.htm",a:"In this Workbench view, you can write, edit, and debug IDL programs. An example of a file opened in the editor view is shown below: Breakpoints - The red circle in the in the vertical gray bar to the left of the line numbers (above) is a breakpoint.  These can be added by double clicking  in the ...",t:"The Editor View"},"2876":{i:0.000124185717401396,u:"../Content/DevelopmentEnvironment/QuickReference/BookmarksView.htm",a:"The Bookmarks View displays all Bookmarks set in the Workbench. Bookmarks are placeholders that you can set to allow easy navigation back to a particular file and file location. To show the Bookmarks View, select WINDOW \u003e Show View \u003e Bookmarks from the Menubar (or WINDOW \u003e Show View \u003e Other \u003e ...",t:"The Bookmarks View"},"2877":{i:0.000102242338508486,u:"../Content/DevelopmentEnvironment/QuickReference/CodeCoverage.htm",a:"The IDL Code Coverage feature helps you analyze the lines of code that were executed within your application. Code coverage is very useful at identifying unused or unneeded code paths, or to ensure that your \"unit tests\" are exercising all of your code. There are three ways to use the Code Coverage ...",t:"Code Coverage"},"2878":{i:0.0004717499499678,u:"../Content/DevelopmentEnvironment/QuickReference/IDLConsoleView.htm",a:"In this view, you can enter IDL statements at the IDL\u003e prompt. Information  (such as output from programs, errors, warnings, etc.) is also displayed in this view. Some other features that are included in Console view include: Content Assist - If you start typing a command, you can hit \u003cCTRL\u003e\u003cSPACE\u003e ...",t:"The IDL Console View"},"2879":{i:0.0004717499499678,u:"../Content/DevelopmentEnvironment/QuickReference/ClassHierarchy.htm",a:"The Class Hierarchy View displays the class members associated with your program file. Clicking on a name in the Class Hierarchy View will highlight the selected class in the Editor .  Option Buttons The first set of buttons control the general functioning of the Class Hierarchy window. Link with ...",t:"The Class Hierarchy"},"2880":{i:0.0004717499499678,u:"../Content/DevelopmentEnvironment/QuickReference/CommandHistory.htm",a:"The Command History view shows a list of recent statements entered into the IDL Console . Clicking the \"Date\" column header allows you to sort commands by date from oldest or most recent. To copy statements from Command History to the IDL Console or Editor : Copy/Paste to Console or Editor : ...",t:"The Command History View"},"2881":{i:0.0004717499499678,u:"../Content/DevelopmentEnvironment/QuickReference/OutlineView.htm",a:"The Outline View displays all of the programs in a file that is open in the Editor .  Clicking on a program  name in the Outline View will highlight the declaration in the Editor. If the declaration isn\u0027t currently visible, the Editor scrolls to make it visible. Option Buttons See the figure above ...",t:"The Outline View"},"2882":{i:0.000142251658658969,u:"../Content/DevelopmentEnvironment/QuickReference/DEPreferences.htm",a:"The IDL Workbench contains a set of user-definable preferences available from the Menubar . Click: WINDOW \u003e Preferences to access them. Preferences allow you to control the behavior of certain elements in the Workbench. General Appearance - Settings controlling the look and feel of the Workbench. ...",t:"IDL Workbench Preferences"},"2883":{i:0.0004717499499678,u:"../Content/DevelopmentEnvironment/QuickReference/ProblemsView.htm",a:"This view shows compilation errors and functions/routines with the same name that are located in your IDL path. Double-clicking a Problem Description will highlight the associated block of code in your Editor View .  IDL only has one namespace, so if there are multiple routines with the same name in ...",t:"The Problems View (Collision Detection)"},"2884":{i:0.000760923379195565,u:"../Content/DevelopmentEnvironment/QuickReference/ProfilerView.htm",a:"The IDL Code Profiler helps you analyze the performance of your applications. You can easily monitor the calling frequency and execution time for procedures and functions. If the tab for the Profiler View is not visible, simply choose WINDOW \u003e Profiler . It is also available by choosing WINDOW \u003e ...",t:"The IDL Code Profiler"},"2885":{i:0.000560449649754633,u:"../Content/DevelopmentEnvironment/QuickReference/ProjectExplorer.htm",a:"The IDL Workbench\u0027s Project Explorer is similar to many file browsers in other graphical user interfaces - it is an intuitive way to organize your files in a hierarchical tree-type view. The screenshot below shows an example of the Project Explorer, with \"closed\" and \"open\" projects delineated. What ...",t:"The Project Explorer"},"2886":{i:9.56670594948427E-05,u:"../Content/DevelopmentEnvironment/QuickReference/TasksView.htm",a:"The Tasks View allows you to manage your own Tasks in a Project. Tasks are simply reminders of things you need to do or fix within your program files. To show the Tasks View, select WINDOW \u003e Show View \u003e Tasks from the Menubar (or WINDOW \u003e Show View \u003e Other \u003e Tasks).   (Complete) - The leftmost ...",t:"The Tasks View"},"2887":{i:0.000471749949967801,u:"../Content/DevelopmentEnvironment/QuickReference/VariablesView.htm",a:"The Variables View tracks and displays the variables currently in use in the Editor and Console Views (either currently being debugged in the Editor or that has been executed in the Console).  Clear Variables : Use the Workbench\u0027s Reset button to clear out the current variables in the Variables ...",t:"The Variables View"},"2888":{i:0.000180818158580972,u:"../Content/DevelopmentEnvironment/QuickReference/ESETasks.htm",a:"The IDL Workbench contains functionality to help you write and publish Tasks for use in ENVI Services Engine (ESE). This includes the ability to easily create JSON and PRO  code, edit and validate  JSON files, and  publish Tasks from IDL directly to an ESE Server. Create a Task Edit a Task Publish a ...",t:"ESE Tasks"},"2889":{i:9.57090966120056E-05,u:"../Content/DevelopmentEnvironment/OrganizeCode/OrganizeCodeBestPractices.htm",a:"IDL offers a variety of ways to organize your code. This topic covers some of the methods we have seen that work well and consistently. You could choose to organize your code in other ways, though, so select a method that makes sense and is easy to use. Our strongest recommendation to organize your ...",t:"Best Practices in Organizing Your Code"},"2890":{i:5.67137900987713E-05,u:"../Content/OtherTopics.htm",a:"Other Topics ",t:"Other Topics"},"2891":{i:5.50327019655568E-05,u:"../Content/External Development/EDG.htm",a:"External Development Overview About This Guide Supported Inter-Language Communication Techniques Dynamic Linking Terms and Concepts When Should I Combine External Code with IDL? Required Skills IDL Organization External Definitions Interpreting Logical Boolean Values Compilation and Linking Details ...",t:"External Development Guide Contents"},"2892":{i:5.50327019655568E-05,u:"../Content/External Development/External Development Overview/EDGOverview.htm",a:"EDG Overview ",t:"EDG Overview"},"2893":{i:5.54291242025632E-05,u:"../Content/External Development/External Development Overview/AboutThisGuide.htm",a:"The External Development Guide describes options for using code not written in IDL. It contains three parts: Part I:Techniques That Do Not Use IDL’s Internal API This section discusses techniques that allow IDL to work together with programs written in other programming languages, using IDL’s ...",t:"About The External Development Guide"},"2894":{i:6.32815880542948E-05,u:"../Content/External Development/External Development Overview/InterlanguageCommunication.htm",a:"IDL supports a number of different techniques for communicating with the operating system and programs written in other languages. These methods are described, in brief, below. Options are presented in approximate order of increasing complexity. We recommend that you favor the simpler options at the ...",t:"Supported Inter-Language Communication Techniques"},"2895":{i:5.54291242025632E-05,u:"../Content/External Development/External Development Overview/DynamicLinking.htm",a:"Dynamic linking consists of compiling and linking code into a form that is loadable by programs at run time as well as link time. The ability to load them at run time is what distinguishes them from ordinary object files. Various operating systems have different names for such loadable code: UNIX: ...",t:"Dynamic Linking Terms and Concepts"},"2896":{i:5.54291242025632E-05,u:"../Content/External Development/External Development Overview/WhenToCombineExternalCode.htm",a:"IDL is an interactive program that runs across numerous operating systems and hardware platforms. The IDL user enjoys a large amount of portability across these platforms because IDL provides access to system abilities at a relatively high level of abstraction. There are reasons to combine external ...",t:"When Should I Combine External Code with IDL?"},"2897":{i:6.32815880542948E-05,u:"../Content/External Development/External Development Overview/RequiredSkills.htm",a:"There is a large difference between the level at which a typical user sees IDL compared to that of the internals programmer. To the user, IDL is an easy-to-use, array-oriented language that combines numerical and graphical abilities, and runs on many platforms. Internally, IDL is a large C language ...",t:"Required Skills"},"2898":{i:5.54291242025632E-05,u:"../Content/External Development/External Development Overview/IDLOrganization.htm",a:"In order to properly write code to be linked with IDL, it is necessary to understand a little about its internal operation. This section is intended to give just enough background to understand the material that follows. Traditional interpreted languages work according to the following algorithm: ...",t:"IDL Organization"},"2899":{i:5.54291242025632E-05,u:"../Content/External Development/External Development Overview/ExternalDefinitions.htm",a:"The file idl_export.h , found in the external/include subdirectory of the IDL distribution, supplies all the IDL-specific definitions required to write code for inclusion with IDL. As such, this file defines the interface between IDL and your code. If you are not writing in C, you will have to ...",t:"External Definitions"},"2900":{i:5.54291242025632E-05,u:"../Content/External Development/External Development Overview/InterpretLogicalBooleanValues.htm",a:"IDL is written in the C programming language, so this section of the Help discusses C language functions and data structures from the IDL program. In this documentation, you will see references to logical (boolean) arguments and results referred to in any of the following forms: True, False, TRUE, ...",t:"Interpreting Logical Boolean Values"},"2901":{i:5.54291242025632E-05,u:"../Content/External Development/External Development Overview/CompilationAndLinking.htm",a:"Once you have written your code, you need to compile it and link it into IDL before it can be run. Information on how to do this is available in the various subdirectories of the external subdirectory of the IDL distribution. In addition: The IDL MAKE_DLL procedure, provides a portable high level ...",t:"Compilation and Linking Details"},"2902":{i:0.000171096415668454,u:"../Content/External Development/Miscellaneous EDG Topics/UsingSpawnAndPipes.htm",a:"IDL’s SPAWN procedure spawns a child process to execute a command or series of commands. General use of SPAWN is described in detail in the IDL Online Help. This section describes how to use SPAWN to communicate with the spawned child process using operating system pipes. By default, calls to the ...",t:"Using SPAWN and Pipes"},"2903":{i:0.000304616325251194,u:"../Content/External Development/Using CALL_EXTERNAL/CALL_EXTERNAL.htm",a:"CALL_EXTERNAL() ",t:"CALL_EXTERNAL()"},"2904":{i:7.65568308125737E-05,u:"../Content/External Development/Using CALL_EXTERNAL/CallExtFn.htm",a:"IDL allows you to integrate programs written in other languages with your IDL code, either by calling a compiled function from an IDL program or by linking a compiled function into IDL’s internal system routine table: The CALL_EXTERNAL function allows you to call external functions (written in C/C++ ...",t:"The CALL_EXTERNAL Function"},"2905":{i:0.000155081469329889,u:"../Content/External Development/Using CALL_EXTERNAL/PassingParameters.htm",a:"IDL calls routines within a shareable library using the IDL portable calling convention, in which the routine is passed two arguments: argc A count of the number of arguments being passed to the routine argv An array of argc memory pointers, which are the addresses of the arguments (by reference) or ...",t:"Passing Parameters"},"2906":{i:0.00012676157194103,u:"../Content/External Development/Using CALL_EXTERNAL/UsingAutoGlue.htm",a:"Users of CALL_EXTERNAL frequently write small functions with the sole purpose of matching the CALL_EXTERNAL portable calling convention with its (argc, argv) interface to the actual interface presented by some existing function that they wish to call. Such functions are often called glue functions. ...",t:"Using Auto Glue"},"2907":{i:6.08519031091106E-05,u:"../Content/External Development/Using CALL_EXTERNAL/BasicCExamples.htm",a:"All of the code for the examples in this section can be found in the /external/call_external/C subdirectory of the IDL distribution. Please read the README file in that directory for details on how to run the examples. In many cases, the files in that directory go into more detail, and are more ...",t:"Basic C Examples"},"2908":{i:5.54291242025632E-05,u:"../Content/External Development/Using CALL_EXTERNAL/WrapperRoutines.htm",a:"CALL_EXTERNAL routines are very sensitive to the number and type of the arguments they receive. Calling a CALL_EXTERNAL routine with the wrong number of arguments or with arguments of the wrong type can cause IDL to crash. For this reason, it is a good practice to provide an IDL wrapper routine that ...",t:"Wrapper Routines"},"2909":{i:5.54291242025632E-05,u:"../Content/External Development/Using CALL_EXTERNAL/PassingStringData.htm",a:"IDL represents strings internally as IDL_STRING descriptors. For more information about IDL_STRING, see IDL Internals: Variables and IDL Internals: String Processing . These descriptors are defined in the C language as: typedef struct { IDL_STRING_SLEN_T slen; unsigned short stype; char *s; } ...",t:"Passing String Data"},"2910":{i:5.54291242025632E-05,u:"../Content/External Development/Using CALL_EXTERNAL/PassingArrayData.htm",a:"When you pass an IDL array into a CALL_EXTERNAL routine, that routine gets a pointer to the first memory location in the array. In order to perform any processing on the array, an external routine needs more information—such as the array’s size and number of dimensions. With CALL_EXTERNAL , you will ...",t:"Passing Array Data"},"2911":{i:5.54291242025632E-05,u:"../Content/External Development/Using CALL_EXTERNAL/PassingStructures.htm",a:"IDL structure variables are stored in memory in the same layout that C uses. This makes it possible to pass IDL structure variables into CALL_EXTERNAL routines, as long as the layout of the IDL structure is known. To access an IDL structure from an external routine, you must create a C structure ...",t:"Passing Structures"},"2912":{i:5.54291242025632E-05,u:"../Content/External Development/Using CALL_EXTERNAL/FORTRANExamples.htm",a:"Example: Calling a Fortran Routine Using a C Interface Routine Calling Fortran is similar to calling C, with the significant difference that Fortran code expects all arguments to be passed by reference and not by value (the C default). This means that the address of the argument is passed rather ...",t:"Fortran Examples"},"2913":{i:9.91849674618481E-05,u:"../Content/External Development/Remote Procedure Calls/RPC.htm",a:"Remote Procedure Calls ",t:"Remote Procedure Calls"},"2914":{i:6.32815880542948E-05,u:"../Content/External Development/Remote Procedure Calls/IDLandRPC.htm",a:"Remote Procedure Calls (RPCs) allow one process (the client process) to have another process (the server process) execute a procedure call just as if the caller process had executed the procedure call in its own address space. Since the client and server are separate processes, they can reside on ...",t:"IDL and RPC"},"2915":{i:5.54291242025632E-05,u:"../Content/External Development/Remote Procedure Calls/UsingIDLasRPCServer.htm",a:"The IDL RPC Directory All of the files related to using IDL’s RPC capabilities are found in the rpc subdirectory of the external subdirectory of the main IDL directory. The main IDL directory is referred to here as idldir . Running IDL in Server Mode To use IDL as an RPC server, run IDL in server ...",t:"Using IDL as an RPC Server"},"2916":{i:5.54291242025632E-05,u:"../Content/External Development/Remote Procedure Calls/ClientVariables.htm",a:"The IDL RPC client API uses the same data structure as IDL to represent a variable, namely an IDL_VARIABLE structure. By not using a unique data structure to represent a variable, the IDL RPC client API can follow a format that is similar to the API of Callable IDL. When a variable is created by the ...",t:"Client Variables"},"2917":{i:0.000125404411649588,u:"../Content/External Development/Remote Procedure Calls/LinkToClientLibrary.htm",a:"To make use of the IDL RPC functionality, you will need to do the following: Include the file idl_rpc.h in your application. Have a copy of idl_export.h in the include path when you compile the client application. Link your client application to the IDL client shared object library ( libidl_rpc ). ...",t:"Link to Client Library"},"2918":{i:8.23238152970214E-05,u:"../Content/External Development/Remote Procedure Calls/Compatibility.htm",a:"With the release of IDL 5.0, IDL’s Remote Procedure Call functionality has been completely reworked. While RPC code built for older versions of IDL can still be used with IDL 5.0 and later, the new RPC functionality has the following advantages: The new API mirrors the Callable IDL API. The RPC ...",t:"Compatibility"},"2919":{i:7.73429836584757E-05,u:"../Content/External Development/Remote Procedure Calls/IDLRPCLibrary.htm",a:"The IDL RPC library contains several C language interface functions that facilitate communication between your application and IDL. There are functions to register and unregister clients, set timeouts, get and set the value of IDL variables, send commands to the IDL server, and cause the server to ...",t:"The IDL RPC Library"},"2920":{i:5.54291242025632E-05,u:"../Content/External Development/Remote Procedure Calls/RPCExamples.htm",a:"A number of example files are included in the IDL_DIR/external/rpc directory. A Makefile for these examples is also included. These short C programs demonstrate the use of the IDL RPC library. Source files for the idlrpc server program are located in the IDL_DIR/external/rpc directory. Note that you ...",t:"RPC Examples"},"2921":{i:0.000367688461801483,u:"../Content/External Development/IDLInternals - Types/Types.htm",a:"Every IDL variable has a data type. The possible type codes and their mapping to C language types are listed in the following table. The undefined type code (IDL_TYP_UNDEF ) will always have the value zero. Although it is rare, the number of types could change. Therefore, you should always use the ...",t:"Types"},"2922":{i:8.54609993910165E-05,u:"../Content/External Development/IDLInternals - Keyword Processing/IDLKeywordProcessing.htm",a:"Keyword arguments are an important IDL language feature. They allow a multitude of options to be specified to a routine in a straightforward, easily understood way. The price of this added power is that it is somewhat more complicated to write a routine that accepts keywords than one that doesn’t. ...",t:"IDL Internals - Keyword Processing"},"2923":{i:5.54291242025632E-05,u:"../Content/External Development/IDLInternals - Keyword Processing/CreatingRoutinesAcceptKeywords.htm",a:"As described in Adding System Routines , you must register your system routine before IDL will recognize it. When registering the routine, you indicate that it accepts keyword arguments in one of the following ways: Specifying the KEYWORDS option for the routine in the module definition file of a ...",t:"Creating Routines that Accept Keywords"},});