define({"0":{i:6.1715248246523E-05,u:"../Content/WhatsNew.htm",a:"If you are new to IDL or upgrading from an older version, see also: What\u0027s New in IDL 8.4.1 What\u0027s New in IDL 8.4 What\u0027s New in IDL 8.3 What\u0027s New in IDL 8.2.3 What\u0027s New in IDL 8.2.2 What\u0027s New in IDL 8.2.1 What\u0027s New in IDL 8.2 What\u0027s New in IDL 8.1 What\u0027s New in IDL 8.0 New Features Python Bridge ...",t:"What\u0027s New in IDL 8.5"},"1":{i:6.1715248246523E-05,u:"../Content/images/ref_part1.htm",a:"IDL Routines The IDL Command Reference includes the following sections: ",t:"IDL Routines"},"2":{i:7.6789836178486E-05,u:"../Content/Creating IDL Programs/Overview of IDL Syntax/IDL_Syntax.htm",a:"The following table lists the syntax elements used in the IDL help system for  documentation on routines, functions, and objects: Element Description [ ] (Square brackets) Indicates that the contents are optional. Do not include the brackets in your call. Brackets are also used when creating and ...",t:"IDL Documentation Syntax"},"3":{i:5.50327019655568E-05,u:"../Content/Reference Material/A/A_list.htm",a:"A Routines ",t:"A Routines"},"4":{i:0.000643093036097846,u:"../Content/Reference Material/A/A_CORRELATE.htm",a:"The A_CORRELATE function computes the autocorrelation Px ( L ) or autocovariance Rx ( L ) of a sample population X as a function of the lag L . where x is the mean of the sample population x = ( x 0 , x 1 , x 2 , ... , x N-1 ). This routine is primarily designed for use in 1-D time-series analysis. ...",t:"A_CORRELATE "},"5":{i:7.59605240053487E-05,u:"../Content/Reference Material/A/ABS.htm",a:"The ABS function returns the absolute value of its argument. Examples To print the absolute value of -25, enter: PRINT, ABS(-25) IDL prints: 25 Syntax Result = ABS( X ) Return Value Returns the absolute value of its argument. Arguments X The value for which the absolute value is desired. If X is of ...",t:"ABS"},"6":{i:0.000261171640830219,u:"../Content/Reference Material/A/ACOS.htm",a:"The ACOS function returns the angle, expressed in radians, whose cosine is X (i.e., the arc-cosine). For real input, the range of ACOS is between 0 and π. For input of a complex number, Z = X + iY, the complex arccosine is given by, acos(Z) = acos(B) - i alog(A + sqrt(A 2 - 1))   if Y \u003e= 0 acos(Z) = ...",t:"ACOS "},"7":{i:9.36894309980955E-05,u:"../Content/Reference Material/A/ADAPT_HIST_EQUAL.htm",a:"The ADAPT_HIST_EQUAL function performs adaptive histogram equalization, a form of automatic image contrast enhancement. The algorithm is described in Pizer et. al., “Adaptive Histogram Equalization and its Variations.”, Computer Vision, Graphics and Image Processing, 39:355-368. Adaptive histogram ...",t:"ADAPT_HIST_EQUAL "},"8":{i:0.000151467465935319,u:"../Content/Reference Material/A/ALOG.htm",a:"The ALOG function returns the natural logarithm of X . For input of a complex number, Z = X + i Y, the complex number can be rewritten as Z = R exp( i θ), where R = abs(Z) and θ = atan(y,x). The complex natural log is then given by, alog(Z) = alog(R) + i θ In the above formula, the use of the ...",t:"ALOG "},"9":{i:0.000112065884284975,u:"../Content/Reference Material/A/ALOG2.htm",a:"The ALOG2 function returns the logarithm to the base 2 of X . For input of a complex number, Z = X + iY, the complex number can be rewritten as Z = R exp(iq), where R = abs(Z) and q = atan(y,x). The complex log base 2 is then given by, alog2(Z) = alog2(R) + i q/alog(2) In the above formula, the use ...",t:"ALOG2"},"10":{i:0.000111232650227001,u:"../Content/Reference Material/A/ALOG10.htm",a:"The ALOG10 function returns the logarithm to the base 10 of X . For input of a complex number, Z = X + iY, the complex number can be rewritten as Z = R exp(iq), where R = abs(Z) and q = atan(y,x). The complex log base 10 is then given by, alog10(Z) = alog10(R) + i q/alog(10) In the above formula, ...",t:"ALOG10 "},"11":{i:0.000286936612117367,u:"../Content/Reference Material/A/AMOEBA.htm",a:"The AMOEBA function performs multidimensional minimization of a function Func ( x ), where x is an n -dimensional vector, using the downhill simplex method 1 . The downhill simplex method is not as efficient as Powell’s method, and usually requires more function evaluations. However, the simplex ...",t:"AMOEBA "},"12":{i:0.000222325047907655,u:"../Content/Reference Material/A/ANNOTATE.htm",a:"The ANNOTATE procedure starts an IDL widget program that allows you to interactively annotate images and plots with text and drawings. Drawing objects include lines, arrows, polygons, rectangles, circles, and ellipses. Annotation files can be saved and restored, and annotated displays can be written ...",t:"ANNOTATE Procedure"},"13":{i:0.000298105819869676,u:"../Content/Reference Material/A/APP_USER_DIR.htm",a:"The APP_USER_DIR function provides access to the IDL application user directory . The application user directory is a location where IDL, and applications written in IDL, can store user-specific data that will persist between IDL sessions. For example, the IDL iTools store user-specified ...",t:"APP_USER_DIR"},"14":{i:0.000139812381889304,u:"../Content/Reference Material/A/APP_USER_DIR_QUERY.htm",a:"The APP_USER_DIR_QUERY function is used to locate existing application user directories previously created by the APP_USER_DIR function. An IDL application can use APP_USER_DIR_QUERY to locate the directories that were used by other (presumably older) versions of itself. A newly installed version ...",t:"APP_USER_DIR_QUERY"},"15":{i:0.000157452122793456,u:"../Content/Reference Material/A/ARG_PRESENT.htm",a:"The ARG_PRESENT function is useful in user-written procedures that need to know if the lifetime of a value they are creating extends beyond the current routine’s lifetime. This can be important for two reasons: To avoid expensive computations that the caller is not interested in. To prevent heap ...",t:"ARG_PRESENT "},"16":{i:0.000160428332894163,u:"../Content/Reference Material/A/ARRAY_EQUAL.htm",a:"See also the IDL_Variable::Equals and IDL_Variable::HasValue methods, which provide similar functionality but with an object-oriented interface. The ARRAY_EQUAL function is a fast way to compare data for equality in situations where the index of the elements that differ are not of interest. This ...",t:"ARRAY_EQUAL"},"17":{i:0.000471889117549186,u:"../Content/Reference Material/A/ARRAY_INDICES.htm",a:"The ARRAY_INDICES function converts one-dimensional subscripts of an array into corresponding multi-dimensional subscripts. This routine is written in the IDL language. Its source code can be found in the file array_indices.pro in the lib subdirectory of the IDL distribution. Examples Example 1 This ...",t:"ARRAY_INDICES"},"18":{i:0.000152057679400016,u:"../Content/Reference Material/A/ARROW.htm",a:"The ARROW function draws an arrow or multiple arrows between points. The ARROW function draws arrows from one (X, Y) location to another (X, Y) location, either as an annotation or within the data space. The VECTOR function may be used to draw a vector field or wind field (in arbitrary units) at a ...",t:"ARROW"},"19":{i:7.11238525810249E-05,u:"../Content/Reference Material/A/ARROW_Procedure.htm",a:"The ARROW procedure draws one or more vectors with arrow heads. This routine is written in the IDL language. Its source code can be found in the file arrow.pro in the lib subdirectory of the IDL distribution. Examples Draw an arrow from (100,150) to (300,350) in DEVICE units: ARROW, 100, 150, 300, ...",t:"ARROW Procedure"},"20":{i:0.000592869324305521,u:"../Content/Reference Material/A/ASCII_TEMPLATE.htm",a:"The ASCII_TEMPLATE function presents a graphical user interface (GUI) which generates a template defining an ASCII file format. Templates are IDL structure variables that may be used when reading ASCII files with the READ_ASCII routine. See READ_ASCII for details on reading ASCII files. This routine ...",t:"ASCII_TEMPLATE "},"21":{i:0.00026847693824301,u:"../Content/Reference Material/A/ASIN.htm",a:"The ASIN function returns the angle, expressed in radians, whose sine is X (i.e., the arc-sine). For real input, the range of ASIN is between -∏/2 and ∏/2. For input of a complex number, Z = X + iY, the complex arcsine is given by, asin(Z) = asin(B) + i alog(A + sqrt(A 2 - 1))   if Y \u003e= 0 asin(Z) = ...",t:"ASIN "},"22":{i:0.000383411242270808,u:"../Content/Reference Material/A/ASSOC.htm",a:"The ASSOC function associates an array structure with a file. It provides a basic method of random access input/output in IDL. Unformatted data files generated by FORTRAN programs under UNIX contain an extra long word before and after each logical record in the file. ASSOC does not interpret these ...",t:"ASSOC "},"23":{i:0.000316254197786827,u:"../Content/Reference Material/A/ATAN.htm",a:"The ATAN function returns the angle, expressed in radians, whose tangent is X (i.e., the arc-tangent). If two parameters are supplied, the angle whose tangent is equal to Y/X is returned. For real input, the range of ATAN is between -∏/2 and ∏/2 for the single argument case, and between -∏ and ∏ if ...",t:"ATAN "},"24":{i:0.000289691635808027,u:"../Content/Reference Material/A/AXIS.htm",a:"The AXIS function adds an axis to an existing IDL Graphic. Example The following lines create the graphic shown on the right.  tstart = JULDAY(1,1,2000,0,0,0) tend = JULDAY(1,5,2000,0,0,0) time = TIMEGEN(START=tstart, FINAL=tend, UNITS=\u0027Hours\u0027) data = 20*BESELJ(FINDGEN(97)/4, 1) p = PLOT(time, data, ...",t:"AXIS"},"25":{i:0.000162424164453917,u:"../Content/Reference Material/A/AXIS_Procedure.htm",a:"The AXIS procedure draws an axis of the specified type and scale at a given position. It can be used to add additional axes to plots or to draw axes at a specified position. The new scale is saved for use by subsequent overplots if the SAVE keyword parameter is set. By default, AXIS draws an X axis. ...",t:"AXIS Procedure"},"26":{i:5.50327019655568E-05,u:"../Content/Reference Material/B/B_list.htm",a:"B Routines ",t:"B Routines"},"27":{i:0.000404396391351849,u:"../Content/Reference Material/B/BANDPASS_FILTER.htm",a:"The BANDPASS_FILTER function applies a bandpass filter to a one-channel image. A bandpass filter is useful when the general location of the noise in the frequency domain is known. The bandpass filter allows frequencies within the chosen range through and attenuates frequencies outside of the given ...",t:"BANDPASS_FILTER"},"28":{i:0.000404396391351849,u:"../Content/Reference Material/B/BANDREJECT_FILTER.htm",a:"The BANDREJECT_FILTER function applies a band reject filter on a one-channel image. A band reject filter is useful when the general location of the noise in the frequency domain is known. A band reject filter blocks frequencies within the chosen range and lets frequencies outside of the range pass ...",t:"BANDREJECT_FILTER"},"29":{i:0.000488041158562212,u:"../Content/Reference Material/B/BARPLOT.htm",a:"The BARPLOT function plots data as a series of rectangular bars. Example The following lines create the plot shown. ; Define the data Pine_Warbler = [0, 0, 13, 18, 41, 82, 59] Yellow_Warbler = [30, 101, 312, 267, 330, 384, 191] Year = [1970, 1975, 1980, 1985, 1990, 1995, 2000]  ; Create the first ...",t:"BARPLOT"},"30":{i:7.11238525810249E-05,u:"../Content/Reference Material/B/BAR_PLOT_Procedure.htm",a:"Please see the BARPLOT function, which replicates the functionality of this routine and offers an interactive interface. The BAR_PLOT procedure creates a bar graph. This routine is written in the IDL language. Its source code can be found in the file bar_plot.pro in the lib subdirectory of the IDL ...",t:"BAR_PLOT Procedure"},"31":{i:0.00024748887170734,u:"../Content/Reference Material/B/BEGIN___END.htm",a:"The BEGIN...END statement defines a block of statements. A block of statements is a group of statements that is treated as a single statement. Blocks are necessary when more than one statement is the subject of a conditional or repetitive statement. Syntax BEGIN statements END | ENDIF | ENDELSE | ...",t:"BEGIN...END "},"32":{i:0.000368202697321914,u:"../Content/Reference Material/B/BESELI.htm",a:"The BESELI function returns the I Bessel function of order N for the argument X . Examples The following example plots the I and K Bessel functions for orders 0, 1 and 2: X = FINDGEN(40)/10 ;Plot I and K Bessel Functions: PLOT, X, BESELI(X, 0), MAX_VALUE=4, $ TITLE = \u0027I and K Bessel Functions\u0027 ...",t:"BESELI "},"33":{i:0.000368202697321914,u:"../Content/Reference Material/B/BESELJ.htm",a:"The BESELJ function returns the J Bessel function of order N for the argument X . Example The following lines create the map shown at the top of this topic. ; Plot the J and Y Bessel functions for orders 0, 1, and 2  X = FINDGEN(100)/10  ; Plot J and Y Bessel Functions pj0 = PLOT(X, BESELJ(X, 0), ...",t:"BESELJ "},"34":{i:0.000368202697321914,u:"../Content/Reference Material/B/BESELK.htm",a:"The BESELK function returns the K Bessel function of order N for the argument X . Examples The following example plots the I and K Bessel functions for orders 0, 1 and 2: X = FINDGEN(40)/10 ;Plot I and K Bessel Functions: PLOT, X, BESELI(X, 0), MAX_VALUE=4, $ TITLE = \u0027I and K Bessel Functions\u0027 ...",t:"BESELK"},"35":{i:0.000368202697321914,u:"../Content/Reference Material/B/BESELY.htm",a:"The BESELY function returns the Y Bessel function of order N for the argument X . Examples The following example plots the J and Y Bessel functions for orders 0, 1, and 2: X = FINDGEN(100)/10 ;Plot J and Y Bessel Functions: PLOT, X, BESELJ(X, 0), TITLE = \u0027J and Y Bessel Functions\u0027 OPLOT, X, ...",t:"BESELY "},"36":{i:0.000238938141807008,u:"../Content/Reference Material/B/BETA.htm",a:"The BETA routine returns the value of the Euler beta function B( Z, W ). The Euler beta function is defined as:  for This routine is written in the IDL language. Its source code can be found in the file beta.pro in the lib subdirectory of the IDL distribution. Examples To evaluate the beta function ...",t:"BETA "},"37":{i:0.000198259938701185,u:"../Content/Reference Material/B/BIGINTEGER.htm",a:"The BigInteger class allows you to create and manipulate integer numbers of any size. The BigInteger class stores a number as an array of unsigned, 32-bit integer \"digits\" with a radix, or base, of 4294967296. The class stores the digits in little-endian order, with the most-significant digit at the ...",t:"BigInteger"},"38":{i:0.000353216221715158,u:"../Content/Reference Material/B/BILINEAR.htm",a:"The BILINEAR function uses a bilinear interpolation algorithm to compute the value of a data array at each of a set of subscript values. This routine is written in the IDL language. Its source code can be found in the file bilinear.pro in the lib subdirectory of the IDL distribution. Examples Create ...",t:"BILINEAR "},"39":{i:0.000201031214205125,u:"../Content/Reference Material/B/BIN_DATE.htm",a:"The BIN_DATE function converts a standard form ASCII date/time string to a binary string. This routine is written in the IDL language. Its source code can be found in the file bin_date.pro in the lib subdirectory of the IDL distribution. Examples Convert a random time of the day to binary: time = ...",t:"BIN_DATE "},"40":{i:0.000405812025519008,u:"../Content/Reference Material/B/BINARY_TEMPLATE.htm",a:"The BINARY_TEMPLATE function presents a graphical user interface which allows the user to interactively generate a template structure for use with READ_BINARY. The graphical user interface allows the user to define one or more fields in the binary file. The file may be big, little, or native byte ...",t:"BINARY_TEMPLATE "},"41":{i:7.41112348156038E-05,u:"../Content/Reference Material/B/BINDGEN.htm",a:"The BINDGEN function creates a byte array with the specified dimensions. Each element of the array is set to the value of its one-dimensional subscript, converted to type byte. Example As an example, create a four-element by four-element byte array and store the result in the variable A. Copy and ...",t:"BINDGEN"},"42":{i:0.000516226888012395,u:"../Content/Reference Material/B/BINOMIAL.htm",a:"The BINOMIAL function computes the probability that in a cumulative binomial (Bernoulli) distribution, a random variable X is greater than or equal to a user-specified value V , given N independent performances and a probability of occurrence or success P in a single performance: This routine is ...",t:"BINOMIAL "},"43":{i:5.50327019655568E-05,u:"../Content/Reference Material/B/BIT_FFS.htm",a:"The BIT_FFS function returns the index of the first bit set (non-zero) in its integer argument. Example Binary integer arithmetic has the property that any integer value with a single bit set is a power of 2. For example, the value 1024 is equivalent to 2 10 . The following statement uses BIT_FFS to ...",t:"BIT_FFS"},"44":{i:5.50327019655568E-05,u:"../Content/Reference Material/B/BIT_POPULATION.htm",a:"The BIT_POPULATION function returns the number of set (non-zero) bits in its integer argument. Example The following statement displays the number of bits in an IDL long integer: PRINT, BIT_POPULATION(\u0027ffffffff\u0027xl) IDL prints: 32 Syntax Result = BIT_POPULATION( Value ) Return Value BIT_POPULATION ...",t:"BIT_POPULATION"},"45":{i:0.000102251280656836,u:"../Content/Reference Material/B/BLAS_AXPY.htm",a:"The BLAS_AXPY procedure updates an existing array by adding a multiple of another array. It can also be used to update one or more one-dimensional subvectors of an array according to the following vector operation: where a is a scale factor and X is an input vector. BLAS_AXPY can be faster and use ...",t:"BLAS_AXPY"},"46":{i:0.000284586413778043,u:"../Content/Reference Material/B/BLK_CON.htm",a:"The BLK_CON function computes a “fast convolution” of a digital signal and an impulse-response sequence. It returns the filtered signal. This routine is written in the IDL language. Its source code can be found in the file blk_con.pro in the lib subdirectory of the IDL distribution. Example The ...",t:"BLK_CON "},"47":{i:9.68272049888169E-05,u:"../Content/Reference Material/B/BOOLARR.htm",a:"The BOOLARR function creates a boolean vector or array with every element set to false (0). Examples To create B as a 3 by 3 by 5 boolean array, enter: B = BOOLARR(3, 3, 5) PRINT, B Syntax Result = BOOLARR( D 1 [ , ..., D 8 ] ) Return Value This function returns a byte vector or array. Arguments D i ...",t:"BOOLARR "},"48":{i:0.000183308135525987,u:"../Content/Reference Material/B/BOOLEAN.htm",a:"The BOOLEAN function returns a result equal to Expression converted to boolean. Notes A boolean variable is actually a variable of type byte with a special boolean flag. The type code for boolean variables is 1 (the same as byte). You can use the ISA function with the BOOLEAN keyword to determine if ...",t:"BOOLEAN "},"49":{i:0.000187848637212439,u:"../Content/Reference Material/B/BOXPLOT.htm",a:"The BOXPLOT function creates a box and whiskers plot from a data series containing a sample minimum, lower quartile, median, upper quartile, and sample maximum. Examples Copy and paste the following lines at the IDL command line to create the plot shown above: ; Create an array of the prairie dog ...",t:"BOXPLOT"},"50":{i:7.11238525810249E-05,u:"../Content/Reference Material/B/BOX_CURSOR_Procedure.htm",a:"The BOX_CURSOR procedure emulates the operation of a variable-sized box cursor (also known as a “marquee” selector). BOX_CURSOR does not function properly when used within a draw widget. See the BUTTON_EVENTS and MOTION_EVENTS keywords in WIDGET_DRAW . This routine is written in the IDL language. ...",t:"BOX_CURSOR Procedure"},"51":{i:0.000275118017634387,u:"../Content/Reference Material/B/BREAK.htm",a:"The BREAK statement provides a convenient way to immediately exit from a loop (FOR, FOREACH, WHILE, REPEAT), CASE, or SWITCH statement without resorting to GOTO statements. Syntax BREAK Examples This example exits the enclosing WHILE loop when the value of i hits 5. PRO count I = 0 PRINT, \u0027Initial ...",t:"BREAK "},"52":{i:0.000826435398967601,u:"../Content/Reference Material/B/BREAKPOINT.htm",a:"The BREAKPOINT procedure allows you to insert and remove breakpoints in programs for debugging. A breakpoint causes program execution to stop after the designated statement is executed. Breakpoints are specified using the source file name and line number. For multiple-line statements (statements ...",t:"BREAKPOINT "},"53":{i:0.00049485147832727,u:"../Content/Reference Material/B/BROYDEN.htm",a:"The BROYDEN function solves a system of n nonlinear equations (where n ≥ 2) in n dimensions using a globally-convergent Broyden’s method. Examples We can use BROYDEN to solve the non-linear system of equations defined by the BROYFUNC function above: FUNCTION broyfunc, X RETURN, ...",t:"BROYDEN "},"54":{i:0.000107793802480799,u:"../Content/Reference Material/B/BUBBLEPLOT.htm",a:"The BUBBLEPLOT function creates a bubble chart that displays three dimensions of data in a two-dimensional Cartesian coordinate system. A bubble chart is similar to a scatter plot except that it additionally displays the magnitude of the data at a given ( x, y ) position. BUBBLEPLOT() accepts data ...",t:"BUBBLEPLOT"},"55":{i:0.000380723997105585,u:"../Content/Reference Material/B/BUTTERWORTH.htm",a:"The BUTTERWORTH function returns an array that contains the absolute value of the low-pass Butterworth kernel. In practice, it is useful for filtering out high-frequency noise. This routine is written in the IDL language. Its source code can be found in the file butterworth.pro in the lib ...",t:"BUTTERWORTH"},"56":{i:0.000425394322463253,u:"../Content/Reference Material/B/BYTARR.htm",a:"The BYTARR function creates a byte vector or array. Examples To create B as a 3 by 3 by 5 byte array where each element is set to a random value, enter: B = BYTARR(3, 3, 5, /NOZERO) PRINT, B Syntax Result = BYTARR( D 1 [ , ..., D 8 ] [, / NOZERO ] ) Return Value This function returns a byte vector ...",t:"BYTARR "},"57":{i:0.000626056805382806,u:"../Content/Reference Material/B/BYTE.htm",a:"The BYTE function returns a result equal to Expression converted to byte type. If Expression is a string, each string is converted to a byte vector of the same length as the string. Each element of the vector is the character code of the corresponding character in the string. The BYTE function can ...",t:"BYTE "},"58":{i:0.000241807832160383,u:"../Content/Reference Material/B/BYTEORDER.htm",a:"The BYTEORDER procedure converts integers between host and network byte ordering or floating-point values between the native format and XDR (IEEE) format. This routine can also be used to swap the order of bytes within both short and long integers. If the type of byte swapping is not specified via ...",t:"BYTEORDER "},"59":{i:0.000422303230994055,u:"../Content/Reference Material/B/BYTSCL.htm",a:"The BYTSCL function scales all values of Array that lie in the range ( Min ≤ x ≤ Max ) into the range (0 ≤ x ≤ Top ). Additionally, the result is returned as type BYTE. For floating-point input, each value is scaled using the formula ( Top + 0.9999) * ( x - Min )/( Max - Min ). For integer input, ...",t:"BYTSCL "},"60":{i:5.50327019655568E-05,u:"../Content/Reference Material/C/C_list.htm",a:"C Routines ",t:"C Routines"},"61":{i:0.00058945569046066,u:"../Content/Reference Material/C/C_CORRELATE.htm",a:"The C_CORRELATE function computes the cross correlation Pxy ( L ) or cross covariance Rxy ( L ) of two sample populations X and Y as a function of the lag L where x and y are the means of the sample populations x = ( x 0 , x 1 , x 2 , ... , x N-1 ) and y = ( y 0 , y 1 , y 2 , ... , y N-1 ), ...",t:"C_CORRELATE "},"62":{i:0.000150037138952046,u:"../Content/Reference Material/C/CALENDAR_Procedure.htm",a:"The CALENDAR procedure displays a calendar for a month or an entire year on the current plotting device. This IDL routine imitates the UNIX cal command. This routine is written in the IDL language. Its source code can be found in the file calendar.pro in the lib subdirectory of the IDL distribution. ...",t:"CALENDAR Procedure"},"63":{i:0.000609681212230822,u:"../Content/Reference Material/C/CALDAT.htm",a:"The CALDAT procedure computes the month, day, year, hour, minute, or second corresponding to a given Julian date. The inverse of this procedure is JULDAY . Notes The Julian calendar, established by Julius Caesar in the year 45 BCE, was corrected by Pope Gregory XIII in 1582, excising ten days from ...",t:"CALDAT "},"64":{i:0.000845015727340839,u:"../Content/Reference Material/C/CALL_EXTERNAL.htm",a:"The CALL_EXTERNAL function calls a function in an external sharable object and returns a scalar value. Parameters can be passed by reference (the default) or by value. See Chapter 3, “Using CALL_EXTERNAL” ( External Development Guide in the help/pdf directory of your IDL installation) for examples. ...",t:"CALL_EXTERNAL "},"65":{i:0.000546544470279613,u:"../Content/Reference Material/C/CALL_FUNCTION.htm",a:"CALL_FUNCTION function calls the IDL function specified by the string Name , passing any additional parameters as its arguments. Although not as flexible as the EXECUTE function, CALL_FUNCTION is much faster. Therefore, CALL_FUNCTION should be used in preference to EXECUTE whenever possible. ...",t:"CALL_FUNCTION "},"66":{i:0.00048963099202199,u:"../Content/Reference Material/C/CALL_METHOD.htm",a:"The CALL_METHOD function or procedure calls an object method by name, passing any additional parameters as its arguments. CALL_METHOD is useful when you want to dynamically determine the method to call at run-time instead of compile-time. Although not as flexible as EXECUTE , CALL_METHOD is much ...",t:"CALL_METHOD "},"67":{i:0.0004355801828927,u:"../Content/Reference Material/C/CALL_PROCEDURE.htm",a:"CALL_PROCEDURE calls the procedure specified by Name , passing any additional parameters as its arguments. Although not as flexible as the EXECUTE function, CALL_PROCEDURE is much faster. Therefore, CALL_PROCEDURE should be used in preference to EXECUTE whenever possible. Example The following ...",t:"CALL_PROCEDURE "},"68":{i:0.000380723997105585,u:"../Content/Reference Material/C/CANNY.htm",a:"The CANNY function implements the Canny edge-detection algorithm. The Canny edge-detection algorithm has the following steps: Smooth the image with a Gaussian filter. A 5x5 kernel with a given sigma is used. Compute the gradient orientation and magnitude. A pair of 3x3 convolution masks are used, ...",t:"CANNY"},"69":{i:0.000306128207982794,u:"../Content/Reference Material/C/CASE.htm",a:"The CASE statement selects one, and only one, statement or block of statements for execution, depending on the value of an expression. This expression is called the case selector expression. Each statement that is part of a CASE statement is preceded by an expression that is compared to the value of ...",t:"CASE "},"70":{i:0.0011364461426921,u:"../Content/Reference Material/C/CATCH.htm",a:"The CATCH procedure provides a generalized mechanism for the handling of exceptions and errors within IDL. Calling CATCH establishes an error handler for the current procedure that intercepts all errors that can be handled by IDL, excluding non-fatal warnings such as math errors (e.g., ...",t:"CATCH "},"71":{i:0.000643940926624175,u:"../Content/Reference Material/C/CD.htm",a:"The CD procedure is used to set and/or change the current working directory. This routine changes the working directory for the IDL session and any child processes started from IDL during that session after the directory change is made. Under UNIX, CD does not affect the working directory of the ...",t:"CD "},"72":{i:6.24355967687319E-05,u:"../Content/Reference Material/C/CDF_Routines.htm",a:"CDF Routines CDF Overview ",t:"CDF Routines"},"73":{i:0.000476011580441959,u:"../Content/Reference Material/C/CDF Routines/CDF_ATTCREATE.htm",a:"The CDF_ATTCREATE function creates a new attribute in the specified Common Data Format file. If successful, the attribute ID is returned. Examples id = CDF_OPEN(\u0027test\u0027) ; Create a CDF file. xx = CDF_ATTCREATE(id, \u0027Attribute-1\u0027, /GLOBAL_SCOPE) CDF_ATTRENAME, id, \u0027Attribute-1\u0027, \u0027My Favorite Attribute\u0027 ...",t:"CDF_ATTCREATE"},"74":{i:8.26753698764147E-05,u:"../Content/Reference Material/C/CDF Routines/CDF_ATTDELETE.htm",a:"The CDF_ATTDELETE procedure deletes an attribute from the specified CDF file. Note that the attribute’s entries are also deleted, and that the attributes that numerically follow the deleted attribute within the CDF file are automatically renumbered. Examples cid = CDF_CREATE(\u0027DEMOattdelete\u0027) ...",t:"CDF_ATTDELETE"},"75":{i:7.14036033262812E-05,u:"../Content/Reference Material/C/CDF Routines/CDF_ATTEXISTS.htm",a:"The CDF_ATTEXISTS function determines whether a given attribute exists in the specified CDF file. Attributes may be specified by name or number. Examples Create a function to test an attribute’s existence and return a string: FUNCTION exists, cdfid, attname_or_number IF CDF_ATTEXISTS(cdfid, ...",t:"CDF_ATTEXISTS"},"76":{i:0.000194921859741148,u:"../Content/Reference Material/C/CDF Routines/CDF_ATTGET.htm",a:"The CDF_ATTGET procedure reads an attribute entry from a CDF file. Examples ; Open the CDF file created in the CDF_ATTPUT example: id = CDF_OPEN(\u0027foo\u0027) CDF_ATTGET, id, \u0027Attribute2\u0027, \u0027Var2\u0027, x PRINT, X, FORMAT=\u0027(\"[\",9(X,F3.1,\",\"),X,F3.1,\"]\")\u0027 CDF_CLOSE, id ; Close the CDF file. IDL Output [ 0.0, 1.0, ...",t:"CDF_ATTGET"},});