define({"364":{i:6.98828078775762E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_INQATTRS.htm",a:"This function retrieves information about attributes defined in swath. The attribute list is returned as a string with each attribute name separated by commas. See STRSPLIT to separate the attribute list. Examples nattr = EOS_SW_INQATTRS(swathID, attrlist) Syntax Result = EOS_SW_INQATTRS( swathID , ...",t:"EOS_SW_INQATTRS"},"365":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_INQDATAFIELDS.htm",a:"This function retrieves information about all of the data fields defined in swath. The field list is returned as a string with each data field separated by commas. The rank and numbertype arrays will have an entry for each field. See STRSPLIT to separate the field list. Examples nflds = ...",t:"EOS_SW_INQDATAFIELDS"},"366":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_INQDIMS.htm",a:"This function retrieves information about all of the dimensions defined in swath. The dimension list is returned as a string with each dimension name separated by commas. See STRSPLIT to separate the dimension list. Examples ndims = EOS_SW_INQDIMS(swathID, dimname, dims) Syntax Result = ...",t:"EOS_SW_INQDIMS"},"367":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_INQGEOFIELDS.htm",a:"This function retrieves information about all of the geolocation fields defined in swath. The field list is returned as a string with each geolocation field separated by commas. The rank and numbertype arrays will have an entry for each field. See STRSPLIT to separate the field list. Examples nflds ...",t:"EOS_SW_INQGEOFIELDS"},"368":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_INQIDXMAPS.htm",a:"This function retrieves information about all of the indexed geolocation/data mappings defined in swath. The dimension mapping list is returned as a string with each mapping separated by commas. The two dimensions in each mapping are separated by a slash (/). See STRSPLIT to separate the mapping ...",t:"EOS_SW_INQIDXMAPS"},"369":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_INQMAPS.htm",a:"This function retrieves information about all of the (non-indexed) geolocation relations defined in swath. The dimension mapping list is returned as a string with each mapping separated by commas. The two dimensions in each mapping are separated by a slash (/). See STRSPLIT to separate the mapping ...",t:"EOS_SW_INQMAPS"},"370":{i:9.57090966120056E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_INQSWATH.htm",a:"This function retrieves number and names of swaths defined in the HDF-EOS file. The swath list is returned as a string with each swath name separated by commas. See STRSPLIT to separate the swath list. Examples In this example, we retrieve information about the swaths defined in an HDF-EOS file, ...",t:"EOS_SW_INQSWATH"},"371":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_MAPINFO.htm",a:"This function retrieves the offset and increment of the specified geolocation mapping. Examples In this example, we retrieve information about the mapping between the GeoTrack and DataTrack dimensions: status = EOS_SW_MAPINFO(swathID, \"GeoTrack\", \"DataTrack\", $ offset, increment) Syntax Result = ...",t:"EOS_SW_MAPINFO"},"372":{i:7.6789836178486E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_NENTRIES.htm",a:"This function returns number of entries and descriptive string buffer size for a specified entity. This function can be called before an inquiry routine in order to determine the sizes of the output arrays and descriptive strings. Examples In this example, we determine the number of dimension ...",t:"EOS_SW_NENTRIES"},"373":{i:0.000366875705816166,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_OPEN.htm",a:"This function creates a new file or opens an existing file. Examples In this example, we create a new swath file named, SwathFile.hdf. It returns the file handle, fid: fid = EOS_SW_OPEN(\"SwathFile.hdf\", /CREATE) Syntax Result = EOS_SW_OPEN( filename [, / CREATE ] [, / RDWR | , / READ ] ) Return ...",t:"EOS_SW_OPEN"},"374":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_PERIODINFO.htm",a:"This function returns information about a subsetted time period for a particular field. Because of differences in number type and geolocation mapping, a given time period will give different values for the dimensions and size for various fields. Array ordering of variables used or returned by this ...",t:"EOS_SW_PERIODINFO"},"375":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_QUERY.htm",a:"The EOS_SW_QUERY function returns information about a specified swath. Syntax Result =EOS_SW_QUERY( Filename , SwathName , [ Info ]) Return Value This function returns an integer value of 1 if the file is an HDF file with EOS SWATH extensions, and 0 otherwise. Arguments Filename A string containing ...",t:"EOS_SW_QUERY"},"376":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_READATTR.htm",a:"This function reads attributes from a swath field. Examples In this example, we read a single precision (32-bit) floating-point attribute with the name “ScalarFloat”: status = EOS_SW_READATTR(swathID, \"ScalarFloat\", f32) Syntax Result = EOS_SW_READATTR( swathID , attrname , datbuf ) Return Value ...",t:"EOS_SW_READATTR"},"377":{i:7.6789836178486E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_READFIELD.htm",a:"This function reads data from a swath field. The values within start, stride, and edge arrays refer to the swath field (input) dimensions. The default values for start and stride are 0 and 1 respectively if these keywords are not set. The default value for edge is (dim – start) / stride where dim ...",t:"EOS_SW_READFIELD"},"378":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_REGIONINFO.htm",a:"This function returns information about a subsetted region for a particular field. Because of differences in number type and geolocation mapping, a given region will give different values for the dimensions and size for various fields. Array ordering of variables used or returned by this routine ...",t:"EOS_SW_REGIONINFO"},"379":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_SETFILLVALUE.htm",a:"This function sets the fill value for the specified field. The fill value is placed in all elements of the field that have not been explicitly defined. Examples In this example, we set a fill value for the “Temperature” field: tempfill = -999.0 status = EOS_SW_SETFILLVALUE(swathID, \"Temperature\", ...",t:"EOS_SW_SETFILLVALUE"},"380":{i:7.6789836178486E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_WRITEATTR.htm",a:"This function writes/updates attributes in a swath. If the attribute does not exist, it is created. If it does exist, then the value is updated. Examples In this example, we write a single precision (32 bit) floating point number with the name “ScalarFloat” and the value 3.14: f32 = 3.14 status = ...",t:"EOS_SW_WRITEATTR"},"381":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_WRITEDATAMETA.htm",a:"This function writes field metadata for an existing data field. This is useful when the data field was defined without using the swath API. Note that any entries in the dimension list must be defined through the EOS_SW_DEFDIM function before this function is called. Array ordering of variables used ...",t:"EOS_SW_WRITEDATAMETA"},"382":{i:7.6789836178486E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_WRITEFIELD.htm",a:"This function writes data to a swath field. The values within start, stride, and edge arrays refer to the swath field (output) dimensions. The default values for start and stride are 0 and 1 respectively and are used if keywords are not set. The default value for edge is (dim – start) / stride where ...",t:"EOS_SW_WRITEFIELD"},"383":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF-EOS Routines/EOS_SW_WRITEGEOMETA.htm",a:"This function writes field metadata for an existing geolocation field. This is useful when the data field was defined without using the swath API. Note that any entries in the dimension list must be defined through the EOS_SW_DEFDIM function before this function is called. Array ordering of ...",t:"EOS_SW_WRITEGEOMETA"},"384":{i:0.000132262559571748,u:"../Content/Reference Material/E/ERASE_Procedure.htm",a:"The ERASE procedure erases the screen of the currently selected graphics device (or starts a new page if the device is a printer). The device is reset to alphanumeric mode if it has such a mode (e.g., Tektronix terminals). Examples Display a simple image in the current window, then erase it: TV, ...",t:"ERASE Procedure"},"385":{i:0.000136858558780657,u:"../Content/Reference Material/E/ERF.htm",a:"The ERF function returns the value of the error function: For real input, the error function is computed using rational functions, as described in “Rational Chebyshev approximations for the error function,” W. J. Cody, Math. Comp., 1969, pp. 631-638. For complex input, the error function is computed ...",t:"ERF "},"386":{i:0.000150478094429009,u:"../Content/Reference Material/E/ERFC.htm",a:"The ERFC function returns the value of the complementary error function: For real input, ERFC is computed using rational functions, as described in “Rational Chebyshev approximations for the error function,” W. J. Cody, Math. Comp., 1969, pp. 631-638. For complex input, ERFC is computed as 1 - ERF( ...",t:"ERFC "},"387":{i:0.000117255620837196,u:"../Content/Reference Material/E/ERFCX.htm",a:"The ERFCX function returns the value of the scaled complementary error function: For real input, ERFCX is computed using rational functions, as described in “Rational Chebyshev approximations for the error function,” W. J. Cody, Math. Comp., 1969, pp. 631-638. For complex input, ERFCX is computed as ...",t:"ERFCX "},"388":{i:0.000379069495324707,u:"../Content/Reference Material/E/ERODE.htm",a:"The ERODE function implements the erosion operator on binary and grayscale images and vectors. This operator is commonly known as “shrink” or “reduce”. Using ERODE See the description of the DILATE function for background on morphological operators. Erosion is the dual of dilation. It does to the ...",t:"ERODE "},"389":{i:0.000436583462800033,u:"../Content/Reference Material/E/ERRORPLOT.htm",a:"The ERRORPLOT function draws a simple line plot, with error bars surrounding each vertex. You can create plots with both symmetric and asymmetric error bars. Example The following lines create the plot shown at the right. y = [20.1, 19.9, 20.0, 20.0, 19.9, 20.0] yerror = [0.329, 0.186, 0.147, 0.086, ...",t:"ERRORPLOT"},"390":{i:0.000119893885144884,u:"../Content/Reference Material/E/ERRPLOT_Procedure.htm",a:"The new ERRORPLOT function has replaced much of the functionality of the ERRPLOT procedure. The ERRPLOT procedure plots error bars over a previously drawn plot. This routine is written in the IDL language. Its source code can be found in the file errplot.pro in the lib subdirectory of the IDL ...",t:"ERRPLOT Procedure"},"391":{i:0.000404396391351849,u:"../Content/Reference Material/E/ESTIMATOR_FILTER.htm",a:"The ESTIMATOR_FILTER function applies an order statistic noise-reduction filter to a one-channel image. For each pixel in the image, the estimator filter analyzes the neighboring pixels. The order statistic estimator is computed for this neighborhood and the pixel is replaced by the result. This ...",t:"ESTIMATOR_FILTER"},"392":{i:0.000732582268141851,u:"../Content/Reference Material/E/EXECUTE.htm",a:"The EXECUTE function compiles and executes one or more IDL statements contained in a string at run-time. EXECUTE is limited by two factors: The need to compile the string at runtime makes EXECUTE inefficient in terms of speed. The EXECUTE function cannot be used in code that runs in the IDL Virtual ...",t:"EXECUTE "},"393":{i:0.000371084573506424,u:"../Content/Reference Material/E/EXIT.htm",a:"The EXIT procedure quits IDL and exits back to the operating system. All buffers are flushed and open files are closed. The values of all variables that were not saved are lost. See Notes on the EXIT Procedure for more information on this topic. Syntax EXIT [, / NO_CONFIRM ] [, STATUS = code ] ...",t:"EXIT "},"394":{i:8.57867753842261E-05,u:"../Content/Reference Material/E/EXP.htm",a:"The EXP function returns the natural exponential function of Expression . Examples  Example 1 Plot a Gaussian distribution with a 1/e width of 10 and a center of 50 by entering: myPlot = PLOT(EXP(-(FINDGEN(100)/10. - 5.0)^2)) Example 2 Create a simple PLOT of the decay of radioactive tritium (H 3 ) ...",t:"EXP "},"395":{i:7.76486704237332E-05,u:"../Content/Reference Material/E/EXPAND.htm",a:"The EXPAND procedure shrinks or expands a two-dimensional array, using bilinear interpolation. It is similar to the CONGRID and REBIN routines. This routine is written in the IDL language. Its source code can be found in the file expand.pro in the lib subdirectory of the IDL distribution. Example ...",t:"EXPAND "},"396":{i:0.00167265131210627,u:"../Content/Reference Material/E/EXPAND_PATH.htm",a:"The EXPAND_PATH function is used to expand a simple path-definition string into a full path listing. The returned path can be useful for setting the !PATH, and !HELP_PATH system variables, for example. !PATH is a list of locations where IDL searches for currently undefined procedures and functions. ...",t:"EXPAND_PATH "},"397":{i:0.000170838198973289,u:"../Content/Reference Material/E/EXPINT.htm",a:"The EXPINT function returns the value of the exponential integral E n ( x ). EXPINT is based on the routine expint described in section 6.3 of Numerical Recipes in C: The Art of Scientific Computing (Second Edition), published by Cambridge University Press, and is used by permission. Examples To ...",t:"EXPINT"},"398":{i:5.564819964933E-05,u:"../Content/Reference Material/E/EXTRAC.htm",a:"The EXTRAC function returns a defined portion of an array or vector. The main advantage to EXTRAC is that, when parts of the specified subsection lie outside the bounds of the array, zeros are returned for these outlying elements. It is usually more efficient to use the array subscript ranges (the ...",t:"EXTRAC "},"399":{i:0.000448496343531382,u:"../Content/Reference Material/E/EXTRACT_SLICE.htm",a:"The EXTRACT_SLICE function extracts a specified planar slice of volumetric data. This function allows for a rotation or vector form of the slice equation. In the vector form, the slice plane is governed by the plane equation (ax+by+cz+d = 0) and a single vector which defines the x direction. This ...",t:"EXTRACT_SLICE "},"400":{i:5.50327019655568E-05,u:"../Content/Reference Material/F/F_list.htm",a:"F Routines ",t:"F Routines"},"401":{i:0.000408032265503576,u:"../Content/Reference Material/F/F_CVF.htm",a:"The F_CVF function computes the cutoff value V in an F distribution with degrees of freedom in the numerator and degrees of freedom in the denominator such that the probability that a random variable X is greater than V is equal to a user-supplied probability P . This routine is written in the IDL ...",t:"F_CVF "},"402":{i:0.000486180480269618,u:"../Content/Reference Material/F/F_PDF.htm",a:"The F_PDF function computes cumulative distribution function for an F distribution with defined degrees of freedom in the numerator and denominator. This is the probability P that, in an F distribution, a random variable X is less than or equal to a user-specified cutoff value V . This routine is ...",t:"F_PDF "},"403":{i:0.000160482642035314,u:"../Content/Reference Material/F/FACTORIAL.htm",a:"The FACTORIAL function computes the factorial N ! For integers, the factorial is computed as ( N ) • ( N – 1) • ( N – 2) • ... • 3 • 2 • 1. For non-integers the factorial is computed using GAMMA( N +1 ). This routine is written in the IDL language. Its source code can be found in the file ...",t:"FACTORIAL "},"404":{i:0.000541504308509247,u:"../Content/Reference Material/F/FFT.htm",a:"The FFT function returns a result equal to the complex, discrete Fourier transform of Array . The result of this function is a single- or double-precision complex array. FFT uses a multivariate complex Fourier transform, computed in place with a mixed-radix Fast Fourier Transform algorithm. The FFT ...",t:"FFT "},"405":{i:0.000134218393767427,u:"../Content/Reference Material/F/FFT_PowerSpectrum.htm",a:"The FFT_POWERSPECTRUM function computes the Fourier power spectrum of an array. For a given input signal array, the power spectrum computes the portion of a signal\u0027s power (energy per unit time) falling within given frequency bins. Power is calculated as the average of the squared signal. In the ...",t:"FFT_POWERSPECTRUM"},"406":{i:0.000176145336449816,u:"../Content/Reference Material/F/FILE_BASENAME.htm",a:"The FILE_BASENAME function returns the basename of a file path . A file path is a string containing one or more segments consisting of names separated by directory delimiter characters (slash ( / ) under UNIX, or backslash ( \\ ) under Microsoft Windows). The basename is the final rightmost segment ...",t:"FILE_BASENAME"},"407":{i:0.00016265100129108,u:"../Content/Reference Material/F/FILE_CHMOD.htm",a:"The FILE_CHMOD procedure allows you to change the current access permissions (sometimes known as modes on UNIX platforms) associated with a file or directory. File modes are specified using the standard Posix convention of three protection classes (user, group, other), each containing three ...",t:"FILE_CHMOD "},"408":{i:0.000138368030432313,u:"../Content/Reference Material/F/FILE_COPY.htm",a:"The FILE_COPY procedure copies files, or directories of files, to a new location. FILE_COPY copies files based on their names. To copy data between open files, see the COPY_LUN procedure. Examples Make a backup copy of a file named myroutine.pro in the current working directory: FILE_COPY, ...",t:"FILE_COPY "},"409":{i:0.000138158617224982,u:"../Content/Reference Material/F/FILE_DELETE.htm",a:"The FILE_DELETE procedure deletes a file or empty directory, if the process has the necessary permissions to remove the file as defined by the current operating system. FILE_CHMOD can be used to change file protection settings. On UNIX, if a file to be deleted is a symbolic link, FILE_DELETE deletes ...",t:"FILE_DELETE"},"410":{i:0.000176145336449816,u:"../Content/Reference Material/F/FILE_DIRNAME.htm",a:"The FILE_DIRNAME function returns the dirname of a file path . A file path is a string containing one or more segments consisting of names separated by directory delimiter characters (slash ( / ) under UNIX, or backslash ( \\ ) under Microsoft Windows). The dirname is all of the file path except for ...",t:"FILE_DIRNAME"},"411":{i:7.38069902898774E-05,u:"../Content/Reference Material/F/FILE_EXPAND_PATH.htm",a:"The FILE_EXPAND_PATH function expands a given file or partial directory name to its fully qualified name and returns it regardless of the current working directory. This routine should be used only to make sure that file paths are fully qualified, but not to expand wildcard characters (e.g. *). The ...",t:"FILE_EXPAND_PATH "},"412":{i:0.000583441877132713,u:"../Content/Reference Material/F/FILE_GUNZIP.htm",a:"The FILE_GUNZIP routine uncompresses a given GZIP input file or files, and saves the uncompressed data into a new file or to memory. The uncompression is done using the ZLIB library, written by Jean-Loup Gailly and Mark Adler. This routine is written in the IDL language. Its source code can be found ...",t:"FILE_GUNZIP"},"413":{i:0.000583441877132713,u:"../Content/Reference Material/F/FILE_GZIP.htm",a:"The FILE_GZIP procedure compresses a given input file (or files) using the DEFLATE compression algorithm, and saves the resulting compressed data in the GZIP file format into a new file or to memory. The compression is done using the ZLIB library, written by Jean-Loup Gailly and Mark Adler. This ...",t:"FILE_GZIP"},"414":{i:0.000195019718445966,u:"../Content/Reference Material/F/FILE_INFO.htm",a:"The FILE_INFO function returns status information about a specified file. Examples To get information on the file dist.pro within the IDL User Library: HELP,/STRUCTURE, FILE_INFO(FILEPATH(\u0027dist.pro\u0027, $ SUBDIRECTORY = \u0027lib\u0027)) Executing the above command will produce output similar to: ** Structure ...",t:"FILE_INFO "},"415":{i:7.4158860232066E-05,u:"../Content/Reference Material/F/FILE_LINES.htm",a:"The FILE_LINES function reports the number of lines of text contained within the specified file or files. Text files containing data are very common. To read such a file usually requires knowing how many lines of text it contains. Under UNIX and Windows, there is no special text file type, and it is ...",t:"FILE_LINES "},"416":{i:0.000160227357212228,u:"../Content/Reference Material/F/FILE_LINK.htm",a:"The FILE_LINK procedure creates UNIX file links, both regular (hard) and symbolic. FILE_LINK is available only under UNIX. A hard link is a directory entry that references a file. UNIX allows multiple such links to exist simultaneously, meaning that a given file can be referenced by multiple names. ...",t:"FILE_LINK "},"417":{i:0.000173128571191676,u:"../Content/Reference Material/F/FILE_MKDIR.htm",a:"The FILE_MKDIR procedure creates a new directory, or directories, with the default access permissions for the current process. Use the FILE_CHMOD procedure to alter access permissions. If a specified directory has non-existent parent directories, FILE_MKDIR automatically creates all the intermediate ...",t:"FILE_MKDIR "},"418":{i:0.000140167177507958,u:"../Content/Reference Material/F/FILE_MOVE.htm",a:"The FILE_MOVE procedure renames files and directories, effectively moving them to a new location. The moved files retain their permission and ownership attributes. Within a given filesystem or volume, FILE_MOVE does not copy file data. Rather, it simply changes the file names by updating the ...",t:"FILE_MOVE "},"419":{i:0.000416486408432759,u:"../Content/Reference Material/F/FILE_POLL_INPUT.htm",a:"Given a list of file logical units (LUNs), the FILE_POLL_INPUT function will block (not return) until it detects that a read operation for a byte of data from at least one of the specified files will succeed. On return, FILE_POLL_INPUT reports True (1) for each file for which a read operation will ...",t:"FILE_POLL_INPUT"},"420":{i:0.000102867364237297,u:"../Content/Reference Material/F/FILE_READLINK.htm",a:"The FILE_READLINK function returns the path pointed to by UNIX symbolic links. Examples Under Mac OS X, the /etc directory is actually a symbolic link. The following statement reads it and returns the location to which the link points: path = FILE_READLINK(\u0027/etc\u0027) It is possible to have chains of ...",t:"FILE_READLINK "},"421":{i:7.38069902898774E-05,u:"../Content/Reference Material/F/FILE_SAME.htm",a:"The FILE_SAME function is used to determine if two different file names refer to the same underlying file. The mechanism used to determine whether two names refer to the same file depends on the operating system in use: UNIX : Under UNIX, all files are uniquely identified by two integer values: the ...",t:"FILE_SAME"},"422":{i:0.000578469324823944,u:"../Content/Reference Material/F/FILE_SEARCH.htm",a:"The FILE_SEARCH function returns a string array containing the names of all files matching the input path specification. Input path specifications may contain wildcard characters, enabling them to match multiple files. If you want to test for existence of a file, use FILE_TEST . A relative path is a ...",t:"FILE_SEARCH "},"423":{i:0.000518898656073846,u:"../Content/Reference Material/F/FILE_TAR.htm",a:"The FILE_TAR procedure archives a given set of input files and directories into a TAR file or an output buffer. This routine is written in the IDL language. Its source code can be found in the file file_tar.pro in the lib subdirectory of the IDL distribution. Examples This example archives the ...",t:"FILE_TAR"},"424":{i:0.000375641900765071,u:"../Content/Reference Material/F/FILE_TEST.htm",a:"The FILE_TEST function checks files for existence and other attributes without having to first open the file. Examples To determine whether your IDL distribution supports the Intel-based Macintosh operating system: result = FILE_TEST(!DIR + \u0027/bin/bin.darwin.i386\u0027, /DIRECTORY) PRINT, \u0027Intel-Mac ...",t:"FILE_TEST "},"425":{i:0.000518898656073846,u:"../Content/Reference Material/F/FILE_UNTAR.htm",a:"The FILE_UNTAR procedure uncompresses a TAR file or TAR data stream. FILE_UNTAR also automatically performs GZIP uncompression if necessary. This routine is written in the IDL language. Its source code can be found in the file file_untar.pro in the lib subdirectory of the IDL distribution. Because ...",t:"FILE_UNTAR"},"426":{i:0.000455890346780903,u:"../Content/Reference Material/F/FILE_UNZIP.htm",a:"The FILE_UNZIP procedure uncompresses ZIP files. The uncompression of individual files within the ZIP file is done using the ZLIB_UNCOMPRESS routine. This routine is written in the IDL language. Its source code can be found in the file file_unzip.pro in the lib subdirectory of the IDL distribution. ...",t:"FILE_UNZIP"},"427":{i:0.000155919881839314,u:"../Content/Reference Material/F/FILE_WHICH.htm",a:"The FILE_WHICH function separates a specified file path into its component directories, and searches each directory in turn for a specific file. This command is modeled after the UNIX which(1) command, but is written in the IDL language and is available on all platforms. Its source code can be found ...",t:"FILE_WHICH "},"428":{i:0.000518898656073846,u:"../Content/Reference Material/F/FILE_ZIP.htm",a:"The FILE_ZIP procedure compresses a given set of input files and directories into the PKWARE ZIP file format, using the DEFLATE compression algorithm for all files within the ZIP. The routine uses the ZLIB_COMPRESS function to compress the data within each file. This routine is written in the IDL ...",t:"FILE_ZIP"},"429":{i:0.000516054645266143,u:"../Content/Reference Material/F/FILEPATH.htm",a:"The FILEPATH function returns the fully-qualified path to a file contained in the IDL distribution. Operating system dependencies are taken into consideration. This routine is used to make the library routines portable. Examples Open the IDL distribution file people.dat : OPENR, 1, ...",t:"FILEPATH "},"430":{i:0.000340118341540861,u:"../Content/Reference Material/F/FINDGEN.htm",a:"The FINDGEN function creates a floating-point array of the specified dimensions. Each element of the array is set to the value of its one-dimensional subscript. For example, F=FINDGEN(100) will create a 100-element, single-precision, floating-point array with the values 0.0, 1.0, ..., 99.0. Values ...",t:"FINDGEN"},"431":{i:0.000297823118180744,u:"../Content/Reference Material/F/FINITE.htm",a:"The FINITE function identifies whether or not a given argument is finite. Examples Example 1 To find out if the logarithm of 5.0 is finite, enter: PRINT, FINITE(ALOG(5.0)) IDL prints “1” because the argument is finite. See Additional Examples for more examples of using FINITE. Syntax Result = ...",t:"FINITE "},"432":{i:0.000668499995832464,u:"../Content/Reference Material/F/FIX.htm",a:"The FIX function converts a given expression to an integer type. Optionally, the conversion type can be specified at runtime, allowing flexible runtime type-conversion to arbitrary types. The default behavior is to truncate to an integer type. Examples Convert the floating-point array [2.2, 3.0, ...",t:"FIX "},"433":{i:6.18572524570509E-05,u:"../Content/Reference Material/F/FLICK_Procedure.htm",a:"The FLICK procedure causes the display to flicker between two output images at a given rate. This routine is written in the IDL language. Its source code can be found in the file flick.pro in the lib subdirectory of the IDL distribution. Syntax FLICK, A , B [, Rate ] Arguments A Byte image number 1, ...",t:"FLICK Procedure"},"434":{i:0.000496466210069274,u:"../Content/Reference Material/F/FLOAT.htm",a:"The FLOAT function converts a given Expression into a single-precision floating-point value. Examples If A contains the integer value 6, it can be converted to floating-point and stored in the variable B by entering: B = FLOAT(A) Syntax Result = FLOAT( Expression [ , Offset [ , D 1 [ , ... , D 8 ]]] ...",t:"FLOAT"},"435":{i:0.000209794368470491,u:"../Content/Reference Material/F/FLOOR.htm",a:"The FLOOR function returns the closest integer less than or equal to its argument. Examples To print the floor function of 5.9, enter: PRINT, FLOOR(5.9) IDL prints: 5 To print the floor function of 3000000000.1, the result of which is too large to represent in a 32-bit integer: PRINT, ...",t:"FLOOR "},"436":{i:0.000277908057219887,u:"../Content/Reference Material/F/FLOW3.htm",a:"The FLOW3 procedure draws lines representing a 3D flow/velocity field. Note that the 3D scaling system must be in place before calling FLOW3. This procedure works best with Z buffer output device. This routine is written in the IDL language. Its source code can be found in the file flow3.pro in the ...",t:"FLOW3 "},});