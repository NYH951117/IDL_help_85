define({"2584":{i:0.000127737570381391,u:"../Content/Creating IDL Programs/Components of the IDL Language/Structure_References.htm",a:"The basic syntax of a reference to a field within a structure is as follows: Variable_Name.Tag_Name Variable_Name must be a variable that contains a structure. Tag_Name is the name of the field and must exist in the structure. If the field referred to by the tag name is itself a structure, the ...",t:"Structure References"},"2585":{i:6.7682962248732E-05,u:"../Content/Creating IDL Programs/Components of the IDL Language/Defining_and_Using_Const.htm",a:"The syntax of a constant determines its type. Efficiency is adversely affected when the type of a constant must be converted during expression evaluation. Consider the following expression: A + 5 If the variable A is of floating-point type, the constant 5 must be converted from short integer type to ...",t:"Defining and Using Constants"},"2586":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Components of the IDL Language/IDL_Pointers.htm",a:"As illustrated above, you must use a special IDL routine to create a pointer to a heap variable. Two routines are available: PTR_NEW and PTRARR. Before discussing these functions, however, it is useful to examine the concept of a null pointer. Null Pointers The Null Pointer is a special pointer ...",t:"IDL Pointers"},"2587":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Components of the IDL Language/Freeing_Pointers.htm",a:"The PTR_FREE procedure destroys the heap variables pointed at by pointers supplied as its arguments. Any memory used by the heap variable is released, and the heap variable ceases to exist. PTR_FREE is the only way to destroy a pointer heap variable; if PTR_FREE is not called on a heap variable, it ...",t:"Freeing Pointers"},"2588":{i:0.000108071169746975,u:"../Content/Creating IDL Programs/Components of the IDL Language/Operations_on_Pointers.htm",a:"Pointer variables are not directly usable by many of the operators, functions, or procedures provided by IDL. You cannot, for example, do arithmetic on them or plot them. You can, of course, do these things with the heap variables referenced by such pointers, assuming that they contain appropriate ...",t:"Operations on Pointers"},"2589":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Components of the IDL Language/Pointer_Examples.htm",a:"Pointers are useful in building dynamic memory structures, such as linked lists and trees. The following examples demonstrate how pointers are used to build several types of dynamic structures. Note that the purpose of these examples is to illustrate simply and clearly how pointers are used. As ...",t:"Pointer Examples"},"2590":{i:0.000636737555816869,u:"../Content/Creating IDL Programs/Components of the IDL Language/String_Operations.htm",a:"IDL supports several basic string operations, as described below: Operation Description Concatenation The Addition operator, “+”, can be used to concatenate strings together. Formatting Data The STRING function is used to format data into a string. The READS procedure can be used to read values from ...",t:"String Operations"},"2591":{i:0.000112179688356021,u:"../Content/Creating IDL Programs/Components of the IDL Language/Comparing_Strings.htm",a:"IDL provides several different mechanisms for performing string comparisons. In addition to the EQ operator, the STRCMP, STRMATCH, and STREGEX functions can all be used for string comparisons. Case-Insensitive Comparisons of the First N Characters The STRCMP function simplifies case-insensitive ...",t:"Comparing Strings"},"2592":{i:8.20942001476275E-05,u:"../Content/Creating IDL Programs/Components of the IDL Language/Finding_the_Length_of_a.htm",a:"The STRLEN function is used to obtain the length of a string. It has the form: L = STRLEN( String ) where String is the string for which the length is required. For example, the following statement PRINT, STRLEN(\u0027This sentence has 31 characters\u0027) results in the output 31 while the following IDL ...",t:"Finding the Length of a String"},"2593":{i:8.20942001476275E-05,u:"../Content/Creating IDL Programs/Components of the IDL Language/Case_Folding.htm",a:"The STRLOWCASE and STRUPCASE functions are used to convert arguments to lowercase or uppercase. Where String is the string to be converted, they have the form: S = STRLOWCASE( String ) S = STRUPCASE( String ) The following IDL statements generate a table of the contents of TREES showing each name in ...",t:"Case Folding"},"2594":{i:0.000112179688356021,u:"../Content/Creating IDL Programs/Components of the IDL Language/Substrings.htm",a:"IDL provides the STRPOS , STRPUT , and STRMID routines to locate, insert, and extract substrings from their string arguments. Searching for a Substring The STRPOS function is used to search for the first occurrence of a substring. It has the form S = STRPOS( Object , Search_string [, Position ]) ...",t:"Substrings"},"2595":{i:0.000220929022586415,u:"../Content/Creating IDL Programs/Components of the IDL Language/Learning_About_Regular_E.htm",a:"Regular expressions are a very powerful way to match arbitrary text. Stemming from neurophysiological research conducted in the early 1940’s, their mathematical foundation was established during the 1950’s and 1960’s. Their use has a long history in computer science, and they are an integral part of ...",t:"Learning About Regular Expressions"},"2596":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/ErrorHandling.htm",a:"Error Handling ",t:"Error Handling"},"2597":{i:0.000248230695009455,u:"../Content/Creating IDL Programs/Application Programming/Controlling_and_Recoveri.htm",a:"IDL divides possible execution errors into three categories: input/output, math, and all others. There are three main error-handling routines: CATCH , ON_ERROR , and ON_IOERROR . CATCH is a generalized mechanism for handling exceptions and errors. The ON_ERROR routine handles regular errors when an ...",t:"Controlling and Recovering from Errors"},"2598":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Application Programming/Creating_Custom_Error_Me.htm",a:"To generate an exception and cause control to return to the\nerror handler, use the MESSAGE procedure. Calling MESSAGE generates an\nexception that sets the !ERROR_STATE system variable. !ERROR_STATE.MSG\nis set to the string used as an argument to MESSAGE. The MESSAGE procedure is used by user ...",t:"Creating Custom\nError Messages"},"2599":{i:0.0028356643002714,u:"../Content/Creating IDL Programs/Appendices/Error_Handling_System_Va.htm",a:"The following system variables are either set by IDL when an error condition occurs or used by IDL when displaying information about errors. !ERR This system variable is now obsolete and has been replaced by the !ERROR_STATE system variable. Code that uses the !ERR system variable will continue to ...",t:"Error Handling System Variables"},"2600":{i:0.000113789688384616,u:"../Content/Creating IDL Programs/Application Programming/Math_Errors.htm",a:"The detection of math errors, such as division by zero, overflow, and attempting to take the logarithm of a negative number, is hardware and operating system dependent. Some systems trap more errors than other systems. On systems that implement the IEEE floating-point standard, IDL substitutes the ...",t:"Math Errors"},"2601":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Operators.htm",a:"Operators ",t:"Operators"},"2602":{i:0.000170234785243985,u:"../Content/Creating IDL Programs/Components of the IDL Language/Logical_Operators.htm",a:"IDL supports three logical operators: && , || , and ~ . When dealing with logical operators, non-zero numerical values, non-empty strings, and non-empty heap variables (pointers and object references) are considered true, everything else is false. Programmers familiar with the C programming ...",t:"Logical Operators"},"2603":{i:0.000314648187043807,u:"../Content/Creating IDL Programs/Components of the IDL Language/Mathematical_Operators.htm",a:"Mathematical Opera tors IDL mathematical operators are described in the following table. Also see Assignment and Compound Assignment for information on = and op= and Other Operators for information on the [ ] , ( ) , and ?: operators. If one or both of the operands are objects, the operator may be ...",t:"Mathematical Operators"},"2604":{i:0.000116643900625765,u:"../Content/Creating IDL Programs/Components of the IDL Language/Bitwise_Operators.htm",a:"There are four bitwise operators in IDL: AND , NOT , OR , and XOR . For integer operands (byte, signed- and unsigned-integer, longword, and 64-bit longword data types), bitwise operators operate on each bit of the operand or operands independently. If one or both of the operands are objects, the ...",t:"Bitwise Operators"},"2605":{i:0.000189241251367794,u:"../Content/Creating IDL Programs/Components of the IDL Language/Relational_Operators.htm",a:"The IDL relational operators apply a relation to two operands and return a  value of true (1) or false (0). The resulting value can be used as the predicate in IF, WHILE or REPEAT statements. You can also combine operators with other logical values to make more complex expressions. It is important ...",t:"Relational Operators"},"2606":{i:0.000150183426909717,u:"../Content/Creating IDL Programs/Components of the IDL Language/Operator_Precedence.htm",a:"The following table lists IDL’s operator precedence. Operators with the highest precedence are evaluated first. Operators with equal precedence are evaluated from left to right. See Efficiency and Expression Evaluation Order for information on creating efficient statements. Priority Operator First ...",t:"Operator Precedence"},"2607":{i:0.000230460001728845,u:"../Content/Creating IDL Programs/Components of the IDL Language/Matrix_Operators.htm",a:"IDL has two operators used to multiply arrays and matrices. For an example illustrating the difference between the two, see Multiplying Arrays . If one or both of the operands are objects, the operator may be overloaded. Operator Description Example # Computes array elements by multiplying the ...",t:"Matrix Operators"},"2608":{i:6.70700835204611E-05,u:"../Content/Creating IDL Programs/Components of the IDL Language/Minimum_and_Maximum_Oper.htm",a:"The IDL minimum and maximum operators return the smaller or larger of their operands, as described below. Negated values must be enclosed in parentheses in order for IDL to interpret them correctly. If one or both of the operands are objects, the operator may be overloaded. Operator Description ...",t:"Minimum and Maximum Operators"},"2609":{i:0.000158817267139958,u:"../Content/Creating IDL Programs/Components of the IDL Language/Other_Operators.htm",a:"The following operators are used when working with arrays,  expressions, or methods. Operator Description Examples [ ] Array concatenation The expression [A,B] is an array formed by concatenating A and B, which can be scalars or arrays, along the first dimension. To concatenate second and third ...",t:"Other Operators"},"2610":{i:0.000211994726416806,u:"../Content/Creating IDL Programs/Components of the IDL Language/Assignment_and_Compound.htm",a:"The assignment statement stores a value in a variable. Compound assignment combines assignment with another operator. Operator Description Examples = Assignment The value of the expression on the right hand side of the equal sign is stored in the variable, subscript element, or range on the left ...",t:"Assignment and Compound Assignment"},"2611":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Parameters.htm",a:"Parameters ",t:"Parameters"},"2612":{i:9.40695669088197E-05,u:"../Content/Creating IDL Programs/Application Programming/Parameters.htm",a:"The variables and expressions passed to the function or procedure from its caller are parameters . Actual parameters are those appearing in the procedure call statement or the function reference. In the following, ; Call procedure with two parameters. myproABC, A, 12  ; Call function with one ...",t:"Parameters: Arguments and Keywords"},"2613":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Application Programming/Parameter_Passing_Mechan.htm",a:"Parameters are passed to IDL system and user-written procedures and functions by value or by reference . It is important to recognize the distinction between these two methods. Expressions, constants, system variables, and subscripted variable references are passed by value. Variables are passed by ...",t:"Parameter Passing"},"2614":{i:0.00250561306654875,u:"../Content/Creating IDL Programs/Application Programming/Keyword_Inheritance.htm",a:"Keyword inheritance allows IDL routines to accept keyword parameters not defined in their function or procedure declaration and pass them on to the routines that they call. Routines are able to accept keywords on behalf of the routines they call without explicitly processing each individual keyword. ...",t:"Keyword Inheritance"},"2615":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Variables.htm",a:"Variables ",t:"Variables"},"2616":{i:9.96534005716172E-05,u:"../Content/Creating IDL Programs/Application Programming/Monitoring_Variable_Valu.htm",a:"When execution halts, there are several ways to see the values of program variables. These include: Check variable values from the command line — see Showing Variable Values During Execution . Use the Variable Watch window — see The Variables View Recover \"missing\" variables — see Disappearing ...",t:"Monitoring Variable Values"},"2617":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Components of the IDL Language/Assignment_Operations_an.htm",a:"The following table shows the variations possible in expressions containing array and scalar subscripts. The result of the assignment operation depends upon the dimensionality of the subscript. A subscript structure can also be composed of a range of elements. If expression is scalar, it is inserted ...",t:"Assignment Operations and Arrays\n        "},"2618":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Application Programming/Saving_Variables_from_an.htm",a:"Saving V ariables from an IDL Session In addition to distributing IDL code in binary format, you can also create SAVE files that contain variable data. The state of variables in an IDL session can be saved quickly and easily, and can be restored to the same point. This feature allows you to stop ...",t:"Saving Variables from an IDL Session"},"2619":{i:7.84216139489386E-05,u:"../Content/Creating IDL Programs/Environment Variables.htm",a:"When IDL starts, it checks for the presence of a number of environment variables. If one of these environment variables exists, its value is used in one of two ways: As the value for a preference To configure IDL’s environment in such a way that it can load and run Preferences Preferences are ...",t:"Environment Variables"},"2620":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/System Variables.htm",a:"General System Variables !CPU - Controls the state of the IDL thread pool. !DEBUG_PROCESS_EVENTS - Allow processing of widget events while stopped. !DIR - Path to the main IDL directory. !DLM_PATH - List of search paths for DLM files. !EDIT_INPUT - Controls command-line editing. !HELP_PATH - List of ...",t:"System Variables"},"2621":{i:0.00656489112050394,u:"../Content/Creating IDL Programs/Appendices/IDL_Environment_System_V.htm",a:"The following system variables contain information about IDL’s configuration. !CPU IDL can use multiple system processors to perform some computations in parallel. The !CPU system variable supplies information about the state of the system processor, and of IDL\u0027s use of it. !CPU is read only, and ...",t:"General System Variables"},"2622":{i:0.00192406915802544,u:"../Content/Creating IDL Programs/Appendices/Constant_System_Variable.htm",a:"The following system variables contain predefined constants or values for use by IDL routines. System variables can be used just like other variables. For example, the command: PRINT, ACOS(A) * !RADEG converts a result expressed in radians to one expressed in degrees. !COLOR A read-only structure ...",t:"Constant System Variables"},"2623":{i:0.00016998572127564,u:"../Content/Direct Graphics/Graphics_System_Variable.htm",a:"The following system variables control various IDL Direct Graphics functions. These system variables are structures that contain many tags. For example, the command !P.TITLE = \u0027Cross Section\u0027 sets the default plot title. Many of the functions of the graphics keywords described in Direct Graphics ...",t:"Direct Graphics System Variables"},"2624":{i:5.50327019655568E-05,u:"../Content/MiscellaneousLanguageTopics.htm",a:"Miscellaneous Topics ",t:"Miscellaneous Topics"},"2625":{i:5.73587357991539E-05,u:"../Content/Creating IDL Programs/Overview of IDL Syntax/TipsAndTricks.htm",a:"This is an ever-expanding list of IDL Tips and Tricks to make your coding easier and quicker. Finding Files Using Open Resource If you know at least part of the name of the file you\u0027re looking for, Open Resource can be an extremely fast way to find and open it. In IDL Workbench\u0027s IDL Console tab, ...",t:"IDL Tips and Tricks"},"2626":{i:0.000848663576542632,u:"../Content/Creating IDL Programs/Components of the IDL Language/Automatic_Garbage_Collec.htm",a:"The term garbage collection refers to the process of finding heap variables that have become inaccessible, and de-allocating the memory storing the data. IDL performs automatic garbage collection on all data types so that when a variable is destroyed or goes out of scope, the variable’s memory is ...",t:"Automatic Garbage Collection"},"2627":{i:0.00685006643752913,u:"../Content/Creating IDL Programs/Components of the IDL Language/Format_Codes.htm",a:"Format codes specify either how data should be transferred or how input/output is handled. Syntax of Format Codes The syntax of an IDL format code is: [n] FC [+][-][ width ] Where: n is an optional repeat count (1 ≤ n ) specifying the number of times the format code should be processed. If n is not ...",t:"Format Codes"},"2628":{i:0.000372047005071908,u:"../Content/Creating IDL Programs/Components of the IDL Language/Using_Explicitly_Formatt.htm",a:"The FORMAT keyword can be used with the formatted input/output routines to explicitly specify the appearance of the data. The standard syntax of IDL format strings is similar to that used in FORTRAN; a C printf()-style syntax is also supported, as described in C printf-Style Quoted String Format ...",t:"Using Formatted Input and Output"},"2629":{i:0.000516128341281949,u:"../Content/Creating IDL Programs/Components of the IDL Language/ImpliedPrint.htm",a:"If you enter an expression or a variable name at the IDL command prompt, IDL will automatically evaluate the expression and print out the result. This feature works when entering commands in both the IDL command line and in the IDL Workbench. It also works with the EXECUTE function when you set the ...",t:"Implied Print"},"2630":{i:0.000153098670935865,u:"../Content/Creating IDL Programs/Appendices/reswords.htm",a:"Variables, user-written procedures, and user-written functions should not have the same names as IDL functions or procedures. Re-using names of IDL routines can lead to syntax errors or to “hiding” variables. In addition, certain words representing IDL language constructs are strictly ...",t:"Reserved Words"},"2631":{i:0.000187193966445714,u:"../Content/Creating IDL Programs/Appendices/specchars.htm",a:"Within the IDL environment, a number of characters have special meanings. The following table lists characters with special interpretations and states their functions in IDL. These characters are discussed further in the descriptions following the table. Character Function ! First character of ...",t:"Special Characters"},"2632":{i:5.50327019655568E-05,u:"../Content/Creating IDL Programs/Components of the IDL Language/Using_HELP_with_Structur.htm",a:"Use the HELP,/STRUCTURE command to determine the type, structure, and tag name of each field in a structure. In the example above, a structure was stored into variable A. The statement, HELP, /STRUCTURE, A prints the following information: ** Structure STAR, 4 tags, length=40: NAME            STRING ...",t:"Using HELP with Structures"},"2633":{i:0.000276404821031875,u:"../Content/Object Classes/ref_part2.htm",a:"Object Class and Method Reference  ",t:"Object Class and Method Reference "},"2634":{i:5.50327019655568E-05,u:"../Content/Objects/Object_Oriented_Programm.htm",a:"Traditional programming techniques make a strong distinction between routines written in the programming language (procedures and functions in the case of IDL) and data to be acted upon by the routines. Object-oriented programming begins to remove this distinction by melding the two into objects ...",t:"Object-Oriented Programming Concepts"},"2635":{i:5.50327019655568E-05,u:"../Content/Object Classes/IDL Object Class Overview/Using_the_Class_Referenc.htm",a:"IDL’s object class library is documented in this section. The page or pages describing each class include references to any superclasses of the class, to the properties of the class, and to the methods associated with the class. Class methods are documented alphabetically following the description ...",t:"Using the Class Reference"},"2636":{i:5.50327019655568E-05,u:"../Content/Objects/Creating_Objects.htm",a:"To create an object from the IDL object class library, you can use the class name as a function or use the OBJ_NEW function. The Init method for each class describes the arguments and keywords available when you are creating a new object. For example, to create a new object from the IDLgrAxis class, ...",t:"Creating Objects"},"2637":{i:0.00356656553110731,u:"../Content/Object Classes/IDL Object Class Overview/Object_Properties.htm",a:"Some IDL objects have properties associated with them — things like color, line style, size, and so on. You can set properties at object initialization by providing property-value pairs in a call to the object\u0027s Init method: Obj = OBJ_NEW(\u0027ObjectClass\u0027, PROPERTY = value , ... ) If your object ...",t:"Modifying Object Properties"},"2638":{i:0.00010747302287537,u:"../Content/Objects/Acting_on_Objects_Using.htm",a:"In order to perform an action on an object’s instance data, you must call one of the object’s methods . In addition to their own specific methods, all object classes shipped with IDL except for the IDL_Container class have four methods in common: Cleanup, In it, Get Property, and Set Property. The ...",t:"Acting on Objects Using Methods "},"2639":{i:0.00103803734750921,u:"../Content/Objects/Static_Methods.htm",a:"Static Methods In  addition to calling methods on an object instance, you can also call static (or class) methods on a class. In order to call a method as \"static,\" you will need to mark the method with a special \"compile_opt static\" flag. Usually, the documentation for the class will indicate which ...",t:"Static Methods and Properties"},"2640":{i:7.80121330092946E-05,u:"../Content/Objects/Using_IDL_Operators_with.htm",a:"The following standard IDL operators work directly on object reference variables: Assignment Method invocation (described in Acting on Objects Using Methods ) Property referencing EQ NE Attempting to use other standard operators on object references results in an error. Beginning with IDL 8.0, it is ...",t:"Using IDL Operators with Objects"},"2641":{i:0.00202333686560111,u:"../Content/Object Classes/IDL Object Class Overview/Registered_Properties.htm",a:"In order for an object property to be displayed in the WIDGET_PROPERTYSHEET interface, which makes it possible for a user to interactively change the value of the property using the mouse and keyboard, the following two conditions must be met: The property must belong to an object that subclasses ...",t:"Registered Properties"},"2642":{i:7.0625309954478E-05,u:"../Content/Objects/Destroying_Objects.htm",a:"You can destroy an object explicitly, or you can let the IDL garbage collection system automatically destroy it. The IDL garbage collection system will destroy an object when the object\u0027s last reference is destroyed. Specifically, IDL garbage collection calls the object’s Cleanup method. See ...",t:"Destroying Objects"},"2643":{i:5.50327019655568E-05,u:"../Content/Objects/Creating Custom Objects.htm",a:"Creating Object Classes ",t:"Creating Object Classes"},"2644":{i:0.000154842272470748,u:"../Content/Objects/Creating_an_Object_Class_1.htm",a:"Object instance data is contained in named IDL structures. We will use the term class structure to refer to IDL structures containing object instance data. Beyond the restriction that class structures must be named structures, there are no limits on what a class structure contains. Class structures ...",t:"Creating an Object Class Structure "},"2645":{i:5.50327019655568E-05,u:"../Content/Objects/The_Object_Lifecycle_1.htm",a:"Objects are persistent , meaning they exist in memory until you destroy them. We can break the life of an object into three phases: creation and initialization, use, and destruction. Object lifecycle routines allow the creation and destruction of object references; lifecycle methods associated with ...",t:"The Object Lifecycle"},"2646":{i:0.000352267116586192,u:"../Content/Objects/Creating_Custom_Object_M_1.htm",a:"IDL objects can have associated procedures and functions called methods . Methods are called on objects via their object references using the method invocation operator. While object methods are constructed in the same way as any other IDL procedure or function, they are different from other ...",t:"Creating Custom Object Method Routines"},"2647":{i:0.000154842272470748,u:"../Content/Objects/Method_Overriding_1.htm",a:"Unlike data fields, method names can be duplicated. This is an important feature that allows method overriding, which in turn facilitates polymorphism in the design of object-oriented programs. Method overriding allows a subclass to provide its own implementation of a method already provided by one ...",t:"Method Overriding"},"2648":{i:0.000380541830231386,u:"../Content/Objects/Creating_Static_Methods.htm",a:"IDL object classes can have both instance methods and static methods. When you create a method on a class, by default the method is an \"instance\" method. Instance methods can only be called on an actual \"instance\" of that class. Within an instance method, you have access to the self variable and the ...",t:"Creating Static Methods"},"2649":{i:5.50327019655568E-05,u:"../Content/Objects/Object_Examples.htm",a:"The following example creates an IDL object class with both instance and static methods. The ObjCircle class inherits from the IDL_Object superclass. To run the example, save the following code into a file called \" objcircle__define.pro \" somewhere on IDL\u0027s path. FUNCTION ObjCircle::Init, _EXTRA=ex ...",t:"Object Example"},"2650":{i:5.50327019655568E-05,u:"../Content/Objects/Overview_of_Object_Graph.htm",a:"The following sections provide an overview of the different types of objects included in the  class library. In order to describe the attributes of the  classes, we have grouped the objects into functional categories: Display Objects , Visualization Objects , and Destination Objects . These category ...",t:"Overview of Object Graphics Classes"},"2651":{i:6.51173110557678E-05,u:"../Content/Objects/Creating_an_Object_Graph.htm",a:"All Object Graphics applications require at least two basic building blocks. These include: A destination object - the device (such as a window, memory buffer, file, clipboard, or printer) to which the visualization is to be rendered. A view object - the viewport rectangle (within the destination) ...",t:"Creating an Object Graphics Display "},"2652":{i:7.68117670474587E-05,u:"../Content/Objects/Object_Graphics_Display.htm",a:"An Object Graphics display can be thought of as a group of graphics objects organized into a hierarchy or tree. For example, a graphics object tree with four graphics atoms (visualization objects) might be contained in three separate model objects, which are in turn contained in two distinct view ...",t:"Object Graphics Display Hierarchy"},"2653":{i:8.30496687502036E-05,u:"../Content/Objects/Destination_Objects.htm",a:"Destination objects are objects on which object trees can be rendered (displayed on a screen or printed on a printer). Destination Description Buffer Objects of the IDLgrBuffer class represent an off-screen, in-memory data area that may serve as a graphics source or destination. Clipboard Objects of ...",t:"Destination Objects"},"2654":{i:8.30496687502036E-05,u:"../Content/Objects/Display_Objects.htm",a:"Minimally, you must have a view object in an Object Graphics display. However, it is likely that you will use a combination of the following display objects in any display. The Object Graphics Display Hierarchy shows the relationship between these objects as a tree structure. The advantage of ...",t:"Display Objects"},"2655":{i:0.000138399417185071,u:"../Content/Objects/Visualization_Objects.htm",a:"Visualization objects contain data that is designed to produce a visualization. These graphic objects are the basic drawable elements of the IDL Object Graphics system, and are containers for other objects. Visualization objects are added to a model object, which controls the spatial positioning of ...",t:"Visualization Objects"},});