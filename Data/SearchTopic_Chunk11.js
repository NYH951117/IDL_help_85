define({"793":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF5 Routines/H5T_GET_SIGN.htm",a:"The H5T_GET_SIGN function returns the sign type for an integer datatype. Syntax Result = H5T_GET_SIGN( Datatype_id ) Return Value Returns the sign type. Possible values are: -1 — Error 0 — Unsigned integer type 1 — Two\u0027s complement signed integer type Arguments Datatype_id An integer representing ...",t:"H5T_GET_SIGN "},"794":{i:0.000359081206137267,u:"../Content/Reference Material/H/HDF5 Routines/H5T_GET_SIZE.htm",a:"The H5T_GET_SIZE function returns the size of a datatype in bytes. Syntax Result = H5T_GET_SIZE( Datatype_id ) Return Value Represents the size (in bytes) of the first element found within the datatype. When H5T_GET_SIZE is given a datatype containing a string, it will return the number of ...",t:"H5T_GET_SIZE "},"795":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF5 Routines/H5T_GET_STRPAD.htm",a:"The H5T_GET_STRPAD function returns the padding method for a string datatype. Syntax Result = H5T_GET_STRPAD( Datatype_id ) Return Value Returns a string containing the padding method. Possible values are: ‘NULLTERM’ — Null terminate (like C) ‘NULLPAD’ — Pad with zeroes ‘SPACEPAD’ — Pad with spaces ...",t:"H5T_GET_STRPAD "},"796":{i:0.000336404928125915,u:"../Content/Reference Material/H/HDF5 Routines/H5T_GET_SUPER.htm",a:"The H5T_GET_SUPER function returns the base datatype from which a datatype is derived. Syntax Result = H5T_GET_SUPER( Datatype_id ) Return Value Returns the base datatype’s identifier number. This identifier can be released with the H5T_CLOSE . Arguments Datatype_id An integer representing the ...",t:"H5T_GET_SUPER "},"797":{i:0.000102115537567721,u:"../Content/Reference Material/H/HDF5 Routines/H5T_GET_TAG.htm",a:"The H5T_GET_TAG function retrieves a tag string from an opaque data type. Syntax Result = H5T_GET_TAG( Datatype_id ) Return Value Returns a string containing the tag associated with the specified opaque datatype, or an empty string if no tag exists. Arguments Datatype_id A long integer containing ...",t:"H5T_GET_TAG"},"798":{i:0.000562535220267709,u:"../Content/Reference Material/H/HDF5 Routines/H5T_IDL_CREATE.htm",a:"The H5T_IDL_CREATE function creates a datatype object based on the IDL type of the supplied data. Example See the example under H5F_CREATE . Syntax Result = H5T_IDL_CREATE( Data [, MEMBER_NAMES = vector ] [, / OPAQUE ]) Return Value Returns a long integer containing the identifier of the new ...",t:"H5T_IDL_CREATE"},"799":{i:0.000476294463182133,u:"../Content/Reference Material/H/HDF5 Routines/H5T_IDLTYPE.htm",a:"The H5T_IDLTYPE function returns the IDL type code corresponding to a datatype. This function is not part of the standard HDF5 interface, but is provided as a programming convenience. Syntax Result = H5T_IDLTYPE( Datatype_id [, ARRAY_DIMENSIONS = variable ][, STRUCTURE = variable ] ) Return Value ...",t:"H5T_IDLTYPE "},"800":{i:5.50327019655568E-05,u:"../Content/Reference Material/H/HDF5 Routines/H5T_INSERT.htm",a:"The H5T_INSERT procedure adds a new member to the end of a compound datatype. Syntax H5T_INSERT, Datatype_id , Name , Field_id Arguments Datatype_id An integer giving the identifier of the compound datatype to modify. Name Name of the field to insert. Field_id An integer giving the identifier of the ...",t:"H5T_INSERT"},"801":{i:0.0002574569484502,u:"../Content/Reference Material/H/HDF5 Routines/H5T_MEMTYPE.htm",a:"The H5T_MEMTYPE function returns the native memory datatype corresponding to a file datatype. This function is not part of the standard HDF5 interface, but is provided as a programming convenience. Syntax Result = H5T_MEMTYPE( Datatype_id ) Return Value The Result gives the datatype identifier. If ...",t:"H5T_MEMTYPE "},"802":{i:0.00324645955150345,u:"../Content/Reference Material/H/HDF5 Routines/H5T_OPEN.htm",a:"The H5T_OPEN function opens a named datatype. Syntax Result = H5T_OPEN( Loc_id , Name ) Return Value Returns the datatype’s identifier number. This identifier can be released with the H5T_CLOSE . Arguments Loc_id An integer representing the identifier of the file or group containing the datatype. ...",t:"H5T_OPEN "},"803":{i:0.000303617734498541,u:"../Content/Reference Material/H/HDF5 Routines/H5T_REFERENCE_CREATE.htm",a:"The H5T_REFERENCE_CREATE function creates a reference datatype object. Example See the example under H5F_CREATE . Syntax Result = H5T_REFERENCE_CREATE([/ REGION ]) Return Value The Result is either an integer (if an object reference is created) or a structure (if a dataspace region reference is ...",t:"H5T_REFERENCE_CREATE"},"804":{i:0.000102115537567721,u:"../Content/Reference Material/H/HDF5 Routines/H5T_SET_TAG.htm",a:"The H5T_SET_TAG procedure sets a tag string on an opaque data type. Syntax H5T_SET_TAG, Datatype_id , Tag Arguments Datatype_id A long integer containing the identifier of the opaque datatype. Tag A string containing the new tag for the opaque datatype. Tag strings can contain a maximum of 255 ...",t:"H5T_SET_TAG"},"805":{i:0.000135499541163126,u:"../Content/Reference Material/H/HDF5 Routines/H5T_STR_TO_VLEN.htm",a:"The H5T_STR_TO_VLEN function converts an IDL string array to an IDL_H5_VLEN array of strings. This routine is written in the IDL language. Its source code can be found in the file h5t_str_to_vlen.pro in the lib subdirectory of the IDL distribution. Syntax Result = H5T_STR_TO_VLEN( Array [, / NO_COPY ...",t:"H5T_STR_TO_VLEN"},"806":{i:0.000135499541163126,u:"../Content/Reference Material/H/HDF5 Routines/H5T_VLEN_CREATE.htm",a:"The H5T_VLEN_CREATE function creates a variable length array datatype object. Syntax Result = H5T_VLEN_CREATE( Datatype_id ) Return Value Returns a long integer containing the identifier of the new variable length array datatype. Datatype identifiers created by this function should be released with ...",t:"H5T_VLEN_CREATE"},"807":{i:0.000135499541163126,u:"../Content/Reference Material/H/HDF5 Routines/H5T_VLEN_TO_STR.htm",a:"The H5T_VLEN_TO_STR function converts an IDL_H5_VLEN array of strings to an IDL string array. This routine is written in the IDL language. Its source code can be found in the file h5t_vlen_to_str.pro in the lib subdirectory of the IDL distribution. Syntax Result = H5T_VLEN_TO_STR( Array [, / ...",t:"H5T_VLEN_TO_STR"},"808":{i:0.000484966409305906,u:"../Content/Reference Material/H/HEAP_FREE.htm",a:"The HEAP_FREE procedure recursively frees all heap variables (pointers or objects) referenced by its input argument. This routine examines the input variable, including all array elements and structure fields. When a valid pointer or object reference is encountered, that heap variable is marked for ...",t:"HEAP_FREE "},"809":{i:0.000469373801316985,u:"../Content/Reference Material/H/HEAP_GC.htm",a:"The HEAP_GC procedure performs manual garbage collection on heap variables. It searches all current IDL variables (including common blocks, widget user values, etc.) for pointers and object references and determines which heap variables have become inaccessible. Pointer heap variables are freed (via ...",t:"HEAP_GC "},"810":{i:0.0026876273830524,u:"../Content/Reference Material/H/HEAP_NOSAVE.htm",a:"The HEAP_NOSAVE procedure is used to clear the save attribute of pointer or object heap variables. For more information about the heap variable save attribute, see the documentation for the HEAP_SAVE function, which provides a more general interface for managing the save attribute of heap variables. ...",t:"HEAP_NOSAVE"},"811":{i:0.000470257550654925,u:"../Content/Reference Material/H/HEAP_REFCOUNT.htm",a:"The HEAP_REFCOUNT function returns the current reference count for a pointer or object reference (a heap variable). It can also be used to disable garbage collection for a heap variable, or for all heap variables. See Heap Variables and Automatic Garbage Collection for in-depth discussions of these ...",t:"HEAP_REFCOUNT"},"812":{i:0.00277231539675581,u:"../Content/Reference Material/H/HEAP_SAVE.htm",a:"The HEAP_SAVE function is used to query whether a pointer or object heap variable is savable. It can also be used to change the heap variable save attribute. Every pointer and object heap variable has a save attribute , which is either set (True) or not set (False). This attribute determines whether ...",t:"HEAP_SAVE"},"813":{i:0.00185753357657095,u:"../Content/Reference Material/H/HELP.htm",a:"The HELP procedure gives the user information on many aspects of the current session. The specific area for which help is desired is selected by specifying the appropriate keyword. If no arguments or keywords are specified, the default is to show the current nesting of procedures and functions, all ...",t:"HELP "},"814":{i:0.000134022649601188,u:"../Content/Reference Material/H/HILBERT.htm",a:"The HILBERT function outputs a series that has all periodic terms phase-shifted by 90 degrees. This transform has the interesting property that the correlation between a series and its own Hilbert transform is mathematically zero. This routine is written in the IDL language. Its source code can be ...",t:"HILBERT "},"815":{i:0.000174419514775766,u:"../Content/Reference Material/H/HIST_2D.htm",a:"The HIST_2D function returns the two dimensional density function (histogram) of two variables. This routine is written in the IDL language. Its source code can be found in the file hist_2d.pro in the lib subdirectory of the IDL distribution. The data type of the values specified for BIN1, BIN2, ...",t:"HIST_2D "},"816":{i:0.000174835957889468,u:"../Content/Reference Material/H/HIST_EQUAL.htm",a:"The HIST_EQUAL function returns a histogram-equalized byte array. The HISTOGRAM function is used to obtain the density distribution of the input array. The histogram is integrated to obtain the cumulative density-probability function and finally the lookup function is used to transform to the output ...",t:"HIST_EQUAL "},"817":{i:0.000302910289041167,u:"../Content/Reference Material/H/HISTOGRAM.htm",a:"The HISTOGRAM function computes the density function of Array . In the simplest case, the density function, at subscript i , is the number of Array elements in the argument with a value of i . Let F i = the value of element i , 0 ≤ i \u003c n . Let H v = result of histogram function, an integer vector. ...",t:"HISTOGRAM "},"818":{i:0.000119339160963243,u:"../Content/Reference Material/H/HLS.htm",a:"The HLS procedure creates a color table based on the HLS (Hue, Lightness, Saturation) color system. Using the input parameters, a spiral through the double-ended HLS cone is traced. Points along the cone are converted from HLS to RGB. The current colortable (and the COLORS common block) contains the ...",t:"HLS "},"819":{i:0.000595769180846373,u:"../Content/Reference Material/H/HOUGH.htm",a:"The HOUGH function implements the Hough transform, used to detect straight lines within a two-dimensional image. This function can be used to return either the Hough transform, which transforms each nonzero point in an image to a sinusoid in the Hough domain, or the Hough backprojection, where each ...",t:"HOUGH "},"820":{i:0.000523757557618106,u:"../Content/Reference Material/H/HQR.htm",a:"The HQR function returns all eigenvalues of an upper Hessenberg array. Using the output produced by the ELMHES function, this function finds all eigenvalues of the original real, nonsymmetric array. If you are working with complex inputs, use the LA_HQR function instead. Examples To compute the ...",t:"HQR "},"821":{i:0.000119339160963243,u:"../Content/Reference Material/H/HSV.htm",a:"The HSV procedure creates a color table based on the HSV (Hue and Saturation Value) color system. Using the input parameters, a spiral through the single-ended HSV cone is traced. The color representation of pixel values is linearly interpolated from beginning and ending values of hue, saturation, ...",t:"HSV "},"822":{i:5.50327019655568E-05,u:"../Content/Reference Material/I/I_list.htm",a:"I Routines ",t:"I Routines"},"823":{i:0.000524603264891046,u:"../Content/Reference Material/I/I18N_MULTIBYTETOUTF8.htm",a:"This Windows-only function converts a  string from its multibyte representation  in the operating system\u0027s default encoding to the UTF-8 representation of the string. The input encoding is the system default Windows ANSI code page. For more information, see Internationalizing Code . Syntax ...",t:"I18N_MULTIBYTETOUTF8"},"824":{i:0.00027623810835037,u:"../Content/Reference Material/I/I18N_MULTIBYTETOWIDECHAR.htm",a:"This Windows-only function converts an a string from its multibyte representation in the operating system\u0027s default encoding to an unsigned integer value representing a UTF-16, wide-character string (Unicode). The input encoding is the system default Windows ANSI code page. For more information, see ...",t:"I18N_MULTIBYTETOWIDECHAR"},"825":{i:0.00049564734758412,u:"../Content/Reference Material/I/I18N_UTF8TOMULTIBYTE.htm",a:"This Windows-only function converts a UTF-8 string to the multibyte representation of that string in the operating system\u0027s default encoding. The output encoding is the system default Windows ANSI code page. For more information, see Internationalizing Code . Syntax Multibyte_String = ...",t:"I18N_UTF8TOMULTIBYTE"},"826":{i:0.000567188951034495,u:"../Content/Reference Material/I/I18N_WIDECHARTOMULTIBYTE.htm",a:"This Windows-only function converts an unsigned integer value representing a UTF-16, wide-character string (Unicode) to the multibyte representation of that string in the operating system\u0027s default encoding. The output encoding is the system default Windows ANSI code page. For more information, see ...",t:"I18N_WIDECHARTOMULTIBYTE"},"827":{i:0.000238938141807008,u:"../Content/Reference Material/I/IBETA.htm",a:"The IBETA function computes the incomplete beta function. This routine is written in the IDL language. Its source code can be found in the file ibeta.pro in the lib subdirectory of the IDL distribution. Examples For more information on using IBETA, see Additional Examples. Example 1 Compute the ...",t:"IBETA "},"828":{i:0.000207193566783781,u:"../Content/Reference Material/I/ICONTOUR.htm",a:"Please see the CONTOUR function, which replaces the functionality of this routine. If no arguments are specified, the ICONTOUR procedure creates an empty Contour tool. Using Palettes Contour colors can be specified in several ways. By default, all contour levels are black. The COLOR keyword can be ...",t:"ICONTOUR\n        "},"829":{i:0.00116380106474691,u:"../Content/Reference Material/I/ICONVERTCOORD.htm",a:"Examples In the following examples, we convert coordinates in an iPlot visualization between device, normal, and data coordinate systems. IPLOT, /TEST, dimensions=[800,600 ; Lower left corner of window in normal space PRINT, ICONVERTCOORD(0, 0, /DEVICE, /TO_NORMAL)  ...",t:"ICONVERTCOORD\n        "},"830":{i:0.000556777829445448,u:"../Content/Reference Material/I/IDELETE.htm",a:"Syntax IDELETE [, iToolID ] Arguments iToolID This optional argument contains the identifier for the specific iTool to delete. If not provided, the current tool is destroyed. Keywords None. Example Enter the following at the IDL Command Line: IPLOT, IDENTIFIER = PlotID1ISURFACE, IDENTIFIER = ...",t:"IDELETE\n        "},"831":{i:0.000109091867016594,u:"../Content/Reference Material/I/IDENTITY.htm",a:"The IDENTITY function returns an identity array (an array with ones along the main diagonal and zeros elsewhere) of the specified dimensions. This routine is written in the IDL language. Its source code can be found in the file identity.pro in the lib subdirectory of the IDL distribution. Examples ; ...",t:"IDENTITY "},"832":{i:7.74112710220555E-05,u:"../Content/Reference Material/I/IDL_BASE64.htm",a:"The IDL_BASE64 function uses MIME Base64 encoding to convert a byte array into a Base64 encoded scalar string, or to convert a Base64-encoded scalar string into a byte array. The MIME Base64 encoding uses 64 characters, consisting of “A-Z”, “a-z”, “0-9”, “+”, and “/”. Every 3 bytes of the original ...",t:"IDL_BASE64"},"833":{i:5.50327019655568E-05,u:"../Content/Reference Material/I/IDL_Container_Object_Cla.htm",a:"IDL_Container Object Class See IDL_Container  ",t:"\n            IDL_Container Object Class\n        "},"834":{i:0.000358326314341858,u:"../Content/Reference Material/I/IDL_VALIDNAME.htm",a:"The IDL_VALIDNAME function determines whether a string may be used as a valid IDL variable name or structure tag name. Optionally, the routine can convert non-valid characters into underscores, returning a valid name string. Examples The following table provides IDL_VALIDNAME examples and their ...",t:"IDL_VALIDNAME"},"835":{i:9.18838535103434E-05,u:"../Content/Reference Material/I/IDLEXBR_ASSISTANT.htm",a:"The IDLEXBR_ASSISTANT procedure launches the Export Bridge Assistant. If no keywords are supplied, IDL launches the Assistant without opening a project. See IDL Feature Support for a list of platforms that support the Export Bridge Assistant. See Supported Platforms and IDL Modes for a list of ...",t:"IDLEXBR_ASSISTANT"},"836":{i:9.94487015997163E-05,u:"../Content/Reference Material/I/IDLITSYS_CREATETOOL.htm",a:"Examples See Chapter 5, “Example: Simple iTool” (iTool Developer’s Guide). Syntax Result = IDLITSYS_CREATETOOL( StrTool [, ANISOTROPIC_SCALE_2D = value ] [, ANISOTROPIC_SCALE_3D = value ] [, CURRENT ] [, DIMENSIONS =[ width , height ]] [, / DISABLE_SPLASH_SCREEN ] [, IDENTIFIER = variable ] [, ...",t:"IDLITSYS_CREATETOOL\n        "},"837":{i:0.000533314256858289,u:"../Content/Reference Material/I/IDLUNIT.htm",a:"The IDLUNIT function allows you to perform basic dimensional analysis, conversions, and mathematical operations, all while factoring units. IDLUNIT is designed to be flexible, allowing you to evaluate simple mathematical expressions, or convert units. Results can be used in other IDL functions and ...",t:"IDLUNIT"},"838":{i:0.000136671182185741,u:"../Content/Reference Material/I/IELLIPSE.htm",a:"IELLIPSE creates an annotation object with an identifier of OVAL . This identifier must be used when manipulating the object with routines like ISETPROPERTY. If you create the ellipse with an anisotropic coordinate system, the resulting ellipse object might not appear as expected. If the ellipse ...",t:"IELLIPSE\n        "},"839":{i:0.00024897713692785,u:"../Content/Reference Material/I/IF___THEN___ELSE.htm",a:"The IF...THEN...ELSE statement conditionally executes a statement or block of statements. Another way to write an IF...THEN...ELSE statement is with a conditional expression using the ?: operator. For more information, see Working with Conditional Expressions . Programs with vector and array ...",t:"IF...THEN...ELSE"},"840":{i:0.000258326481403067,u:"../Content/Reference Material/I/IGAMMA.htm",a:"The IGAMMA function computes the incomplete gamma function. IGAMMA uses either a power series representation or a continued fractions method. If Z is less than or equal to A +1, a power series representation is used. If Z is greater than A +1, a continued fractions method is used. This routine is ...",t:"IGAMMA "},"841":{i:0.000841080777464482,u:"../Content/Reference Material/I/IGETCURRENT.htm",a:"You can also retrieve the identifier of an iTool by specifying the IDENTIFIER keyword in the call to the routine that creates the tool (for example, IPLOT or IIMAGE). Examples Example 1 Suppose you have several iPlot tools running in your IDL session, and you want to retrieve the iTool identifier ...",t:"IGETCURRENT\n        "},"842":{i:0.000195609744317092,u:"../Content/Reference Material/I/IGETDATA.htm",a:"Examples See the example for IPUTDATA . Syntax IGETDATA, ID , Arg1 , Arg2 , ... [, OBJECT = Value ] [, TOOL = iToolID ] Arguments ID A string containing the identifier of the iTools object from which to retrieve data. If you pass a partial identifier, the IGETID function is called to retrieve the ...",t:"IGETDATA\n        "},"843":{i:0.000322166723274374,u:"../Content/Reference Material/I/IGETID.htm",a:"Because IGETID is designed to locate the most likely match for a partial identifier, retrieving some identifiers may require careful construction of the partial identifier to be expanded. See How IGETID Expands Identifiers for information on constructing useful searches. Examples IPLOT, ...",t:"IGETID\n        "},"844":{i:0.000195609744317092,u:"../Content/Reference Material/I/IGETPROPERTY.htm",a:"The keyword name used to get the property may not be the same as the human-readable name displayed on the property sheet. Examples See the example for ISETPROPERTY . Syntax IGETPROPERTY, ID [, PROPERTY = value ] [, _REGISTERED = array ] [, TOOL = iToolID ] Arguments ID A string containing the ...",t:"IGETPROPERTY\n        "},"845":{i:0.000237548153062108,u:"../Content/Reference Material/I/IIMAGE.htm",a:"Please see the IMAGE function, which replaces the functionality of this routine. If no arguments are specified, the IIMAGE procedure creates an empty Image tool. Examples In the IDL Intelligent Tools system, data can be imported from the IDL Command Line (as described in Example 1), or data can be ...",t:"IIMAGE"},"846":{i:0.000866291772837737,u:"../Content/Reference Material/I/IMAGE.htm",a:"The IMAGE function displays image data in a graphics window. See File Formats for a list of supported image types. Example The following lines create the image shown at the top of this topic. ; Display an image. file1 = FILEPATH(\u0027Night.jpg\u0027, $ SUBDIRECTORY=[\u0027examples\u0027,\u0027data\u0027])  ; The image spans ...",t:"IMAGE"},"847":{i:8.61067080048234E-05,u:"../Content/Reference Material/I/IMAGE_CONT_Procedure.htm",a:"The IMAGE_CONT procedure overlays an image with a contour plot. This routine is written in the IDL language. Its source code can be found in the file image_cont.pro in the lib subdirectory of the IDL distribution. Examples ; Create an image to display: A = BYTSCL(DIST(356)) ; Display image and ...",t:"IMAGE_CONT Procedure"},"848":{i:9.98818547664976E-05,u:"../Content/Reference Material/I/IMAGE_STATISTICS.htm",a:"The IMAGE_STATISTICS procedure computes sample statistics for a given array of values. An optional mask may be specified to restrict computations to a spatial subset of the input data. Example Copy and paste the following code at the IDL command line to see an example of using IMAGE_STATISTICS. ; ...",t:"IMAGE_STATISTICS "},"849":{i:0.000155201206088648,u:"../Content/Reference Material/I/IMAGE_THRESHOLD.htm",a:"The IMAGE_THRESHOLD function generates a threshold value for an 8 or 16 bit image. IMAGE_THRESHOLD returns a binary mask that represents whether any given pixel was below (0) or above (1) the calculated threshold value, effectively turning the input into a binary image. Examples This examples shows ...",t:"IMAGE_THRESHOLD"},"850":{i:0.000165791263925907,u:"../Content/Reference Material/I/IMAGINARY.htm",a:"The IMAGINARY function returns the imaginary part of its complex-valued argument. Examples ; Create an array of complex values: C = COMPLEX([1,2,3],[4,5,6]) ; Print just the imaginary parts of each element in C: PRINT, IMAGINARY(C) IDL prints: 4.00000 5.00000 6.00000 Syntax Result = IMAGINARY( ...",t:"IMAGINARY"},"851":{i:7.61858269340129E-05,u:"../Content/Reference Material/I/IMAP.htm",a:"Please see the MAP function, which replaces the functionality of this routine. If no arguments are specified, the IMAP procedure creates an empty iMap tool. Syntax Empty Map Projection IMAP [, MAP_PROJECTION = string ]  Image Visualization IMAP [, Image [, X , Y ]] [, GEOTIFF = variable ] [, ...",t:"IMAP"},"852":{i:0.000269184383731145,u:"../Content/Reference Material/I/INDGEN.htm",a:"The INDGEN function returns an array with the specified dimensions. Each element of the array is set to the value of its one-dimensional subscript. For example, I=INDGEN(100) will create a 100-element, 16-bit integer array with the values 0, 1, ..., 99. Syntax Result = INDGEN( D 1 [, ..., D 8 ] [, / ...",t:"INDGEN"},"853":{i:0.00059400572645962,u:"../Content/Reference Material/I/INT_2D.htm",a:"The INT_2D function computes the double integral of a bivariate function using iterated Gaussian quadrature. The algorithm’s transformation data is provided in tabulated form with 15 decimal accuracy. This routine is written in the IDL language. Its source code can be found in the file int_2d.pro in ...",t:"INT_2D "},"854":{i:0.000574348425806537,u:"../Content/Reference Material/I/INT_3D.htm",a:"The INT_3D function computes the integral of a trivariate function using iterated Gaussian quadrature. The algorithm’s transformation data is provided in tabulated form with 15 decimal accuracy. This routine is written in the IDL language. Its source code can be found in the file int_3d.pro in the ...",t:"INT_3D "},"855":{i:0.000624914514513921,u:"../Content/Reference Material/I/INT_TABULATED.htm",a:"The INT_TABULATED function integrates a tabulated set of data { X i , F i } on the closed interval [MIN( X ) , MAX( X )], using a five-point Newton-Cotes integration formula. Data that is highly oscillatory requires a sufficient number of samples for an accurate integral approximation. This routine ...",t:"INT_TABULATED "},"856":{i:0.00051748844317432,u:"../Content/Reference Material/I/INTARR.htm",a:"The INTARR function returns an integer vector or array. Examples Create I, a 3-element by 3-element integer array with each element set to 0 by entering: I = INTARR(3, 3) Syntax Result = INTARR( D 1 [ , ... , D 8 ] [, / NOZERO ] ) Return Value Returns the integer array of the specified dimensions. ...",t:"INTARR "},"857":{i:0.000240343757294518,u:"../Content/Reference Material/I/INTERPOL.htm",a:"The INTERPOL function performs linear, quadratic, or spline interpolation on vectors with a regular or irregular grid. The INTERPOL function automatically detects any NaN values in your input data, and excludes these values when computing the interpolation. This routine is written in the IDL ...",t:"INTERPOL "},"858":{i:0.000433714218948432,u:"../Content/Reference Material/I/INTERPOLATE.htm",a:"The INTERPOLATE function returns an array of linear, bilinear or trilinear interpolates, depending on the dimensions of the input array P . Interpolates outside the bounds of P can be set to a user-specified value by using the MISSING keyword. Examples The example below computes bilinear ...",t:"INTERPOLATE "},"859":{i:0.000193096636730204,u:"../Content/Reference Material/I/INTERVAL_VOLUME.htm",a:"The INTERVAL_VOLUME procedure is used to generate a tetrahedral mesh from volumetric data. The generated mesh spans the portion of the volume where the volume data samples fall between two constant data values. This can also be thought of as a mesh constructed to fill the volume between two ...",t:"INTERVAL_VOLUME "},"860":{i:0.000271914115150562,u:"../Content/Reference Material/I/INVERT.htm",a:"The INVERT function uses the Gaussian elimination method to compute the inverse of a square array. Errors from singular or near-singular arrays are accumulated in the optional Status argument. If you are working with complex inputs, use the LA_INVERT function instead. Examples ; Create an array A: A ...",t:"INVERT "},"861":{i:0.000107046733954338,u:"../Content/Reference Material/I/IOCTL.htm",a:"The IOCTL function provides a thin wrapper over the UNIX ioctl(2) system call. IOTCL performs special functions on the specified file. The set of functions actually available depends on your version of UNIX and the type of file (tty, tape, disk file, etc.) referred to. To use IOCTL, read the C ...",t:"IOCTL "},"862":{i:0.00127423323380107,u:"../Content/Reference Material/I/IOPEN.htm",a:"Examples See Additional Examples for more information on using IOPEN. Example 1 In the following example, we use the IOPEN procedure with the /VISUALIZE keyword to open and display the image meteor_crater.jpg . We then display information about the imageData variable that holds the file data. ...",t:"IOPEN\n        "},"863":{i:0.000380723997105585,u:"../Content/Reference Material/I/IR_FILTER.htm",a:"The IR_FILTER function filters data with an infinite impulse response (IIR) or finite impulse response (FIR) filter. This routine is written in the IDL language. Its source code can be found in the file ir_filter.pro in the lib subdirectory of the IDL distribution. The form of the filter is given by ...",t:"IR_FILTER"},"864":{i:9.00223248660632E-05,u:"../Content/Reference Material/I/IPLOT.htm",a:"Please see the PLOT , BARPLOT , ERRORPLOT , POLARPLOT , and PLOT3D functions, which replace the functionality of this routine. If no arguments are specified, the IPLOT procedure creates an empty Plot tool. Syntax IPLOT [, CLIP_PLANES = array ] [, COLOR = RGB vector ] [, ERRORBAR_COLOR = vector ] [, ...",t:"IPLOT\n        "},"865":{i:0.000148547505738384,u:"../Content/Reference Material/I/IPOLYGON.htm",a:"Examples In the following example, we draw a polygon around a feature in the iImage iTool. Since we draw the polygon in the data space, the polygon resizes smoothly with the image. ; Opening the data file file = FILEPATH(\u0027mineral.png\u0027, $ SUBDIRECTORY = [\u0027examples\u0027, \u0027data\u0027]) data = READ_PNG(file) ; ...",t:"IPOLYGON\n        "},"866":{i:0.000148547505738384,u:"../Content/Reference Material/I/IPOLYLINE.htm",a:"IPOLYLINE creates an annotation object with an identifier of LINE . This identifier must be used when manipulating the object with routines like ISETPROPERTY. Examples See the example for ITEXT . Syntax IPOLYLINE, Points [, ARROW_SIZE = Value ] [, ARROW_STYLE = Value ] [, / DATA | , / DEVICE | , / ...",t:"IPOLYLINE\n        "},});