define({"149":{i:0.000189629701545081,u:"../Content/Reference Material/C/COMPLEXROUND.htm",a:"The COMPLEXROUND function rounds real and imaginary components of a complex array. This routine is written in the IDL language. Its source code can be found in the file complexround.pro in the lib subdirectory of the IDL distribution. Examples X = [COMPLEX(1.245, 3.88), COMPLEX(9.1, 0.3345)] PRINT, ...",t:"COMPLEXROUND"},"150":{i:0.000127309256654586,u:"../Content/Reference Material/C/COMPUTE_MESH_NORMALS.htm",a:"The COMPUTE_MESH_NORMALS function computes normal vectors for a set of polygons described by the input array. Syntax Result = COMPUTE_MESH_NORMALS( fVerts [, iConn ] ) Return Value Returns a 3 x M array containing a unit normal for each vertex in the input array. Arguments fVerts A 3 x M array of ...",t:"COMPUTE_MESH_NORMALS "},"151":{i:0.000201476994833479,u:"../Content/Reference Material/C/COND.htm",a:"The COND function returns the condition number of a real or complex two-dimensional array A . By default, COND uses the L • norm to compute the condition number. You may use the LNORM keyword to specify the L 1 , L 2 , or L • norm. For the L 1 and L • norms, the condition number is computed from ...",t:"COND"},"152":{i:0.000565226946511581,u:"../Content/Reference Material/C/CONGRID.htm",a:"The CONGRID function shrinks or expands the size of an array by an arbitrary amount. CONGRID is similar to REBIN in that it can resize a one, two, or three dimensional array, but where REBIN requires that the new array size must be an integer multiple of the original size, CONGRID will resize an ...",t:"CONGRID "},"153":{i:0.000121409316671503,u:"../Content/Reference Material/C/CONJ.htm",a:"The CONJ function returns the complex conjugate of X . The complex conjugate of the real-imaginary pair ( x, y ) is ( x, -y ). If X is not complex, a complex-valued copy of X is used. Examples Print the conjugate of the complex pair (4.0, 5.0) by entering: PRINT, CONJ(COMPLEX(4.0, 5.0)) IDL prints: ...",t:"CONJ "},"154":{i:0.000368202697321914,u:"../Content/Reference Material/C/CONSTRAINED_MIN.htm",a:"The CONSTRAINED_MIN procedure solves nonlinear optimization problems of the following form: Minimize or maximize gp(X), subject to: glb i ≤ g i (X) ≤ gub i for i = 0,...,nfuns-1, i ≠ p xlb j ≤ x j ≤ xub j for j = 0,...,nvars-1 X is a vector of nvars variables, x 0 ,...,x nvars -1, and G is a vector ...",t:"CONSTRAINED_MIN"},"155":{i:0.00024748887170734,u:"../Content/Reference Material/C/CONTINUE.htm",a:"The CONTINUE statement provides a convenient way to immediately start the next iteration of the enclosing FOR, FOREACH, WHILE, or REPEAT loop. Do not confuse the CONTINUE statement described here with the .CONTINUE executive command. The two constructs are not related, and serve completely different ...",t:"CONTINUE "},"156":{i:0.000451566615992792,u:"../Content/Reference Material/C/CONTOUR.htm",a:"The CONTOUR function draws a two-dimensional contour plot for a 2D array of data. Instead of data, you can also input an equation of X and Y using either the input argument or the EQUATION property. In this case IDL will automatically generate the independent X and Y values and use your equation to ...",t:"CONTOUR"},"157":{i:0.000251370980354679,u:"../Content/Reference Material/C/CONTOUR_Procedure.htm",a:"Please see the CONTOUR function, which replicates the functionality of this routine and offers an interactive interface. The CONTOUR procedure draws a contour plot from data stored in a rectangular array or from a set of unstructured points. Both line contours and filled contour plots can be ...",t:"CONTOUR Procedure"},"158":{i:0.000192201096675058,u:"../Content/Reference Material/C/CONVERT_COORD.htm",a:"The CONVERT_COORD function transforms one or more sets of coordinates to and from the coordinate systems supported by IDL. The input coordinates X and, optionally, Y and/or Z can be given in data, device, or normalized form by using the DATA, DEVICE, or NORMAL keywords. The default input coordinate ...",t:"CONVERT_COORD "},"159":{i:0.000568359035518435,u:"../Content/Reference Material/C/CONVOL.htm",a:"The CONVOL function convolves an array with a kernel, and returns the result. Convolution is a general process that can be used for various types of smoothing, signal processing, shifting, differentiation, edge detection, etc. The CENTER keyword controls the alignment of the kernel with the array ...",t:"CONVOL "},"160":{i:0.000330280076281938,u:"../Content/Reference Material/C/CONVOL_FFT.htm",a:"The CONVOL_FFT function computes the convolution of an image using a product of Fourier transforms for speed. Because this algorithm uses Fourier transforms, complex numbers are used during the calculations. The returned result will either be a Float or a Double, and may differ from the CONVOL ...",t:"CONVOL_FFT"},"161":{i:0.000119528477840095,u:"../Content/Reference Material/C/COORD2TO3.htm",a:"The COORD2TO3 function converts normalized X and Y screen coordinates to 3D data coordinates. A valid 3D transform must exist in !P.T or be specified by the PTI keyword. The axis scaling variables, !X.S, !Y.S and !Z.S must be valid. This routine is written in the IDL language. Its source code can be ...",t:"COORD2TO3 "},"162":{i:0.000138368030432313,u:"../Content/Reference Material/C/COPY_LUN.htm",a:"The COPY_LUN procedure copies data between two open files. It allows you to transfer a known amount of data from one file to another without needing to have the data available in an IDL variable. COPY_LUN can copy a fixed amount of data, specified in bytes or lines of text, or it can copy from the ...",t:"COPY_LUN "},"163":{i:0.00066546762822042,u:"../Content/Reference Material/C/CORRELATE.htm",a:"The CORRELATE function computes the linear Pearson correlation coefficient of two vectors or the correlation matrix of an m x n array. Alternatively, this function computes the covariance of two vectors or the covariance matrix of an m x n array. This routine is written in the IDL language. Its ...",t:"CORRELATE "},"164":{i:0.000319743816505821,u:"../Content/Reference Material/C/COS.htm",a:"The periodic function COS returns the trigonometric cosine of X. Examples Find the cosine of 0.5 radians and print the result by entering: PRINT, COS(.5) IDL prints: 0.877583 Syntax Result = COS( X ) Return Value Returns the trigonometric cosine of X. Arguments X The angle for which the cosine is ...",t:"COS "},"165":{i:0.000222730649517988,u:"../Content/Reference Material/C/COSH.htm",a:"The COSH function returns the hyperbolic cosine of X . Examples Find the hyperbolic cosine of 0.5 radians and print the result by entering: PRINT, COSH(.5) IDL prints: 1.12763 Syntax Result = COSH( X ) Return Value Returns the hyperbolic cosine of X . Arguments X The value for which the hyperbolic ...",t:"COSH "},"166":{i:0.00170875930032933,u:"../Content/Reference Material/C/CPU.htm",a:"The CPU procedure is used to change the values stored in the read-only !CPU system variable, which in turn controls the way IDL uses the system processor or processors. Not all routines are affected by changes to the !CPU system variable. Those routines that are affected can override some of the ...",t:"CPU "},"167":{i:0.00046292593022444,u:"../Content/Reference Material/C/CRAMER.htm",a:"The CRAMER function solves an n by n linear system of equations using Cramer’s rule. This routine is written in the IDL language. Its source code can be found in the file cramer.pro in the lib subdirectory of the IDL distribution. Examples Define an array A and right-hand side vector B. A = [[ 2.0,  ...",t:"CRAMER "},"168":{i:0.000124999030941892,u:"../Content/Reference Material/C/CREATEBOXPLOTDATA.htm",a:"The CREATEBOXPLOTDATA function takes a raw input dataset and generates the data needed as input into the BOXPLOT function. CREATEBOXPLOTDATA returns five values for each input dataset: the minimum (excluding possible outliers), the lower quartile, the median, the upper quartile, and the maximum ...",t:"CREATEBOXPLOTDATA"},"169":{i:0.000355081537688964,u:"../Content/Reference Material/C/CREATE_CURSOR.htm",a:"The CREATE_CURSOR function creates an image array from a string array that represents a 16 by 16 cursor. The returned image array can be passed to the REGISTER_CURSOR procedure Image argument. This allows you to quickly design a cursor using a simple string array. Examples The following code creates ...",t:"CREATE_CURSOR "},"170":{i:0.000692218672641268,u:"../Content/Reference Material/C/CREATE_STRUCT.htm",a:"The CREATE_STRUCT function creates a structure given pairs of tag names and values. CREATE_STRUCT can also be used to concatenate structures. Examples To create the anonymous structure { A: 1, B: \u0027xxx\u0027} in the variable P , enter: p = CREATE_STRUCT(\u0027A\u0027, 1, \u0027B\u0027, \u0027xxx\u0027) To add the fields “FIRST” and ...",t:"CREATE_STRUCT "},"171":{i:7.6789836178486E-05,u:"../Content/Reference Material/C/CREATE_VIEW_Procedure.htm",a:"The CREATE_VIEW procedure sets the various system variables required to define a coordinate system and a 3-D view. This procedure builds the system viewing matrix (!P.T) in such a way that the correct aspect ratio of the data is maintained even if the display window is not square. CREATE_VIEW also ...",t:"CREATE_VIEW Procedure"},"172":{i:0.000206384335254414,u:"../Content/Reference Material/C/CROSSP.htm",a:"The CROSSP function returns a vector that is the cross-product of two input vectors, V1 and V2 . Syntax Result = CROSSP( V1 , V2 ) Return Value Returns a floating-point vector that is the cross-product of two 3-element vectors, V1 and V2 . Arguments V1, V2 Three-element vectors. Version History ...",t:"CROSSP "},"173":{i:7.70675868280127E-05,u:"../Content/Reference Material/C/CRVLENGTH.htm",a:"The CRVLENGTH function computes the length of a curve with a tabular representation, Y [ i ] = F( X [ i ]). Data that is highly oscillatory requires a sufficient number of samples for an accurate curve length computation. This routine is written in the IDL language. Its source code can be found in ...",t:"CRVLENGTH "},"174":{i:8.05182555445229E-05,u:"../Content/Reference Material/C/CT_LUMINANCE.htm",a:"The CT_LUMINANCE function calculates the luminance of colors. This routine is written in the IDL language. Its source code can be found in the file ct_luminance.pro in the lib subdirectory of the IDL distribution. Syntax Result = CT_LUMINANCE( [ R , G , B ] [, BRIGHT = variable ] [, DARK = variable ...",t:"CT_LUMINANCE"},"175":{i:0.00022299040812966,u:"../Content/Reference Material/C/CTI_TEST.htm",a:"The CTI_TEST function constructs a “contingency table” from an array of observed frequencies and tests the hypothesis that the rows and columns are independent using an extension of the chi-square goodness-of-fit test. This routine is written in the IDL language. Its source code can be found in the ...",t:"CTI_TEST "},"176":{i:0.000255252218044181,u:"../Content/Reference Material/C/CURSOR_Procedure.htm",a:"The CURSOR procedure is used to read the position of the interactive graphics cursor from the current graphics device. Note that not all graphics devices have interactive cursors. CURSOR enables the graphic cursor on the device and optionally waits for the operator to position it. On devices that ...",t:"CURSOR Procedure"},"177":{i:0.000689286876819889,u:"../Content/Reference Material/C/CURVEFIT.htm",a:"The CURVEFIT function uses a gradient-expansion algorithm to compute a non-linear least squares fit to a user-supplied function with an arbitrary number of parameters. The user-supplied function may be any non-linear function where the partial derivatives are known or can be approximated. Iterations ...",t:"CURVEFIT "},"178":{i:0.00022478523164247,u:"../Content/Reference Material/C/CV_COORD.htm",a:"The CV_COORD function converts 2D and 3D coordinates between the rectangular, polar, cylindrical, and spherical coordinate systems. This routine is written in the IDL language. Its source code can be found in the file cv_coord.pro in the lib subdirectory of the IDL distribution. Examples Convert ...",t:"CV_COORD "},"179":{i:0.00020809821449386,u:"../Content/Reference Material/C/CVTTOBM.htm",a:"The CVTTOBM function converts a byte array in which each byte represents one pixel into a “bitmap byte array” in which each bit represents one pixel. This is useful when creating bitmap labels for buttons created with the WIDGET_BUTTON function. Most of IDL’s image file format reading functions ...",t:"CVTTOBM "},"180":{i:0.000192492243151692,u:"../Content/Reference Material/C/CW_ANIMATE.htm",a:"The CW_ANIMATE function creates a compound widget that— along with its associated routines — displays an animated sequence of images using off-screen windows knows as pixmaps . The speed and direction of the display can be adjusted using the widget interface. CW_ANIMATE provides the graphical ...",t:"CW_ANIMATE "},"181":{i:0.000166202895115334,u:"../Content/Reference Material/C/CW_ANIMATE_GETP.htm",a:"The CW_ANIMATE_GETP procedure gets a copy of the vector of pixmap window IDs being used by a CW_ANIMATE animation widget. If this routine is called, CW_ANIMATE does not destroy the pixmaps when it is destroyed. You can then provide the pixmaps to a later instance of CW_ANIMATE to re-use them, ...",t:"CW_ANIMATE_GETP"},"182":{i:0.000166202895115334,u:"../Content/Reference Material/C/CW_ANIMATE_LOAD.htm",a:"The CW_ANIMATE_LOAD procedure creates an array of pixmaps which are loaded into a CW_ANIMATE compound widget. CW_ANIMATE provides the graphical interface used by the XINTERANIMATE procedure, which is the preferred routine for displaying animation sequences in most situations. Use this widget instead ...",t:"CW_ANIMATE_LOAD"},"183":{i:0.000166202895115334,u:"../Content/Reference Material/C/CW_ANIMATE_RUN.htm",a:"The CW_ANIMATE_RUN procedure displays a series of images that have been loaded into a CW_ANIMATE compound widget by a call to CW_ANIMATE_LOAD. CW_ANIMATE provides the graphical interface used by the XINTERANIMATE procedure, which is the preferred routine for displaying animation sequences in most ...",t:"CW_ANIMATE_RUN"},"184":{i:7.79278777946764E-05,u:"../Content/Reference Material/C/CW_ARCBALL.htm",a:"The CW_ARCBALL function creates a compound widget for intuitively specifying three-dimensional orientations. The user drags a simulated track-ball with the mouse to interactively obtain arbitrary rotations. Sequences of rotations may be cascaded. The rotations may be unconstrained (about any axis), ...",t:"CW_ARCBALL  "},"185":{i:0.000324755328845314,u:"../Content/Reference Material/C/CW_BGROUP.htm",a:"The CW_BGROUP function creates a widget base of buttons. It simplifies creation of a cluster of buttons, and handles the details of creating the proper base (standard, exclusive, or non-exclusive) and filling in the desired buttons. Button groups can be simple menus in which each button acts ...",t:"CW_BGROUP "},"186":{i:0.000114503812619765,u:"../Content/Reference Material/C/CW_CLR_INDEX.htm",a:"The CW_CLR_INDEX function creates a compound widget that displays a horizontal color bar and allows the user to select a color index. Clicking on the bar sets the color index. This routine is written in the IDL language. Its source code can be found in the file cw_clr_index.pro in the lib ...",t:"CW_CLR_INDEX  "},"187":{i:0.000102744664253186,u:"../Content/Reference Material/C/CW_COLORSEL.htm",a:"The CW_COLORSEL function creates a compound widget that displays all the colors in the current colormap in a 16 x 16 (320 x 320 pixels) grid. To select a color index, the user moves the mouse pointer over the desired color square and presses any mouse button. Alternatively, the color index can be ...",t:"CW_COLORSEL  "},"188":{i:0.000158432870069714,u:"../Content/Reference Material/C/CW_DEFROI.htm",a:"The CW_DEFROI function creates a compound widget that allows the user to define a region of interest within a widget draw window. This is a modal widget. No other widget applications will be responsive while this widget is in use. Also, since CW_DEFROI has its own event-handling loop, it should not ...",t:"CW_DEFROI "},"189":{i:0.000116630806898312,u:"../Content/Reference Material/C/CW_FIELD.htm",a:"The CW_FIELD function creates a widget data entry field. The field consists of a label and a text widget. CW_FIELD can create string, integer, or floating-point fields. The default is an editable string field. This routine is written in the IDL language. Its source code can be found in the file ...",t:"CW_FIELD  "},"190":{i:6.68880880696338E-05,u:"../Content/Reference Material/C/CW_FILESEL.htm",a:"The CW_FILESEL function is a compound widget for file selection. This routine is written in the IDL language. Its source code can be found in the file cw_filesel.pro in the lib subdirectory of the IDL distribution. Examples This example creates a CW_FI LESEL widget that is used to select image files ...",t:"CW_FILESEL "},"191":{i:6.68880880696338E-05,u:"../Content/Reference Material/C/CW_FORM.htm",a:"The CW_FORM function is a compound widget that simplifies creating small forms which contain text, numeric fields, buttons, lists, and droplists. Event handling is also simplified. This routine is written in the IDL language. Its source code can be found in the file cw_form.pro in the lib ...",t:"CW_FORM"},"192":{i:9.24231483451084E-05,u:"../Content/Reference Material/C/CW_FSLIDER.htm",a:"The CW_FSLIDER function creates a slider that selects floating-point values. This routine is written in the IDL language. Its source code can be found in the file cw_fslider.pro in the lib subdirectory of the IDL distribution. Using CW_FSLIDER To get or set the value of a CW_FSLIDER widget, use the ...",t:"CW_FSLIDER  "},"193":{i:0.000140510335671832,u:"../Content/Reference Material/C/CW_LIGHT_EDITOR.htm",a:"The CW_LIGHT_EDITOR function creates a compound widget to edit properties of existing IDLgrLight objects in a view. Lights cannot be added or removed from a view using this widget. However, lights can be “turned off or on” by hiding or showing them (i.e., HIDE property). Two routines associated with ...",t:"CW_LIGHT_EDITOR "},"194":{i:0.000140510335671832,u:"../Content/Reference Material/C/CW_LIGHT_EDITOR_GET.htm",a:"The CW_LIGHT_EDITOR_GET procedure gets the CW_LIGHT_EDITOR properties. Syntax CW_LIGHT_EDITOR_GET, WidgetID [, DIRECTION_DISABLED =variable ] [, DRAG_EVENTS =variable ] [, HIDE_DISABLED =variable ] [, LIGHT = variable ] [, LOCATION_DISABLED =variable ] [, TYPE_DISABLED =variable ] [, XSIZE = ...",t:"CW_LIGHT_EDITOR_GET "},"195":{i:0.00013813076785634,u:"../Content/Reference Material/C/CW_LIGHT_EDITOR_SET.htm",a:"The CW_LIGHT_EDITOR procedure sets the CW_LIGHT_EDITOR properties. Syntax CW_LIGHT_EDITOR_SET, WidgetID [, / DIRECTION_DISABLED ] [, / DRAG_EVENTS ] [, / HIDE_DISABLED ] [, LIGHT = objref(s) ] [, / LOCATION_DISABLED ] [, / TYPE_DISABLED ] [, XSIZE = pixels ] [, YSIZE = pixels ] [, XRANGE = vector ] ...",t:"CW_LIGHT_EDITOR_SET "},"196":{i:6.68880880696338E-05,u:"../Content/Reference Material/C/CW_ORIENT.htm",a:"The CW_ORIENT function creates a compound widget lets you interactively adjust the three-dimensional drawing transformation and resets the !P.T system variable field to reflect the changed orientation. This routine is written in the IDL language. Its source code can be found in the file ...",t:"CW_ORIENT "},"197":{i:0.000284707092319125,u:"../Content/Reference Material/C/CW_PALETTE_EDITOR.htm",a:"The CW_PALETTE_EDITOR function creates a compound widget to display and edit color palettes. The palette editor is a base that contains a drawable area to display the color palette, a set of vectors that represent the palette and an optional histogram. Two routines associated with the ...",t:"CW_PALETTE_EDITOR "},"198":{i:0.00018866983379456,u:"../Content/Reference Material/C/CW_PALETTE_EDITOR_GET.htm",a:"The CW_PALETTE_EDITOR_GET procedure gets the CW_PALETTE_EDITOR properties. Syntax CW_PALETTE_EDITOR_GET, WidgetID [, ALPHA = variable ] [, HISTOGRAM = variable ] Arguments WidgetID The widget ID of the CW_PALETTE_EDITOR compound widget. Keywords ALPHA Set this keyword to a named variable that will ...",t:"CW_PALETTE_EDITOR_GET "},"199":{i:0.00018866983379456,u:"../Content/Reference Material/C/CW_PALETTE_EDITOR_SET.htm",a:"The CW_PALETTE_EDITOR_SET procedure sets the CW_PALETTE_EDITOR properties. Syntax CW_PALETTE_EDITOR_SET, WidgetID [, ALPHA = byte_vector ] [, HISTOGRAM = byte _ vector ] Arguments WidgetID The widget ID of the CW_PALETTE_EDITOR compound widget. Keywords ALPHA A 256 element byte vector that describes ...",t:"CW_PALETTE_EDITOR_SET "},"200":{i:0.000319939143626481,u:"../Content/Reference Material/C/CW_PDMENU.htm",a:"The CW_PDMENU function creates widget pulldown menus, which can include sub-menus, from a set of buttons. It has a simpler interface than the XPDMENU procedure, which it replaces. Events for the individual buttons are handled transparently, and a CW_PDMENU event returned. This event can return any ...",t:"CW_PDMENU  "},"201":{i:6.91714181476282E-05,u:"../Content/Reference Material/C/CW_RGBSLIDER.htm",a:"The CW_RGBSLIDER function creates a compound widget that provides three sliders for adjusting color values. The RGB, CMY, HSV, and HLS color systems can all be used. No matter which color system is in use, the resulting color is always supplied in RGB, which is the base system for IDL. This routine ...",t:"CW_RGBSLIDER  "},"202":{i:0.000113875661849111,u:"../Content/Reference Material/C/CW_TMPL.htm",a:"The CW_TMPL procedure is a template for compound widgets that use the XMANAGER. Use this template instead of writing your compound widgets from “scratch”. This template can be found in the file cw_tmpl.pro in the lib subdirectory of the IDL distribution. Syntax Result = CW_TMPL( Parent [, TAB_MODE = ...",t:"CW_TMPL "},"203":{i:0.000195314390582862,u:"../Content/Reference Material/C/CW_ZOOM.htm",a:"The CW_ZOOM function creates a compound widget that displays two images: an original image in one window and a zoomed portion of the original image in another. The user can select the center of the zoom region, the zoom scale, the interpolation style, and the method of indicating the zoom center. ...",t:"CW_ZOOM "},"204":{i:5.50327019655568E-05,u:"../Content/Reference Material/D/D_list.htm",a:"D Routines ",t:"D Routines"},"205":{i:5.50327019655568E-05,u:"../Content/Reference Material/D/DB_EXISTS.htm",a:"Use the DB_EXISTS function to determine if the database functionality is available on a specific platform. Syntax status = DB_EXISTS() Return Value DB_EXISTS returns true (1) if the platform in use supports ODBC and the user is licensed to use the IDL DataMiner, or false (0) if it is not available. ...",t:"DB_EXISTS\n        "},"206":{i:0.00051748844317432,u:"../Content/Reference Material/D/DBLARR.htm",a:"The DBLARR function creates a double-precision, floating-point vector or array of the specified dimensions. Examples To create D, an 3-element by 3-element, double-precision, floating-point array with every element set to 0.0, enter: D = DBLARR(3, 3) Syntax Result = DBLARR( D 1 [ , ..., D 8 ] [, / ...",t:"DBLARR "},"207":{i:8.88539542044977E-05,u:"../Content/Reference Material/D/DCINDGEN.htm",a:"The DCINDGEN function creates a complex, double-precision, floating-point array with the specified dimensions. Each element of the array has its real part set to the value of its one-dimensional subscript. The imaginary part is set to zero. For example, C=DCINDGEN(100) will create a 100-element, ...",t:"DCINDGEN"},"208":{i:0.000586659852160182,u:"../Content/Reference Material/D/DCOMPLEX.htm",a:"The DCOMPLEX function returns double-precision complex scalars or arrays given one or two scalars or arrays. If only one parameter is supplied, the imaginary part of the result is zero, otherwise it is set to the value of the Imaginary parameter. Parameters are first converted to double-precision ...",t:"DCOMPLEX "},"209":{i:0.000495768735481438,u:"../Content/Reference Material/D/DCOMPLEXARR.htm",a:"The DCOMPLEXARR function returns a complex, double-precision, floating-point vector or array. Examples To create an empty, 5-element by 5-element, complex array DC, enter: DC = DCOMPLEXARR(5, 5) Syntax Result = DCOMPLEXARR( D 1 [ , ... , D 8 ] [, / NOZERO ] ) Return Value Returns a complex, ...",t:"DCOMPLEXARR "},"210":{i:0.00013995127868869,u:"../Content/Reference Material/D/DEFINE_KEY.htm",a:"The DEFINE_KEY procedure programs the keyboard function Key with the string Value , or with one of the actions specified by the available keywords. DEFINE_KEY is intended for use with IDL’s command-line mode on Unix, and is not compatible with the IDL Workbench or with the command-line on Windows. ...",t:"DEFINE_KEY "},"211":{i:0.000567508447564349,u:"../Content/Reference Material/D/DEFINE_MSGBLK.htm",a:"The DEFINE_MSGBLK procedure defines and loads a new message block into the currently running IDL session. Messages are issued from a message block using the MESSAGE procedure, which handles the details of IDL message display, including proper formatting, setting the values of the !ERROR_STATE system ...",t:"DEFINE_MSGBLK"},"212":{i:0.000567508447564349,u:"../Content/Reference Material/D/DEFINE_MSGBLK_FROM_FILE.htm",a:"The DEFINE_MSGBLK_FROM_FILE procedure reads the definition of a message block from a file, and uses DEFINE_MSGBLK to load it into the currently running IDL session. Messages are issued from a message block using the MESSAGE procedure, which handles the details of IDL message display, including ...",t:"DEFINE_MSGBLK_FROM_FILE "},"213":{i:0.00015703062474987,u:"../Content/Reference Material/D/DEFROI.htm",a:"The DEFROI function defines an irregular region of interest of an image using the image display system and the cursor and mouse. DEFROI only works for interactive, pixel oriented devices with a cursor and an exclusive or writing mode. Regions may have at most 1000 vertices. DEFROI does not function ...",t:"DEFROI "},"214":{i:0.000371206858647425,u:"../Content/Reference Material/D/DEFSYSV.htm",a:"The DEFSYSV procedure creates a new system variable called Name initialized to Value . Examples To create a new, floating-point, scalar system variable called !NEWVAR with an initial value of 2.0, enter: DEFSYSV, \u0027!NEWVAR\u0027, 2.0 You can both define and use a system variable within a single procedure: ...",t:"DEFSYSV "},"215":{i:0.000642233794710785,u:"../Content/Reference Material/D/DELVAR.htm",a:"The DELVAR procedure deletes variables from the main IDL program level. DELVAR frees any memory used by the variable and removes it from the main program’s symbol table. The following restrictions apply: DELVAR can only be called from the main program level. If a main program is created with the ...",t:"DELVAR "},"216":{i:6.65442933359059E-05,u:"../Content/Reference Material/D/DENDRO_PLOT_Procedure.htm",a:"Given a hierarchical tree cluster, usually created by the CLUSTER_TREE function, the DENDRO_PLOT procedure draws a two-dimensional dendrite plot on the current direct graphics device. This routine is written in the IDL language. Its source code can be found in the file dendro_plot.pro in the lib ...",t:"DENDRO_PLOT Procedure"},"217":{i:0.000530128605600052,u:"../Content/Reference Material/D/DENDROGRAM.htm",a:"Given a hierarchical tree cluster, usually created by the CLUSTER_TREE function, the DENDROGRAM procedure constructs a dendrogram and returns a set of vertices and connectivity that can be used to visualize the dendrite plot. This routine is written in the IDL language. Its source code can be found ...",t:"DENDROGRAM"},"218":{i:8.45007048452803E-05,u:"../Content/Reference Material/D/DERIV.htm",a:"The DERIV function uses three-point (quadratic) Lagrangian interpolation to compute the derivative of an evenly-spaced or unevenly-spaced array of data. Given three neighboring points in your data with X coordinates [x 0 , x 1 , x 2 ] and Y coordinates [y 0 , y 1 , y 2 ], the three-point Lagrangian ...",t:"DERIV "},"219":{i:8.45007048452803E-05,u:"../Content/Reference Material/D/DERIVSIG.htm",a:"The DERIVSIG function computes the standard deviation of the uncertainty of the derivative found by the DERIV function, using the standard deviations of the estimated errors in the X and Y parameters. The standard deviations are computed using the method of propagation of errors. Given a function of ...",t:"DERIVSIG "},"220":{i:0.000205172754438652,u:"../Content/Reference Material/D/DETERM.htm",a:"The DETERM function computes the determinant of an n by n array. LU decomposition is used to represent the input array in triangular form. The determinant is then computed as the product of diagonal elements of the triangular form. Row interchanges are tracked during the LU decomposition to ensure ...",t:"DETERM "},"221":{i:0.00054561005501002,u:"../Content/Reference Material/D/DEVICE_Procedure.htm",a:"Syntax | Examples | Version History The DEVICE procedure provides device-dependent control over the current graphics device (as set by the SET_PLOT routine). The IDL graphics procedures and functions are device-independent. That is, IDL presents the user with a consistent interface to all devices. ...",t:"DEVICE Procedure"},"222":{i:0.000286936612117367,u:"../Content/Reference Material/D/DFPMIN.htm",a:"The DFPMIN procedure minimizes a user-written function Func of two or more independent variables using the Broyden-Fletcher-Goldfarb-Shanno variant of the Davidon-Fletcher-Powell method, using its gradient as calculated by a user-written function Dfunc . DFPMIN is based on the routine dfpmin ...",t:"DFPMIN "},});