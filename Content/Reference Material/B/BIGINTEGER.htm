<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-US" xml:lang="en-US" data-mc-search-type="Stem" data-mc-help-system-file-name="idl.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="Routines (alphabetical)|Routines: B">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>BigInteger</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/TableStyles/Description.css" rel="stylesheet" />
        <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/Doc_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix"> </span><a class="MCBreadcrumbsLink" href="../../images/ref_part1.htm">Routines (alphabetical)</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="B_list.htm">Routines: B</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">BigInteger Class</span>
        </div>
        <h1 class="Routine"><a name="kanchor84"></a><a name="BigInteger"></a>BigInteger</h1>
        <p>The BigInteger class allows you to create and manipulate integer numbers of any size.</p>
        <p>The BigInteger class stores a number as an array of unsigned, 32-bit integer "digits" with a radix, or base, of 4294967296. The class stores the digits in little-endian order, with the most-significant digit at the end of the array. The sign (positive or negative) is stored as a separate flag.</p>
        <p>For speed, all of the basic math operations are written in C code. However, the BigInteger class and many of its methods are written in the IDL language. You can find the source code in the file <code>lib/datatypes/biginteger__define.pro</code> in your IDL installation.</p>
        <h3>Examples</h3>
        <h4>Constructors</h4>
        <p>You can create BigIntegers from regular numbers or from strings. For example, all of the following statements produce the same BigInteger value:</p>
        <p class="Code">b = BigInteger(-1440154473791)</p>
        <p class="Code">b = -BigInteger(1440154473791)</p>
        <p class="Code">b = BigInteger('-1440154473791')</p>
        <p class="Code">b = BigInteger('1440154473791', SIGN=-1)</p>
        <p class="Code">b = BigInteger('-14f4fe5553f', RADIX=16)</p>
        <p class="Code">b = BigInteger('14f4fe5553f', RADIX=16, SIGN=-1)</p>
        <p class="Code">b = BigInteger('-10100111101001111111001010101010100111111', RADIX=2)</p>
        <p class="Code">b = BigInteger('-IDLISFUN', RADIX=36)</p>
        <p>You can also use special constructors to create BigIntegers. For example:</p>
        <p class="Code">b = BigInteger.Factorial(100000)</p>
        <p class="Code">c = BigInteger.Random(2048)</p>
        <p class="Code">HELP, b, c</p>
        <p>IDL prints:</p>
        <p class="Code">B               BIGINTEGER &lt;ID=1 LENGTH=1516705 bits&gt; = 2.8242294079603480...x10^456573</p>
        <p class="Code">C               BIGINTEGER &lt;ID=2 LENGTH=2048 bits&gt; = 2.4851685629963955...x10^616</p>
        <h4>Math Expressions</h4>
        <p>You can use BigIntegers in mathematical expressions in combination with other BigIntegers or regular numbers.</p>
        <p class="Code">b = BigInteger(89681)</p>
        <p class="Code">c = b*96079</p>
        <p class="Code">d = c^1000 + 1</p>
        <p class="Code">HELP, d</p>
        <p>IDL prints:</p>
        <p class="Code">D               BIGINTEGER &lt;ID=1 LENGTH=33005 bits&gt; = 2.1326348897083203...x10^9935</p>
        <h4>Useful Methods</h4>
        <p>The BigInteger class has numerous methods for exploring the properties of your BigInteger numbers. For example:</p>
        <p class="Code">d = BigInteger.Prime(1024)</p>
        <p class="Code">PRINT, d</p>
        <p class="Code">PRINT, d.IsPrime() ? "true" : "false"</p>
        <p class="Code">PRINT, "The next prime is ", d.NextPrime() - d, " greater."</p>
        <p>IDL prints:</p>
        <p class="Code">1149852122999776946265950910757778460801690763339596229715397877648741495523473947736</p>
        <p class="Code">9123431875461037047773232597449876136824910342085113678568090440263273346403963966558</p>
        <p class="Code">7022954039171507173198715249963367029415827692424955706299669891876155639956998605077</p>
        <p class="Code">128420061437794990570729762185868510044669595754416741</p>
        <p class="Code">&#160;</p>
        <p class="Code">true</p>
        <p class="Code">&#160;</p>
        <p class="Code">The next prime is 298 greater.</p>
        <h3>Static Constructors</h3>
        <ul>
            <li value="1"><a href="#Syntax" class="selected">BigInteger( <i>Value</i>, RADIX=integer, SIGN=integer )</a>
            </li>
            <li value="2"><a href="#Factorial" class="selected">BigInteger.Factorial( <i>N</i> )</a>
            </li>
            <li value="3"><a href="#Prime" class="selected">BigInteger.Prime( <i>BitLength</i>, SEED=<i>value</i> )</a>
            </li>
            <li value="4"><a href="#Primorial" class="selected">BigInteger.Primorial( n, COUNT=<i>variable</i>, /IS_INDEX )</a>
            </li>
            <li value="5"><a href="#Random" class="selected">BigInteger.Random( <i>BitLength</i>, /EXACT, SEED=<i>value</i> )</a>
            </li>
        </ul>
        <h3>Methods</h3>
        <ul>
            <li value="1"><a href="#BitLength" class="selected">BigInteger::BitLength</a>
            </li>
            <li value="2"><a href="#GCD" class="selected">BigInteger::GCD</a>
            </li>
            <li value="3"><a href="#GetPrimes" class="selected">BigInteger::GetPrimes</a>
            </li>
            <li value="4"><a href="#GetProperty" class="selected">BigInteger::GetProperty</a>
            </li>
            <li value="5"><a href="#Hashcode" class="selected">BigInteger::Hashcode</a>
            </li>
            <li value="6"><a href="#IsPowerOfTwo" class="selected">BigInteger::IsPowerOfTwo</a>
            </li>
            <li value="7"><a href="#IsPrime" class="selected">BigInteger::IsPrime</a>
            </li>
            <li value="8"><a href="#LCM" class="selected">BigInteger::LCM</a>
            </li>
            <li value="9"><a href="#Log2" class="selected">BigInteger::Log2</a>
            </li>
            <li value="10"><a href="#Log10" class="selected">BigInteger::Log10</a>
            </li>
            <li value="11"><a href="#ModInverse" class="selected">BigInteger::ModInverse</a>
            </li>
            <li value="12"><a href="#ModPower" class="selected">BigInteger::ModPower</a>
            </li>
            <li value="13"><a href="#NextPrime" class="selected">BigInteger::NextPrime</a>
            </li>
            <li value="14"><a href="#Primorial" class="selected">BigInteger::Primorial</a>
            </li>
            <li value="15"><a href="#Signum" class="selected">BigInteger::Signum</a>
            </li>
            <li value="16"><a href="#Sqrt" class="selected">BigInteger::Sqrt</a>
            </li>
            <li value="17"><a href="#ToDouble" class="selected">BigInteger::ToDouble</a>
            </li>
            <li value="18"><a href="#ToInteger" class="selected">BigInteger::ToInteger</a>
            </li>
            <li value="19"><a href="#ToString" class="selected">BigInteger::ToString</a>
            </li>
        </ul>
        <h3>Additional Information</h3>
        <ul>
            <li value="1"><a href="#Operator" class="selected">Operators</a>
            </li>
            <li value="2"><a href="#Logical" class="selected">Logical Truth and Negation</a>
            </li>
            <li value="3"><a href="#Help" class="selected">Help and Print</a>
            </li>
            <li value="4"><a href="#ISA" class="selected">ISA and TYPENAME</a>
            </li>
            <li value="5"><a href="#Copying" class="selected">Copying BigIntegers</a>
            </li>
        </ul>
        <h2 class="API"><a name="Syntax"></a>Syntax</h2>
        <p class="Syntax"><i>Result</i> = BigInteger( )</p>
        <p>or</p>
        <p class="Syntax"><i>Result</i> = BigInteger( <i>Digits</i>,  SIGN=integer )</p>
        <p>or</p>
        <p class="Syntax"><i>Result</i> = BigInteger( <i>Value</i>,  SIGN=integer )</p>
        <p>or</p>
        <p class="Syntax"><i>Result</i> = BigInteger( <i>String</i>, RADIX=integer, SIGN=integer  )</p>
        <h2 class="API">Return Value </h2>
        <p>Returns a <i>reference</i> to the newly-created BigInteger.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Digits</h3>
        <p>Set this argument to an array of unsigned long integers (type ULONG) that contains the BigInteger value as a series of digits in radix 4294967296. You should input the digits in little-endian order, with the most significant digit at the end of the array. For negative BigInteger numbers, set the SIGN keyword to –1.</p>
        <h3 class="Argument">Value</h3>
        <p>Set this argument to an integer or float to be transformed into a BigInteger. Float values will be truncated to integers. For negative numbers you can either specify a negative <i>Value</i> or set the SIGN keyword.</p>
        <h3 class="Argument">String</h3>
        <p>Set this argument to a string containing the number. You can use the RADIX keyword if your string is in a radix other than the default of base 10. The string is case insensitive. For negative numbers you can either use a "–" sign at the beginning of your string, or set the SIGN keyword.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">RADIX</h3>
        <p style="font-style: italic;">Integer, 2–36, default = 10</p>
        <p>The radix of the input <i>String</i>. This keyword can only be used with a string argument. For example, if your <i>String</i> is in base 16 (hexadecimal) then you would set RADIX=16. In this case, the <i>String</i> should contain the digits <code>0–9</code> and the letters <code>A–F</code> or <code>a–f</code>. If your string happened to be in base 36 then you could use the digits  <code>0–9</code> and all letters of the alphabet <code>A–Z</code>.</p>
        <h3 class="Keyword">SIGN</h3>
        <p style="font-style: italic;">Integer, -1, 0, or 1, default = 1</p>
        <p>The sign of the BigInteger: –1 for negative, 0 for zero value, 1 for positive.</p>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>If you use a string or integer value and it already has a minus sign, then you do not need to set the SIGN keyword.</p>
        <h2 class="API">Properties</h2>
        <p>You can retrieve the following properties using either "dot" notation or the <a href="#GetProperty" class="selected">::GetProperty</a> method. For example:</p>
        <p class="Code">b = -BigInteger(2)^100</p>
        <p class="Code">d = b.DIGITS</p>
        <p class="Code">s = b.SIGN</p>
        <p class="Code">; Or, using GetProperty...</p>
        <p class="Code">; b.GetProperty, DIGITS=d, SIGN=s</p>
        <p class="Code">PRINT, d, s</p>
        <p>IDL prints:</p>
        <p class="Code">0           0           0          16</p>
        <p class="Code">-1</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>BigInteger objects are immutable: You cannot set the DIGITS or SIGN properties.</p>
        <h3><a name="DIGITS"></a>DIGITS</h3>
        <p>This property contains the BigInteger number as a series of unsigned 32-bit integers in base 4294967296, stored in little-endian order (largest digit at the end).</p>
        <h3><a name="SIGN"></a>SIGN</h3>
        <p>This property is an integer (–1, 0, or 1) that indicates whether the BigInteger number is negative, zero, or positive.</p>
        <h1 class="ObjMethod"><a name="BitLength"></a>BigInteger::BitLength</h1>
        <p>The BigInteger::BitLength method returns the number of bits in the number.</p>
        <h2 class="API">Example</h2>
        <p class="Code">bigint = BigInteger(2)^1279 - 1</p>
        <p class="Code">PRINT, bigint.BitLength()</p>
        <p>IDL prints:</p>
        <p class="Code">1279</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= bigint.BitLength( )</p>
        <h2 class="API">Return Value</h2>
        <p>An integer giving the number of bits in the BigInteger value.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Since there is no "sign" bit in a BigInteger value, a negative BigInteger value will have the same bit length as the corresponding positive value.</p>
        <h2 class="API">Arguments</h2>
        <p>None</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h1 class="ObjMethod"><a name="Factorial"></a>BigInteger::Factorial</h1>
        <p>The BigInteger::Factorial static constructor method returns a new BigInteger containing the value of <i>N</i>!.</p>
        <h2 class="API">Example</h2>
        <p class="Code">bigint = BigInteger.Factorial(100)</p>
        <p class="Code">PRINT, bigint</p>
        <p>IDL prints:</p>
        <p class="Code">9332621544394415268169923885626670049071596826438162146859296389521759999322991</p>
        <p class="Code">5608941463976156518286253697920827223758251185210916864000000000000000000000000</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= BigInteger.Factorial( <i>N</i> )</p>
        <h2 class="API">Return Value</h2>
        <p>A BigInteger equal to <i>N</i>!.</p>
        <h2 class="API">Arguments</h2>
        <p>N</p>
        <p>An integer giving the factorial value.</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h1 class="ObjMethod"><a name="GCD"></a>BigInteger::GCD</h1>
        <p>The BigInteger::GCD method computes the greatest common divisor (the greatest common factor) between this BigInteger and another integer. The greatest common divisor is the largest integer that evenly divides each number (i.e., the remainder is 0). By definition the GCD will always be greater than or equal to 1 and less than or equal to the smaller of the two numbers.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">u = BigInteger.Factorial(49000)</p>
        <p class="Code">   v = BigInteger.Factorial(6000) + 34</p>
        <p class="Code">  result = u.GCD(v)</p>
        <p class="Code">HELP, u, v</p>
        <p class="Code">PRINT, "GCD = ", result</p>
        <p>IDL prints:</p>
        <p class="Code">U               BIGINTEGER &lt;ID=1 LENGTH=692762 bits&gt; = 8.3655952924066987...x10^208541</p>
        <p class="Code">V               BIGINTEGER &lt;ID=2 LENGTH=66656 bits&gt; = 2.6839997657267398...x10^20065</p>
        <p class="Code">GCD = 275978</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = bigint.GCD( <i>Value</i> )</p>
        <h2 class="API">Return Value </h2>
        <p>Returns a BigInteger containing the greatest common divisor of <i>bigint</i> and <i>Value</i>.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Value</h3>
        <p>Set this argument to either a normal IDL integer or a BigInteger.</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h1 class="ObjMethod"><a name="GetPrimes"></a>BigInteger::GetPrimes</h1>
        <p>The BigInteger::GetPrimes static method returns an unsigned integer array containing the prime numbers up to a certain maximum.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>The GetPrimes method will only return prime numbers up to the maximum that will fit in an unsigned 32-bit integer. For larger primes you should use the <a href="#NextPrime" class="selected">NextPrime</a> method.</p>
        <h2 class="API">Example</h2>
        <p class="Code">; All prime numbers up to 100.</p>
        <p class="Code">result = BigInteger.GetPrimes(100, COUNT=c)</p>
        <p class="Code">PRINT, "The first ", c, " primes are:"</p>
        <p class="Code">PRINT, result, FORMAT='(13I4)'</p>
        <p>IDL prints:</p>
        <p class="Code">The first           25 primes are:</p>
        <p class="Code">2   3   5   7  11  13  17  19  23  29  31  37  41</p>
        <p class="Code">43  47  53  59  61  67  71  73  79  83  89  97</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= bigint.GetPrimes( <i>N</i>, COUNT=<i>variable</i>, /IS_INDEX )</p>
        <h2 class="API">Return Value</h2>
        <p>An array of unsigned 32-bit integers.</p>
        <h2 class="API">Arguments</h2>
        <p>N</p>
        <p>An integer giving the maximum value to return. All prime numbers less than or equal to <i>N</i> will be included (<i>N</i> itself does not need to be prime).</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">COUNT</h3>
        <p style="font-style: italic;">Output variable</p>
        <p>Returns the number of prime numbers in <i>Result</i>. If IS_INDEX is set then COUNT will be equal to <i>N</i>.</p>
        <h3 class="Keyword">IS_INDEX</h3>
        <p style="font-style: italic;">Flag, default=0</p>
        <p>Treat the input <i>N</i> as the number of prime numbers to return instead of the maximum value. In the above example, if we wanted the same result we would set <i>N</i>=25 and /IS_INDEX.</p>
        <h1 class="ObjMethod"><a name="GetProperty"></a>BigInteger::GetProperty</h1>
        <p>You can retrieve the properties of a BigInteger using either "dot" notation or the ::GetProperty method.</p>
        <h2 class="API">Example</h2>
        <p class="Code">bigint = -BigInteger(2)^79 + 1</p>
        <p class="Code">digits = bigint.DIGITS</p>
        <p class="Code">sign = bigint.SIGN</p>
        <p class="Code">; Or, using GetProperty...</p>
        <p class="Code">bigint.GetProperty, DIGITS=digits, SIGN=sign</p>
        <p class="Code">PRINT, digits</p>
        <p class="Code">PRINT, sign</p>
        <p>IDL prints:</p>
        <p class="Code">4294967295&#160;&#160;&#160;4294967295&#160;&#160;&#160;32767</p>
        <p class="Code">-1</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>BigInteger objects are immutable: You cannot set the DIGITS or SIGN properties.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= bigint.GetProperty( PROPERTY=<i>variable</i> )</p>
        <h2 class="API">Arguments</h2>
        <p>None</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">DIGITS</h3>
        <p>This property contains the BigInteger number as a series of unsigned 32-bit integers in base 4294967296, stored in little-endian order (largest digit at the end).</p>
        <h3 class="Keyword">SIGN</h3>
        <p>This property is an integer (–1, 0, or 1) that indicates whether the BigInteger number is negative, zero, or positive.</p>
        <h1 class="ObjMethod"><a name="Hashcode"></a>BigInteger::Hashcode</h1>
        <p>The BigInteger::Hashcode method returns a hash code based upon the BigInteger value. The hash code is constructed by calling the <a href="../Static Methods/IDL_Variable.htm#Hashcode">Hashcode</a> method on the DIGITS property, then taking the bitwise <i>not</i> operator if the BigInteger is negative.</p>
        <h2 class="API">Example</h2>
        <p class="Code">bigint = BigInteger(2)^1279 - 1</p>
        <p class="Code">HELP, bigint.Hashcode()</p>
        <p>IDL prints:</p>
        <p class="Code">&lt;Expression&gt;    ULONG     =   1097148854</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= bigint.Hashcode( )</p>
        <h2 class="API">Return Value</h2>
        <p>An integer giving the hash code based upon the BigInteger value.</p>
        <h2 class="API">Arguments</h2>
        <p>None</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h1 class="ObjMethod"><a name="IsPowerOfTwo"></a>BigInteger::IsPowerOfTwo</h1>
        <p>The BigInteger::IsPowerOfTwo method tests whether the value is a power of two and returns 1 (true) or 0 (false).</p>
        <h2 class="API">Example</h2>
        <p class="Code">bigint = BigInteger(2)^1279</p>
        <p class="Code">PRINT, bigint.IsPowerOfTwo()</p>
        <p>IDL prints:</p>
        <p class="Code">1</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= bigint.IsPowerOfTwo( )</p>
        <h2 class="API">Return Value</h2>
        <p>Returns 1 (true) or 0 (false).</p>
        <h2 class="API">Arguments</h2>
        <p>None</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h1 class="ObjMethod"><a name="IsPrime"></a>BigInteger::IsPrime</h1>
        <p>The BigInteger::IsPrime method returns 1 (true) if the number is probably prime, or 0 (false) if the number is definitely composite. The method uses three tests in succession:</p>
        <ol>
            <li value="1">Division by all prime factors up to 1999.</li>
            <li value="2">The Miller-Rabin probabilistic primality test. This is an iterative test, where random numbers are used to test the primality based upon a set of equalities. The algorithm follows the pseudocode in Donald E. Knuth, <i>The Art of Computer Programming, Vol 2: Seminumerical Algorithms</i>, 3rd ed., Addison Wesley, 1998, section 4.5.4, algorithm P.</li>
            <li value="3">The Lucas probable prime test. This algorithm follows the pseudocode in  <i>NIST Federal Information Processing Standards 186-4: Digital Signature Standard (DSS)</i>, July 2013, downloaded from http://csrc.nist.gov/publications/PubsFIPS.html, Dec 2013, section C3.3.</li>
        </ol>
        <p> If the number is less than 3996001, the first test is sufficient to guarantee that the number is prime or composite with no chance of failure. For larger numbers, if the number passes all three tests then the probability of failure is less than 2<sup>-100</sup>.</p>
        <h2 class="API">Example</h2>
        <p class="Code">bigint = BigInteger(2)^1279 - 1</p>
        <p class="Code">PRINT, bigint.IsPrime() ? 'prime' : 'composite'</p>
        <p>IDL prints:</p>
        <p class="Code">prime</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= bigint.IsPrime( ITERATIONS=value )</p>
        <h2 class="API">Return Value</h2>
        <p>Returns 1 if the number is probably prime, 0 if the number is composite.</p>
        <h2 class="API">Arguments</h2>
        <p>None</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">ITERATIONS</h3>
        <p style="font-style: italic;">Integer &gt;= 1</p>
        <p>The number of iterations to perform for the Miller-Rabin primality test. Each iteration has a 1/4 chance (in the worst case) of incorrectly identifying a composite number as being prime. The default value is based upon the bit length, and is designed to give a probability of 2<sup>-100</sup> of incorrectly identifying a composite number as prime:</p>
        <table style="mc-table-style: url('../../Resources/TableStyles/Description.css');" class="TableStyle_Description" cellspacing="0">
            <col />
            <col />
            <thead>
                <tr>
                    <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">Bit length</th>
                    <th class="TableStyle_Description_Head_0_0_RowSep_ColEnd">Iterations</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">2048+</td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">2</td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">1024–2047</td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">4</td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">512–1023</td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">7</td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">256–511</td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">16</td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">128–255</td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">34</td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">64–127</td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">44</td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">32–63</td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">49</td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">&lt;32</td>
                    <td class="TableStyle_Description_Body_1_0_RowEnd_ColEnd">64</td>
                </tr>
            </tbody>
        </table>
        <p>The number of iterations was computed from the formula in section F1.1 of  <i>NIST Federal Information Processing Standards 186-4: Digital Signature Standard (DSS)</i>, July 2013, downloaded from http://csrc.nist.gov/publications/PubsFIPS.html, Dec 2013.  </p>
        <h1 class="ObjMethod"><a name="LCM"></a>BigInteger::LCM</h1>
        <p>The BigInteger::LCM method computes the least common multiple (LCM) between this BigInteger and another integer. The least common multiple is the smallest integer that can be evenly divided (no remainder) by each number. By definition the LCM will always be greater than or equal to the larger of the two numbers.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">u = BigInteger.Factorial(90)</p>
        <p class="Code">   v = BigInteger.Factorial(60) + 34</p>
        <p class="Code">  lcm = u.LCM(v)</p>
        <p class="Code">HELP, u, v, lcm</p>
        <p>IDL prints:</p>
        <p class="Code">U&#160;&#160;&#160;            BIGINTEGER &lt;ID=1 LENGTH=459 bits&gt; = 1.4857159644817615...x10^138</p>
        <p class="Code">V&#160;&#160;&#160;            BIGINTEGER &lt;ID=2 LENGTH=273 bits&gt; = 8.3209871127413901...x10^81</p>
        <p class="Code">LCM&#160;        BIGINTEGER &lt;ID=3 LENGTH=727 bits&gt; = 3.6360657040137889...x10^218</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = bigint.LCM( <i>Value</i> )</p>
        <h2 class="API">Return Value </h2>
        <p>Returns a BigInteger containing the least common multiple of <i>bigint</i> and <i>Value</i>.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Value</h3>
        <p>Set this argument to either a normal IDL integer or a BigInteger.</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h1 class="ObjMethod"><a name="Log2"></a>BigInteger::Log2</h1>
        <p>The BigInteger::Log2 method returns the base-2 logarithm of the number, along with an optional remainder.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If the number is 0 or negative then the method throws an error.</p>
        <h2 class="API">Example</h2>
        <p class="Code">bigint = BigInteger.Factorial(10000)</p>
        <p class="Code">PRINT, bigint.Log2(REMAINDER=rem)</p>
        <p class="Code">HELP, rem</p>
        <p>IDL prints:</p>
        <p class="Code">118458</p>
        <p class="Code">REM             BIGINTEGER &lt;ID=2 LENGTH=118455 bits&gt; = 2.6859533835705141...x10^35658</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= bigint.Log2( )</p>
        <h2 class="API">Return Value</h2>
        <p>An integer giving the base-2 logarithm.</p>
        <h2 class="API">Arguments</h2>
        <p>None</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">REMAINDER</h3>
        <p style="font-style: italic;">Output variable</p>
        <p>Returns a BigInteger containing the remainder, equal to <i>bigint</i> – 2<sup style="font-style: italic;">Result</sup>.</p>
        <h1 class="ObjMethod"><a name="Log10"></a>BigInteger::Log10</h1>
        <p>The BigInteger::Log10 method returns the base-10 logarithm of the number, along with an optional remainder.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If the number is 0 or negative then the method throws an error.</p>
        <h2 class="API">Example</h2>
        <p class="Code">bigint = BigInteger.Factorial(10000)</p>
        <p class="Code">PRINT, bigint.Log10(REMAINDER=rem)</p>
        <p class="Code">HELP, rem</p>
        <p>IDL prints:</p>
        <p class="Code">35659</p>
        <p class="Code">REM             BIGINTEGER &lt;ID=2 LENGTH=118458 bits&gt; = 1.8462596809170546...x10^35659</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= bigint.Log10( )</p>
        <h2 class="API">Return Value</h2>
        <p>An integer giving the base-10 logarithm.</p>
        <h2 class="API">Arguments</h2>
        <p>None</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">REMAINDER</h3>
        <p style="font-style: italic;">Output variable</p>
        <p>Returns a BigInteger containing the remainder, equal to <i>bigint</i> – 10<sup style="font-style: italic;">Result</sup>.</p>
        <h1 class="ObjMethod"><a name="ModInverse"></a>BigInteger::ModInverse</h1>
        <p>The BigInteger::ModInverse method computes the multiplicative inverse of the BigInteger modulo the input <i>Modulus</i>. In order for the inverse to exist, the BigInteger and the <i>Modulus</i> must be co-prime (i.e. their GCD must be 1). If the ModInverse exists then <i>bigint</i>*<i>result</i> mod <i>Modulus</i> = 1. The ModInverse method uses the extended Euclidean algorithm.</p>
        <p>If the BigInteger and Modulus are not co-prime then IDL throws an error.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">u = BigInteger.Factorial(90)</p>
        <p class="Code">v = BigInteger.Factorial(60) - 1</p>
        <p class="Code">r = u.ModInverse(v)</p>
        <p class="Code">PRINT, r</p>
        <p class="Code">PRINT, "u*r mod v = ", u*r mod v</p>
        <p>IDL prints:</p>
        <p class="Code">5398464503473793715027616372607916377802131923010621870166614886971773279155082918</p>
        <p class="Code">u*r mod v = 1</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = bigint.ModInverse( <i>Modulus</i> )</p>
        <h2 class="API">Return Value </h2>
        <p>Returns a BigInteger containing the multiplicative inverse of <i>bigint</i> and <i>Modulus</i>.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Modulus</h3>
        <p>Set this argument to either a normal IDL integer or a BigInteger.</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h1 class="ObjMethod"><a name="ModPower"></a>BigInteger::ModPower</h1>
        <p>The BigInteger::ModPower method computes the modular exponentiation,</p>
        <p><i>Result</i> = bigint<sup style="font-style: italic;">Exponent</sup> mod <i>Modulus</i></p>
        <p>The method uses the right-to-left binary algorithm: the exponent is broken down into binary bits and the result is then the product of each power of two (if the bit is set) modulo the <i>Modulus</i>.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">u = BigInteger.Random(1024)</p>
        <p class="Code">v = BigInteger.Random(1024)</p>
        <p class="Code">e = BigInteger(2)^1024 - 1</p>
        <p class="Code">TIC &amp; r = u.ModPower(e, v) &amp; TOC</p>
        <p class="Code">HELP, r</p>
        <p>IDL prints:</p>
        <p class="Code">% Time elapsed: 0.074999809 seconds.</p>
        <p class="Code">R               BIGINTEGER &lt;ID=1 LENGTH=1018 bits&gt; = 2.2843081667189526...x10^306</p>
        <p>Note that computing this result using <i>u</i><sup style="font-style: italic;">e</sup> mod <i>v</i> would be impossible because the <i>u<sup>e</sup></i> would require approximately 10<sup>308</sup> digits of storage and take longer than the age of the universe.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = bigint.ModPower( <i>Exponent</i>, <i>Modulus</i> )</p>
        <h2 class="API">Return Value </h2>
        <p>Returns a BigInteger containing the modular exponentiation.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Exponent</h3>
        <p>Set this argument to either a normal IDL integer or a BigInteger.</p>
        <h3 class="Argument">Modulus</h3>
        <p>Set this argument to either a normal IDL integer or a BigInteger.</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h1 class="ObjMethod"><a name="NextPrime"></a>BigInteger::NextPrime</h1>
        <p>The BigInteger::NextPrime method computes the next prime number that follows this BigInteger.</p>
        <p>The method uses an algorithm based upon the <i>Sieve of Erastosthenes</i>. Several thousand numbers are generated in sequence following the BigInteger value. The algorithm removes any numbers that are divisible by primes up to 997. The algorithm then tests the surviving numbers for primality and returns the first match.</p>
        <p>The algorithm's speed is highly variable because it depends upon the gap between successive primes. See below for an example. </p>
        <h2 class="API">Example</h2>
        <p>From Thomas R. Nicely's website (http://www.trnicely.net), the first known gap of 10000 is found after the prime number 43775*547#/1866 - 1402. Here, the "#" symbol indicates the <a href="#Primorial" class="selected">Primorial</a> function. We can compute this gap as well as the next gap, and the time needed for the computation:</p>
        <p class="Code">b = 43775*BigInteger.Primorial(547)/1866 - 1402</p>
        <p class="Code">TIC &amp; c = b.NextPrime() &amp; TOC</p>
        <p class="Code">TIC &amp; d = c.NextPrime() &amp; TOC</p>
        <p class="Code">PRINT, 'Gap between b and c is ', c - b</p>
        <p class="Code">PRINT, 'Gap between c and d is ', d - c</p>
        <p>IDL prints:</p>
        <p class="Code">% Time elapsed: 13.886000 seconds.</p>
        <p class="Code">% Time elapsed: 0.32699990 seconds.</p>
        <p class="Code">Gap between b and c is 10000</p>
        <p class="Code">Gap between c and d is 84</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = bigint.NextPrime(  )</p>
        <h2 class="API">Return Value </h2>
        <p>Returns a BigInteger containing the next prime number.</p>
        <h2 class="API">Arguments</h2>
        <p>None</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h1 class="ObjMethod"><a name="Prime"></a>BigInteger::Prime</h1>
        <p>The BigInteger::Prime static constructor method returns a new BigInteger containing a random prime number with a given bit length.</p>
        <h2 class="API">Example</h2>
        <p class="Code">bigint = BigInteger.Prime(256)</p>
        <p class="Code">PRINT, bigint</p>
        <p>IDL prints:</p>
        <p class="Code">103231891082001480830106615945373073145045889883067503900939711192099772102403</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= BigInteger.Prime( <i>BitLength</i>, SEED=<i>value</i> )</p>
        <h2 class="API">Return Value</h2>
        <p>A new BigInteger.</p>
        <h2 class="API">Arguments</h2>
        <p>BitLength</p>
        <p>An integer giving the number of bits in the prime number.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">SEED</h3>
        <p style="font-style: italic;">Integer or array</p>
        <p>This seed will be used as the starting value for the <a href="../R/RANDOMU.htm">RANDOMU</a> function.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Normally, you should never need to use the SEED keyword as BigInteger will automatically pick a new seed value each time it is called. You should only use the SEED keyword if you need to re-generate the same prime number for a given bit length.</p>
        <h1 class="ObjMethod"><a name="Primorial"></a>BigInteger::Primorial</h1>
        <p>The BigInteger::Primorial static constructor method returns a new BigInteger containing the primorial of <i>N</i>.</p>
        <p>The primorial (or "prime factorial") is defined as the product of all prime numbers less than or equal to <i>N</i> (<i>N</i> may be a prime number or a composite number).</p>
        <h2 class="API">Example</h2>
        <p class="Code">bigint = BigInteger.Primorial(100, COUNT=c)</p>
        <p class="Code">PRINT, 'product of first ', c, ' primes is ', bigint</p>
        <p>IDL prints:</p>
        <p class="Code">product of first           25 primes is 2305567963945518424753102147331756070</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= BigInteger.Primorial( <i>N</i>, COUNT=<i>variable</i>, /IS_INDEX )</p>
        <h2 class="API">Return Value</h2>
        <p>A new BigInteger.</p>
        <h2 class="API">Arguments</h2>
        <p>N</p>
        <p>An integer giving the maximum value to use when computing the primorial. All prime numbers less than or equal to <i>N</i> will be included in the product (<i>N</i> itself does not need to be prime).</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">COUNT</h3>
        <p style="font-style: italic;">Output variable</p>
        <p>Returns the number of prime numbers that were multiplied together to produce the result. If IS_INDEX is set then COUNT will just be equal to <i>N</i>.</p>
        <h3 class="Keyword">IS_INDEX</h3>
        <p style="font-style: italic;">Flag, default=0</p>
        <p>Treat the input <i>N</i> as the number of prime numbers to include in the primorial, instead of the maximum value. In the above example, if we wanted the same result, we would set <i>N</i>=25 and /IS_INDEX.</p>
        <h1 class="ObjMethod"><a name="Random"></a>BigInteger::Random</h1>
        <p>The BigInteger::Random static constructor method returns a new BigInteger containing a random number between 0 and the given bit length. The <a href="../R/RANDOMU.htm">RANDOMU</a> function is used to construct the random digits.</p>
        <h2 class="API">Example</h2>
        <p class="Code">bigint = BigInteger.Random(2048)</p>
        <p class="Code">HELP, bigint</p>
        <p>IDL prints:</p>
        <p class="Code">BIGINT          BIGINTEGER &lt;ID=1 LENGTH=2047 bits&gt; = 1.0066318959964815...x10^616</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= BigInteger.Random( <i>BitLength</i>, /EXACT, SEED=<i>value</i> )</p>
        <h2 class="API">Return Value</h2>
        <p>A new BigInteger.</p>
        <h2 class="API">Arguments</h2>
        <p>BitLength</p>
        <p>An integer giving the maximum number of bits. The result could have less bits, unless the EXACT keyword is set.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">EXACT</h3>
        <p style="font-style: italic;">Flag, default=0</p>
        <p>Return a BigInteger with exactly <i>BitLength</i> bits. In other words, the number will be between 2<sup>BitLength</sup> and 2<sup>BitLength+1</sup> – 1. The default is to return a random number between 0 and 2<sup>BitLength+1</sup> – 1.</p>
        <h3 class="Keyword">SEED</h3>
        <p style="font-style: italic;">Integer or array</p>
        <p>This seed will be used as the starting value for the <a href="../R/RANDOMU.htm">RANDOMU</a> function.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Normally, you should never need to use the SEED keyword as BigInteger will automatically pick a new seed value each time it is called. You should only use the SEED keyword if you need to re-generate the same random number for a given bit length.</p>
        <h1 class="ObjMethod"><a name="Signum"></a>BigInteger::Signum</h1>
        <p>The BigInteger::Signum method returns –1 if the number is negative, 0 if the number is zero, and 1 if the number is positive.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = bigint.Signum(  )</p>
        <h2 class="API">Return Value </h2>
        <p>Returns –1, 0, or +1.</p>
        <h2 class="API">Arguments</h2>
        <p>None</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h1 class="ObjMethod"><a name="Sqrt"></a>BigInteger::Sqrt</h1>
        <p>The BigInteger::Sqrt method uses Newton's iterative method to compute the square root of the number along with an optional remainder. If the number is negative, IDL throws an error.</p>
        <h2 class="API">Example</h2>
        <p class="Code">b = BigInteger.Random(2048)</p>
        <p class="Code">c = b^2 + 1</p>
        <p class="Code">b1 = c.Sqrt(REMAINDER=r)</p>
        <p class="Code">PRINT, "sqrt(c) equals b:", b eq b1 ? "true" : "false"</p>
        <p class="Code">PRINT, "remainder is ", r</p>
        <p>IDL prints:</p>
        <p class="Code">sqrt(c) equals b:   true</p>
        <p class="Code">remainder is 1</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = bigint.Sqrt( REMAINDER=<i>variable</i> )</p>
        <h2 class="API">Return Value </h2>
        <p>Returns a BigInteger containing the "integer" part of the square root.</p>
        <h2 class="API">Arguments</h2>
        <p>None</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">REMAINDER</h3>
        <p style="font-style: italic;">Output variable</p>
        <p>Returns a BigInteger containing the remainder, equal to <i>bigint</i> – <i>result</i><sup>2</sup>.</p>
        <h1 class="ObjMethod"><a name="ToDouble"></a>BigInteger::ToDouble</h1>
        <p>The BigInteger::ToDouble method converts the number to a double-precision value.</p>
        <h2 class="API">Examples</h2>
        <p>Find the largest factorial that will still fit in a double:</p>
        <p class="Code">bigint = BigInteger.Factorial(170)</p>
        <p class="Code">HELP, bigint.ToDouble()</p>
        <p>IDL prints:</p>
        <p class="Code">&lt;Expression&gt;    DOUBLE    =   7.2574156e+306</p>
        <p>Now find a huge factorial and use the optional EXPONENT keyword:</p>
        <p class="Code">bigint = BigInteger.Factorial(100000)</p>
        <p class="Code">HELP, bigint.ToDouble(EXPONENT=exponent), exponent</p>
        <p>IDL prints:</p>
        <p class="Code">&lt;Expression&gt;    DOUBLE    =        2.8242294</p>
        <p class="Code">EXPONENT        LONG      =       456573</p>
        <p>The value of 100000! is approximately 2.82x10<sup>456573</sup>.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = bigint.ToDouble( EXPONENT=<i>variable</i> )</p>
        <h2 class="API">Return Value </h2>
        <p>Returns a double-precision value.</p>
        <h2 class="API">Arguments</h2>
        <p>None</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">EXPONENT</h3>
        <p style="font-style: italic;">Output variable</p>
        <p>If set, then the ToDouble method will not include the exponent in the <i>Result</i>, but will instead return the exponent in this variable. This allows you to convert BigIntegers that are larger than 10<sup>308</sup> into useable pieces.</p>
        <p>If you do not specify EXPONENT and the BigInteger is too large, then ToDouble returns <code>Infinity</code>.</p>
        <h1 class="ObjMethod"><a name="ToInteger"></a>BigInteger::ToInteger</h1>
        <p>The BigInteger::ToInteger method converts the BigInteger to a signed 64-bit integer value. If the value is too large then IDL issues a warning and returns 0.</p>
        <h2 class="API">Examples</h2>
        <p>The largest prime that will still fit in a 64-bit integer:</p>
        <p class="Code">bigint = BigInteger(2)^63</p>
        <p class="Code">while (~bigint.IsPrime()) do bigint = bigint - 1</p>
        <p class="Code">PRINT, bigint.ToInteger()</p>
        <p>IDL prints:</p>
        <p class="Code">9223372036854775783</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = bigint.ToInteger( )</p>
        <h2 class="API">Return Value </h2>
        <p>Returns a 64-bit signed integer value.</p>
        <h2 class="API">Arguments</h2>
        <p>None</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h1 class="ObjMethod"><a name="ToString"></a>BigInteger::ToString</h1>
        <p>The BigInteger::ToString method converts the BigInteger to its string representation. By default the string is in base 10 but you can use the RADIX keyword to convert to a different base.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">bigint = BigInteger('303117847695258070278031236')</p>
        <p class="Code">PRINT, bigint.ToString()</p>
        <p class="Code">PRINT, bigint.ToString(RADIX=2)</p>
        <p class="Code">PRINT, bigint.ToString(RADIX=16, /UPPERCASE)</p>
        <p class="Code">PRINT, bigint.ToString(RADIX=36, /UPPERCASE)</p>
        <p>IDL prints:</p>
        <p class="Code">303117847695258070278031236</p>
        <p class="Code">1111101010111011101100110111001100010011100...</p>
        <p class="Code">FABBB37313829F24214784</p>
        <p class="Code">12345IDLISFUN67890</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = bigint.ToString( RADIX=<i>value</i>, /UPPERCASE )</p>
        <h2 class="API">Return Value </h2>
        <p>Returns the string representation of the number.</p>
        <h2 class="API">Arguments</h2>
        <p>None</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">RADIX</h3>
        <p style="font-style: italic;">Integer, 2–36, default = 10</p>
        <p>Return the result in a different base.</p>
        <h3 class="Keyword">UPPERCASE</h3>
        <p style="font-style: italic;">Flag, default=0</p>
        <p>Set this keyword to return the string using uppercase letters instead of lowercase. This keyword only has an effect if RADIX is greater than 10.</p>
        <h1>Additional Information</h1>
        <h3><a name="Operator"></a>Operators</h3>
        <table style="margin-left: 0;margin-right: auto;mc-table-style: url('../../Resources/TableStyles/Description.css');" class="TableStyle_Description" cellspacing="0">
            <col class="Column-Column1" />
            <col class="Column-Column1" />
            <col class="Column-Column1" />
            <col class="Column-Column1" />
            <thead>
                <tr class="Head-Header1">
                    <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">Name</th>
                    <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">Operators</th>
                    <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">Operands</th>
                    <th class="TableStyle_Description_Head_0_0_RowSep_ColEnd">Result</th>
                </tr>
            </thead>
            <tbody>
                <tr class="Body-Body1">
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep"><a href="../../Creating IDL Programs/Components of the IDL Language/Mathematical_Operators.htm">Math</a>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">+ – * / ^ mod</td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">BigIntegers or numbers</td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">A new BigInteger</td>
                </tr>
                <tr class="Body-Body1">
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>Increment,<br />Decrement</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>++ ––</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">BigInteger</td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p>The BigInteger is incremented or decremented</p>
                    </td>
                </tr>
                <tr class="Body-Body2">
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep"><a href="../../Creating IDL Programs/Components of the IDL Language/Relational_Operators.htm">Comparisons</a>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">EQ, NE, GT, GE, LT, LE</td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">BigIntegers or numbers</td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">Boolean 0 or 1</td>
                </tr>
                <tr class="Body-Body1">
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep"><a href="../../Creating IDL Programs/Components of the IDL Language/Bitwise_Operators.htm">Bitwise</a>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">AND, NOT, OR, XOR</td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">BigIntegers or numbers</td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">A new BigInteger</td>
                </tr>
                <tr class="Body-Body2">
                    <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep"><a href="../../Creating IDL Programs/Components of the IDL Language/Minimum_and_Maximum_Oper.htm">Min/max</a>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep">&gt; &lt;</td>
                    <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep">BigIntegers or numbers</td>
                    <td class="TableStyle_Description_Body_0_0_RowEnd_ColEnd">A new BigInteger</td>
                </tr>
            </tbody>
        </table>
        <h3><a name="Logical"></a>Logical Truth and Negation</h3>
        <p>A BigInteger is considered "true" if the value is not zero, otherwise it is false. The "~" negation operator will return a boolean 0 if the BigInteger was nonzero, or 1 if the BigInteger was zero.</p>
        <h3><a name="Help"></a>Help and Print</h3>
        <p>The <a href="../P/PRINT.htm">PRINT procedure</a> will output the BigInteger value in base 10. To output to a different base you can use the <a href="../Static Methods/IDL_Variable.htm#ToString">ToString</a> method.</p>
        <p>The <a href="../H/HELP.htm">HELP procedure</a> will output the BigInteger's heap ID and a shortened version of the BigInteger value.</p>
        <h3><a name="ISA"></a>ISA and TYPENAME</h3>
        <p>You can use the <a href="../I/ISA.htm">ISA</a> function to determine if a variable is a BigInteger:</p>
        <p class="Code">if ISA(bigint, "BigInteger") then ...</p>
        <p>You can use the <a href="../T/TYPENAME.htm">TYPENAME</a> function or the <a href="../Static Methods/Variable Attributes.htm#Variable_Attributes">TYPENAME</a> attribute to retrieve the class name:</p>
        <p class="Code">if (TYPENAME(bigint) eq "BIGINTEGER") then ...</p>
        <p class="Code">if (bigint.TYPENAME eq "BIGINTEGER") then ...</p>
        <h3><a name="Copying"></a>Copying BigIntegers</h3>
        <p>If you assign a BigInteger variable to a new variable, you are simply creating a new reference to the same object. Since BigIntegers are immutable (the value cannot be changed) this is usually not a problem. If for some reason you must have a new object, you can use the DIGITS and SIGN properties to create a new BigInteger. For example:</p>
        <p class="Code">b = BigInteger(2)^1279 - 1</p>
        <p class="Code">c = b</p>
        <p class="Code">d = BigInteger(b.digits, SIGN=b.sign)</p>
        <p class="Code">HELP, b, c, d</p>
        <p>IDL prints:</p>
        <p class="Code">B               BIGINTEGER &lt;ID=7 LENGTH=1279 bits&gt; = 1.0407932194664400...x10^385</p>
        <p class="Code">C               BIGINTEGER &lt;ID=7 LENGTH=1279 bits&gt; = 1.0407932194664400...x10^385</p>
        <p class="Code">D               BIGINTEGER &lt;ID=9 LENGTH=1279 bits&gt; = 1.0407932194664400...x10^385</p>
        <p>Notice that both <code>b</code> and <code>c</code> have the same heap variable ID, while <code>d</code> has a new heap ID.</p>
        <h2 class="API">Version History</h2>
        <table style="mc-table-style: url('../../Resources/TableStyles/VersionTable.css');margin-left: 0;margin-right: auto;caption-side: top;" cellspacing="0" class="TableStyle_VersionTable">
            <col />
            <col />
            <tbody>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">
                        <p>8.4</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">
                        <p>Introduced</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <h2 class="API">See Also</h2>
        <p><a href="../../Creating IDL Programs/Components of the IDL Language/IDL_Data_Types.htm">IDL Data Types</a>, <a href="../../Creating IDL Programs/Components of the IDL Language/Mathematical_Operators.htm">Mathematical Operators</a>, <a href="../../Creating IDL Programs/Components of the IDL Language/Operator_Precedence.htm">Operator Precedence</a></p>
        <p class="Hidden">RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM RANDOM </p>
        <div class="mp_footer">© <span class="DocumentTitleCopyrightYear">2015</span>&#160;<span class="DocumentTitleCopyrightCompanyName">Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation</span>. All Rights Reserved. This information is not subject to the controls of the International Traffic in Arms Regulations (ITAR) or the Export Administration Regulations (EAR). However, this information may be restricted from transfer to various embargoed countries under U.S. laws and regulations.</div>
    </body>
</html>