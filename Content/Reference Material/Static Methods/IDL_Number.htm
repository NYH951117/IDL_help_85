<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-US" xml:lang="en-US" data-mc-search-type="Stem" data-mc-help-system-file-name="idl.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>IDL_Number</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/Doc_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <h1 class="Routine"><a name="kanchor5925"></a><a name="IDL_Number"></a>IDL_Number</h1>
        <p>The IDL_Number class contains static methods that are available for all IDL numbers. In addition, because IDL_Number is a subclass of IDL_Variable, all of the <a href="IDL_Variable.htm">IDL_Variable</a> methods are also available.</p>
        <h2 class="API">Superclasses</h2>
        <p><a href="IDL_Variable.htm">IDL_Variable</a>
        </p>
        <h3>IDL_Number</h3>
        <ul>
            <li value="1"><a href="#Ceil" class="selected">Ceil</a> - Compute the ceiling.</li>
            <li value="2"><a href="#Floor" class="selected">Floor</a> - Compute the floor.</li>
            <li value="3"><a href="#Imaginary" class="selected">Imaginary</a> - Return the imaginary value.</li>
            <li value="4"><a href="#Mean" class="selected">Mean</a> - Compute the mean.</li>
            <li value="5"><a href="#Median" class="selected">Median</a> - Compute the median.</li>
            <li value="6"><a href="#Max" class="selected">Max</a> - Return the value of the largest element.</li>
            <li value="7"><a href="#Min" class="selected">Min</a> - Return the value of the smallest element.</li>
            <li value="8"><a href="#Product" class="selected">Product</a> - Compute the product.</li>
            <li value="9"><a href="#Real" class="selected">Real</a> - Return the real value.</li>
            <li value="10"><a href="#Round" class="selected">Round</a> - Round the value.</li>
            <li value="11"><a href="#Signum" class="selected">Signum</a> - Compute the signum.</li>
            <li value="12"><a href="#Total" class="selected">Total</a> - Compute the total.</li>
        </ul>
        <h3>Additional Information</h3>
        <h4>Thread Pool Keywords</h4>
        <p> Many of the methods for IDL_Number are written to make use of IDL's thread pool, which can increase execution speed on systems with multiple CPUs. The values stored in the !CPU system variable control whether IDL uses the thread pool for a given computation. In addition, you can use the thread pool keywords TPOOL_MAX_ELTS, TPOOL_MIN_ELTS, and TPOOL_NOTHREAD to override the defaults established by !CPU for a single invocation of this routine. See <a href="../../Creating IDL Programs/Appendices/tpoolkeyw.htm#tpoolkeyw_2501860834_317209">Thread Pool Keywords</a> for more information.</p>
        <h1 class="ObjMethod"><a name="kanchor5926"></a><a name="Ceil"></a>IDL_Number::Ceil</h1>
        <p>The IDL_Number::Ceil method returns the closest integer greater than or equal to the variable.</p>
        <h2 class="API">Examples</h2>
        <p>Print the ceil of a number:</p>
        <p class="Code">num = 5.1</p>
        <p class="Code">PRINT, num.Ceil(&#160;)</p>
        <p>IDL prints:</p>
        <p class="Code">6</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = var.Ceil(  )</p>
        <h2 class="API">Return Value</h2>
        <p>If the variable is of type integer, its <i>Result</i> has the same value and type. In all other cases, <i>Result</i> is a 32-bit long integer with the same structure as the variable.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">L64</h3>
        <p>If set, the result type is 64-bit integer regardless of the variable's type. This is useful for situations in which a floating point number contains a value too large for a 32-bit integer.</p>
        <h1 class="ObjMethod"><a name="kanchor5927"></a><a name="Floor"></a>IDL_Number::Floor</h1>
        <p>The IDL_Number::Floor method returns the closest integer less than or equal to the variable.</p>
        <h2 class="API">Examples</h2>
        <p>Print the floor of a number:</p>
        <p class="Code">num = 5.9</p>
        <p class="Code">PRINT, num.Floor(&#160;)</p>
        <p>IDL prints:</p>
        <p class="Code">5</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = var.Floor(  )</p>
        <h2 class="API">Return Value</h2>
        <p>If the variable is of type integer, its <i>Result</i> has the same value and type. In all other cases, <i>Result</i> is a 32-bit long integer with the same structure as the variable.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">L64</h3>
        <p>If set, the result type is 64-bit integer regardless of the variable's type. This is useful for situations in which a floating point number contains a value too largefor a 32-bit integer.</p>
        <h1 class="ObjMethod"><a name="kanchor5928"></a><a name="Imaginary"></a>IDL_Number::Imaginary</h1>
        <p>The IDL_Number::Imaginary method returns the imaginary part of a complex-valued variable.</p>
        <h2 class="API">Examples</h2>
        <p>Print the imaginary parts of a value:</p>
        <p class="Code">num = COMPLEX([1, 2, 3], [4, 5, 6])</p>
        <p class="Code">PRINT, num.Imaginary(&#160;)</p>
        <p>IDL prints:</p>
        <p class="Code">4.00000 5.00000 6.00000</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = var.Imaginary(  )</p>
        <h2 class="API">Return Value</h2>
        <p>If the variable is double-precision, the result will be double-precision, otherwise the result will be single-precision floating-point.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5929"></a><a name="Mean"></a>IDL_Number::Mean</h1>
        <p>The IDL_Number::Mean method computes the mean of the numeric vector.</p>
        <h2 class="API">Examples</h2>
        <p>Print the mean value of a 15-element vector:</p>
        <p class="Code">num = [65, 63, 67, 64, 68, 62, 70, 66, 68, 67, 69, 71, 66, 65, 70]</p>
        <p class="Code">PRINT, num.Mean(&#160;)</p>
        <p>IDL prints:</p>
        <p class="Code">66.7333</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = var.Mean( [DIMENSION=<i>value</i>] [, /DOUBLE] [, /NAN] )</p>
        <h2 class="API">Return Value</h2>
        <p>The average value of the variable's elements.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">DIMENSION</h3>
        <p>Set this keyword to a scalar indicating the dimension across which to calculate the mean. If this keyword is not present or is zero, the mean is computed across all dimensions of the variable. If this keyword is present, the mean is only calculated across a single dimension. In this case the result is an array with one less dimension than the variable.</p>
        <h3 class="Keyword">DOUBLE</h3>
        <p>If this keyword is set, computations are done in double precision arithmetic.</p>
        <h3 class="Keyword">NAN</h3>
        <p>Set this keyword to cause the routine to check for occurrences of the IEEE floating-point values NaN or Infinity in the variable. Elements with the value NaN or Infinity are treated as missing data.</p>
        <h1 class="ObjMethod"><a name="kanchor5930"></a><a name="Median"></a>IDL_Number::Median</h1>
        <p>The IDL_Number::Median method returns the median value of a numeric vector.</p>
        <h2 class="API">Examples</h2>
        <p>Print the median value of a number:</p>
        <p class="Code">num = -24601</p>
        <p class="Code">PRINT, num.Median(&#160;)</p>
        <p>IDL prints:</p>
        <p class="Code">24601</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = var.Median( [<i>Width</i>] [, DIMENSION=<i>value</i>] [, /DOUBLE] [, /EVEN]  )</p>
        <h2 class="API">Return Value</h2>
        <p>The median value of the variable if one parameter is present, or applies a one- or two-dimensional median filter of the specified width to the variable and returns the result.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Width</h3>
        <p>The size of the one- or two-dimensional neighborhood to be used for the median filter. The neighborhood has the same number of dimensions as the variable.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">DIMENSION</h3>
        <p>Set this keyword to the dimension over which to find the median values of the variable. If this keyword is not present or is zero, the median is found over the entire variable and is returned as a scalar value. If this keyword is present and nonzero, the result is a “slice” of the variable that contains the median value elements, and the return value will be an array of one dimension less than the variable.</p>
        <p>For example, if the dimensions of the variable are N1, N2, N3, and DIMENSION = 2, the dimensions of the result are (N1, N3), and element (i, j) of the result contains the median value of the variable[i, *, j]. IDL ignores this keyword if the Width argument is present.</p>
        <h3 class="Keyword">DOUBLE</h3>
        <p>Set this keyword to force the computation to be done using double-precision arithmetic and to return a double-precision result.</p>
        <h3 class="Keyword">EVEN</h3>
        <p>If the  variable contains an even number of points (i.e. there is no middle number), MEDIAN returns the average of the two middle numbers. The returned value may not be an element of the variable.</p>
        <p>If the variable contains an odd number of points, MEDIAN returns the median value. The returned value will always be an element of the variable—even if the EVEN keyword is set—since an odd number of points will always have a single middle value.</p>
        <h1 class="ObjMethod"><a name="kanchor5931"></a><a name="Max"></a>IDL_Number::Max</h1>
        <p>The IDL_Number::Max method returns the value of the largest element of the variable.</p>
        <h2 class="API">Examples</h2>
        <p>Print the largest element of a given array:</p>
        <p class="Code">num = FINDGEN(100)</p>
        <p class="Code">PRINT, num.Max(&#160;)</p>
        <p>IDL prints:</p>
        <p class="Code">99.0000</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = var.Max( [Max_Subscript] [, /ABSOLUTE] [, DIMENSION=<i>value</i>] [, MIN=<i>variable</i>] [, /NAN] [, SUBSCRIPT_MIN=<i>variable</i>] )</p>
        <h2 class="API">Return Value</h2>
        <p>The largest array element value. The type of the result is the same as the type of the variable.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Max_Subscript</h3>
        <p>A named variable that, if supplied, is converted to a long integer containing the one-dimensional subscript of the maximum element. Otherwise, the system variable !C is set to the one-dimensional subscript of the maximum element.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">ABSOLUTE</h3>
        <p>If this keyword is set, IDL used the absolute value of each element when determining the maximum values. This keyword has no effect for arrays of type byte or unsigned integer.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If ABSOLUTE is set then the sign of each value is ignored when searching for the maximum. However, the return value retains the negative sign if the value was indeed negative.</p>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>For complex input, by default MAX only compares the real component of each value. Use the ABSOLUTE keyword to force MAX to compare the absolute value of each value, and to return the complex value corresponding to the maximum absolute value.</p>
        <h3 class="Keyword">DIMENSION</h3>
        <p>Set this keyword to the dimension over which to find the maximum values of an array. If this keyword is not present or is zero, the maximum is found over the entire array and is returned as a scalar value. If this keyword is present and nonzero, the result is the “slice” of the input array that contains the maximum value element, and the return values for Result, Max_Subscript, MIN, and SUBSCRIPT_MIN will all be arrays of one dimension less than the input array. That is, if the dimensions of Array are N1, N2, N3, and DIMENSION=2, the dimensions of the result are (N1, N3), and element (i,j) of the result contains the maximum value of Array[i, *, j].</p>
        <p>For example:</p>
        <p class="Code">arr = FINDGEN(2,3,2)</p>
        <p class="Code">PRINT, arr</p>
        <p>IDL prints:</p>
        <p class="Code">0.00000     1.00000</p>
        <p class="Code">2.00000     3.00000</p>
        <p class="Code">4.00000     5.00000</p>
        <p>&#160;</p>
        <p class="Code">6.00000     7.00000</p>
        <p class="Code">8.00000     9.00000</p>
        <p class="Code">10.0000     11.0000</p>
        <p>&#160;</p>
        <p class="Code">PRINT, MAX(arr, DIMENSION=2)</p>
        <p>IDL prints:</p>
        <p class="Code">4.00000     5.00000</p>
        <p class="Code">10.0000     11.0000</p>
        <p>&#160;</p>
        <p class="Code">PRINT, MAX(arr, DIMENSION=1)</p>
        <p>IDL prints:</p>
        <p class="Code">1.00000     3.00000     5.00000</p>
        <p class="Code">7.00000     9.00000     11.0000</p>
        <h3 class="Keyword">MIN</h3>
        <p>A named variable to receive the value of the minimum array element. If you need to find both the minimum and maximum array values, use this keyword to avoid scanning the array twice with separate calls to MAX and MIN.</p>
        <h3 class="Keyword">NAN</h3>
        <p>Set this keyword to cause the routine to check for occurrences of the IEEE floating-point values NaN or Infinity in the input data. Elements with the value NaN or Infinity are treated as missing data.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If the MAX function is run on an array containing NaN values and the NAN keyword is not set, an invalid result will occur.</p>
        <h3 class="Keyword">SUBSCRIPT_MIN</h3>
        <p>Set this keyword equal to a named variable that will contain the one-dimensional subscript of the minimum element, the value of which is available via the MIN keyword.</p>
        <h1 class="ObjMethod"><a name="kanchor5932"></a><a name="Min"></a>IDL_Number::Min</h1>
        <p>The IDL_Number::Min method returns the value of the smallest element of Array. The type of the result is the same as that of the variable.</p>
        <h2 class="API">Examples</h2>
        <p>Print the absolute value of a number:</p>
        <p class="Code">num = FINDGEN(100)</p>
        <p class="Code">PRINT, num.Min(&#160;)</p>
        <p>IDL prints:</p>
        <p class="Code">0.000000</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = var.Min( [Min_Subscript] [, /ABSOLUTE] [, DIMENSION=<i>value</i>] [, MAX=<i>variable</i>] [, /NAN] [, SUBSCRIPT_MAX=<i>variable</i>] )</p>
        <h2 class="API">Return Value</h2>
        <p>The smallest array element value.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Min_Subscript</h3>
        <p>A named variable that, if supplied, is converted to a long integer containing the one-dimensional subscript of the minimum element. Otherwise, the system variable !C is set to the one-dimensional subscript of the minimum element.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">ABSOLUTE</h3>
        <p>If this keyword is set, IDL uses the absolute value of each element when determining the minimum values. This keyword has no effect for arrays of type byte or unsigned integer.</p>
        <p>Note: If ABSOLUTE is set, IDL ignores the sign of each value when searching for the minimum. However, the return value retains the negative sign if the value was indeed negative.</p>
        <p>Tip: For complex input, MIN by default only compares the real component of each value. Use the ABSOLUTE keyword to force MIN to compare the absolute value of each value, and to return the complex value corresponding to the minimum absolute value.</p>
        <h3 class="Keyword">DIMENSION</h3>
        <p>Set this keyword to the dimension over which to find the minimum values of an array. If this keyword is not present or is zero, the minimum is found over the entire array and is returned as a scalar value. If this keyword is present and nonzero, the result is the “slice” of the input array that contains the minimum value element, and the return values for Result, Min_Subscript, MAX, and SUBSCRIPT_MAX will all be arrays of one dimension less than the input array. That is, if the dimensions of Array are N1, N2, N3, and DIMENSION=2, the dimensions of the result are (N1, N3), and element (i,j) of the result contains the minimum value of Array[i, *, j].</p>
        <p>For example:</p>
        <p class="Code">arr = FINDGEN(2,3,2)</p>
        <p class="Code">PRINT, arr</p>
        <p>IDL prints:</p>
        <p class="Code">0.00000     1.00000</p>
        <p class="Code">2.00000     3.00000</p>
        <p class="Code">4.00000     5.00000</p>
        <p>&#160;</p>
        <p class="Code">6.00000     7.00000</p>
        <p class="Code">8.00000     9.00000</p>
        <p class="Code">10.0000     11.0000</p>
        <p>&#160;</p>
        <p class="Code">PRINT, MIN(arr, DIMENSION=2)</p>
        <p>IDL prints:</p>
        <p class="Code">0.00000     1.00000</p>
        <p class="Code">6.00000     7.00000</p>
        <p>&#160;</p>
        <p class="Code">PRINT, MIN(arr, DIMENSION=1)</p>
        <p>IDL prints:</p>
        <p class="Code">0.00000     2.00000     4.00000</p>
        <p class="Code">6.00000     8.00000     10.0000</p>
        <h3 class="Keyword">MAX</h3>
        <p>The name of a variable to receive the value of the maximum array element. If you need to find both the minimum and maximum array values, use this keyword to avoid scanning the array twice with separate calls to MAX and MIN.</p>
        <h3 class="Keyword">NAN</h3>
        <p>Set this keyword to cause the routine to check for occurrences of the IEEE floating-point values NaN or Infinity in the input data. Elements with the value NaN or Infinity are treated as missing data.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If the MIN function is run on an array containing NaN values and the NAN keyword is not set, an invalid result will occur.</p>
        <h3 class="Keyword">SUBSCRIPT_MAX</h3>
        <p>Set this keyword to a named variable that will contain the one-dimensional subscript of the maximum element, the value of which is available via the MAX keyword.</p>
        <h1 class="ObjMethod"><a name="kanchor5933"></a><a name="Product"></a>IDL_Number::Product</h1>
        <p>The IDL_Number::Product method returns the product of the elements within the variable.</p>
        <h2 class="API">Examples</h2>
        <p>Print the product of a numeric array:</p>
        <p class="Code">num = [20, 10, 5, 5, 3]</p>
        <p class="Code">PRINT, num.Product(&#160;)</p>
        <p>IDL prints:</p>
        <p class="Code">15000.000</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = var.Product(  )</p>
        <h2 class="API">Return Value</h2>
        <p>The product of the elements within the variable.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">CUMULATIVE</h3>
        <p>If this keyword is set, the result is an array of the same size as the variable, with each element, <i>i</i>, containing the product of the variable elements 0 to <i>i</i>. This keyword also works with the Dimension parameter, in which case the cumulative product is performed over the given dimension. Note that if the variable has only a single element, then a scalar is returned.</p>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>If the variable is a temporary variable or an expression, and the result type matches the variable's type (for example by using the PRESERVE_TYPE keyword), then PRODUCT will perform the cumulative product in place and no additional memory will be used.</p>
        <h3 class="Keyword">INTEGER</h3>
        <p>Set this keyword to perform the PRODUCT using integer arithmetic and to return an integer result. If the variable is of type ULONG64, then unsigned 64-bit integers are used for the computation and the Result is of type ULONG64. Otherwise, IDL uses signed 64-bit integers and the Result is of type LONG64. If the variable is complex and INTEGER is set, then only the real part of each value is used for the computation.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If the variable has a large number of values or the values themselves are large, then the PRODUCT with the INTEGER keyword may easily overflow the largest 64-bit integer and return an incorrect result. In this case you may want to avoid using the INTEGER keyword.</p>
        <h3 class="Keyword">NAN</h3>
        <p>Set this keyword to cause the routine to check for occurrences of the IEEE floating-point values NaN or Infinity in the data. Elements with the value NaN or Infinity are treated as missing data with the value 1.</p>
        <h3 class="Keyword">PRESERVE_TYPE</h3>
        <p>Set this keyword to perform the PRODUCT using the variable's type, and to return a result of the same type. The INTEGER keyword is ignored if PRESERVE_TYPE is set.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>For byte or integer data the PRODUCT with PRESERVE_TYPE may easily overflow the largest value for that type. In these cases you may want to use the INTEGER keyword instead.</p>
        <h1 class="ObjMethod"><a name="kanchor5934"></a><a name="Real"></a>IDL_Number::Real</h1>
        <p>The IDL_Number::Real method returns the real part of the complex-valued number.</p>
        <h2 class="API">Examples</h2>
        <p>Print the real parts of a value:</p>
        <p class="Code">num = COMPLEX([1, 2, 3], [4, 5, 6])</p>
        <p class="Code">PRINT, num.Real(&#160;)</p>
        <p>IDL prints:</p>
        <p class="Code">1.00000   2.00000   3.00000</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = var.Real(  )</p>
        <h2 class="API">Return Value</h2>
        <p>If the variable is double-precision, the result will be double-precision, otherwise the result will be single-precision floating-point.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5935"></a><a name="Round"></a>IDL_Number::Round</h1>
        <p>The IDL_Number::Round method rounds the number to its closest integer.</p>
        <h2 class="API">Examples</h2>
        <p>Print the rounded value of a number:</p>
        <p class="Code">num = [5.1, 5.9]</p>
        <p class="Code">PRINT, num.Round(&#160;)</p>
        <p>IDL prints:</p>
        <p class="Code">5      6</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = var.Round(  )</p>
        <h2 class="API">Return Value</h2>
        <p>The integer closest to the number. If the variable is of type integer, its <i>Result</i> has the same value and type, otherwise, Result is returned as a 32-bit long integer with the same structure as the number.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">L64</h3>
        <p>If set, the result type is 64-bit integer no matter what is the type of the variable. This is useful for situations in which a floating point number contains a value too large to be represented in a 32-bit integer.</p>
        <h1 class="ObjMethod"><a name="kanchor5936"></a><a name="Signum"></a>IDL_Number::Signum</h1>
        <p>The IDL_Number::Signum method returns the sign of each element of an array.</p>
        <h2 class="API">Examples</h2>
        <p>Print the signum value of a number:</p>
        <p class="Code">num = -24601</p>
        <p class="Code">PRINT, num.Signum(&#160;)</p>
        <p>IDL prints:</p>
        <p class="Code">24601</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = var.Signum(  )</p>
        <h2 class="API">Return Value</h2>
        <p>A scalar or array of the same type and dimensions as the variable. If the variable is of type string, then the values are converted to single-precision floating point before computing the sign.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5937"></a><a name="Total"></a>IDL_Number::Total</h1>
        <p>The IDL_Number::Total method returns the sum total of the values within the variable.</p>
        <h2 class="API">Examples</h2>
        <p>Print the total value of an array:</p>
        <p class="Code">num = [10, 100, 1000]</p>
        <p class="Code">PRINT, num.Total(&#160;)</p>
        <p>IDL prints:</p>
        <p class="Code">1110</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = var.Total(  )</p>
        <h2 class="API">Return Value</h2>
        <p>The sum total of the values within the variable.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h2 class="API">Version History</h2>
        <table style="mc-table-style: url('../../Resources/TableStyles/VersionTable.css');margin-left: 0;margin-right: auto;caption-side: top;" cellspacing="0" class="TableStyle_VersionTable">
            <col />
            <col />
            <tbody>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">
                        <p>8.4</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">
                        <p>Introduced</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <h2 class="API">See Also</h2>
        <p><a href="../Functional List of IDL Routines/Static_Methods.htm#Static_Methods_and_Attributes">Static Methods and Attributes</a>, <a href="Variable Attributes.htm#Variable_Attributes">Variable Attributes</a>, <a href="IDL_Integer.htm">IDL_Integer</a>, <a href="IDL_Pointer.htm">IDL_Pointer</a>, <a href="IDL_String.htm">IDL_String</a>, <a href="IDL_Variable.htm#IDL_Variable">IDL_Variable</a></p>
        <div class="mp_footer">© <span class="DocumentTitleCopyrightYear">2015</span>&#160;<span class="DocumentTitleCopyrightCompanyName">Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation</span>. All Rights Reserved. This information is not subject to the controls of the International Traffic in Arms Regulations (ITAR) or the Export Administration Regulations (EAR). However, this information may be restricted from transfer to various embargoed countries under U.S. laws and regulations.</div>
    </body>
</html>