<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-US" xml:lang="en-US" data-mc-search-type="Stem" data-mc-help-system-file-name="idl.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>IDL_Variable</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/Doc_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <h1 class="Routine"><a name="kanchor5964"></a><a name="IDL_Variable"></a>IDL_Variable</h1>
        <p>The IDL_Variable class contains static methods that are available for all IDL variables except objects and structures.</p>
        <h2 class="API">Superclasses</h2>
        <p>None</p>
        <h3>IDL_Variable</h3>
        <ul>
            <li value="1"><a href="#Compare" class="selected">Compare</a> - Compare to another variable and return –1, 0, or 1 for each value.</li>
            <li value="2"><a href="#Convert" class="selected">Convert</a> - Convert the variable to a different data type.</li>
            <li value="3"><a href="#Diff" class="selected">Diff</a> - Returns the unique elements that have been added to or removed from a variable.</li>
            <li value="4"><a href="#Equals" class="selected">Equals</a> - Tests whether two variables are equal.</li>
            <li value="5"><a href="#Filter" class="selected">Filter</a> - Returns only data values that successfully pass through a user-defined filter or Lambda function.</li>
            <li value="6"><a href="#Finite" class="selected">Finite</a> - Returns only the finite values within an array.</li>
            <li value="7"><a href="#FromBits" class="selected">FromBits</a> - Converts the variable from an array of bits.</li>
            <li value="8"><a href="#Hashcode" class="selected">Hashcode</a> - Returns a hash code for the variable.</li>
            <li value="9"><a href="#HasValue" class="selected">HasValue</a> - Returns 1 (true) if the variable contains a given set of values.</li>
            <li value="10"><a href="#IsFinite" class="selected">IsFinite</a> - Returns 1 (true) if all of the values in the variable are finite.</li>
            <li value="11"><a href="#IsInfinite" class="selected">IsInfinite</a> - Returns 1 (true) if all of the values in the variable are infinite.</li>
            <li value="12"><a href="#IsNaN" class="selected">IsNaN</a> - Returns 1 (true) if all of the values in the variable are NaN.</li>
            <li value="13"><a href="#IsReal" class="selected">IsReal</a> - Returns 1 (true) if the variable is not a complex data type.</li>
            <li value="14"><a href="#Map" class="selected">Map</a> - Pass all data values through a user-defined function or Lambda function.</li>
            <li value="15"><a href="#NestedMap" class="selected">NestedMap</a> - Use a nested loop to pass the data values and arguments through a user function.</li>
            <li value="16"><a href="#PtrValid" class="selected">PtrValid</a> - Returns the validity of its pointer arguments, or alternatively returns a vector of pointers to all the existing valid pointer heap variables.</li>
            <li value="17"><a href="#Reduce" class="selected">Reduce</a> - Use a user-defined function or Lambda function to cumulatively combine all values from left to right and return a single value.</li>
            <li value="18"><a href="#Reform" class="selected">Reform</a> - Change the array dimensions.</li>
            <li value="19"><a href="#Shift" class="selected">Shift</a> - Shift array elements along a dimension.</li>
            <li value="20"><a href="#Sort" class="selected">Sort</a> - Returns a sorted copy of the array.</li>
            <li value="21"><a href="#ToBits" class="selected">ToBits</a> - Converts the variable to an array of bits.</li>
            <li value="22"><a href="#ToDouble" class="selected">ToDouble</a> - Converts the variable to type DOUBLE.</li>
            <li value="23"><a href="#ToInteger" class="selected">ToInteger</a> - Converts the variable to type LONG.</li>
            <li value="24"><a href="#ToList" class="selected">ToList</a> - Converts the variable to a LIST.</li>
            <li value="25"><a href="#ToString" class="selected">ToString</a> - Converts the variable to type STRING.</li>
            <li value="26"><a href="#Uniq" class="selected">Uniq</a> - Returns a sorted copy of the array with all duplicates removed.</li>
        </ul>
        <h1 class="ObjMethod"><a name="kanchor5965"></a><a name="Compare"></a>IDL_Variable::Compare</h1>
        <p>IDL_Variable::Compare compares one variable to another and return –1 if the value is smaller, 0 if the values are equal, or +1 if the value is larger.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>The Compare method uses the same rules as the <a href="../../Creating IDL Programs/Components of the IDL Language/Relational_Operators.htm">relational operators</a> (LT, GT, etc.) when comparing values. For example, for strings, the method walks through each character of the two strings until it finds a difference in the byte values. For complex numbers, the absolute value is used for the comparison.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If the two variables are different types, the values will be promoted to the larger type using IDL's <a href="../../Creating IDL Programs/Components of the IDL Language/Data_Type_and_Structure.htm">standard rules of type promotion</a>.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>You can not use the Compare method with pointers.</p>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>The Compare method is useful when constructing comparison functions for <a href="#Sort" class="selected">IDL_Variable::Sort</a>.</p>
        <h2 class="API">Examples</h2>
        <p>Compare one string to another:</p>
        <p class="Code">a = "cap"</p>
        <p class="Code">PRINT, a.Compare("cat")</p>
        <p>IDL&#160;prints:</p>
        <p class="Code">     -1</p>
        <p>Compare an array variable with a scalar:</p>
        <p class="Code">a = [10,3,7,5,11]</p>
        <p class="Code">PRINT, a.Compare(5)</p>
        <p>IDL&#160;prints:</p>
        <p class="Code">1&#160;-1&#160;&#160;1&#160;&#160;0&#160;&#160;1</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Compare( <i>Arg</i> )</p>
        <h2 class="API">Return Value</h2>
        <p>The result is always a variable of type INT containing the values –1, 0, or +1. If both <i>var</i> and <i>Arg</i> are scalars then the result is an integer scalar. If one of the arguments is a scalar and the other is an array, then the scalar is matched up against each value of the array and the result is an integer array of the same dimensions. If both arguments are arrays then the result is an integer array with dimensions equal to whichever array has the smaller number of elements.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Arg</h3>
        <p>The variable to compare against.</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h1 class="ObjMethod"><a name="kanchor5966"></a><a name="Convert"></a>IDL_Variable::Convert</h1>
        <p>The IDL_Variable::Convert method converts the variable to a different data type. This method is equivalent to calling the <a href="../F/FIX.htm">FIX</a> function with the appropriate TYPE keyword value.</p>
        <h2 class="API">Examples</h2>
        <p>Convert a float array to an integer array:</p>
        <p class="Code">var = FINDGEN(5)</p>
        <p class="Code">; We could also use TYPE=3 instead of /LONG</p>
        <p class="Code">newvar = var.Convert(/LONG)</p>
        <p class="Code">HELP, newvar</p>
        <p>IDL prints:</p>
        <p class="Code">NEWVAR          LONG      = Array[5]</p>
        <p>Now convert a string array to double-precision floats:</p>
        <p class="Code">var = ['3.14', '1.23', '-1d100']</p>
        <p class="Code">newvar = var.Convert(/DOUBLE)</p>
        <p class="Code">PRINT, newvar</p>
        <p>IDL prints:</p>
        <p class="Code">3.1400000       1.2300000 -1.0000000e+100</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Convert( KEYWORD=<i>keyword</i> )</p>
        <h2 class="API">Return Value</h2>
        <p>The result is a scalar or array of the same dimensions as the variable with each element converted to the new data type.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>You must specify either the TYPE keyword or one of the individual type keywords.</p>
        <h3 class="Keyword">TYPE</h3>
        <p>Set this keyword to an integer giving the IDL type code to convert to. Possible values are:</p>
        <ul>
            <li value="1">1 - BYTE</li>
            <li value="2">2 - INT</li>
            <li value="3">3 - LONG</li>
            <li value="4">4 - FLOAT</li>
            <li value="5">5 - DOUBLE</li>
            <li value="6">6 - COMPLEX</li>
            <li value="7">7 - STRING</li>
            <li value="8">9 - DCOMPLEX</li>
            <li value="9">12 - UINT</li>
            <li value="10">13 - ULONG</li>
            <li value="11">14 - LONG64</li>
            <li value="12">15 - ULONG64</li>
        </ul>
        <h3 class="Keyword">BYTE, INT, LONG, FLOAT, DOUBLE, COMPLEX, STRING, DCOMPLEX, UINT, ULONG, L64, UL64</h3>
        <p>Instead of using the TYPE keyword, you can set one of these keywords to convert your variable to that type.</p>
        <h1 class="ObjMethod"><a name="kanchor5967"></a><a name="Diff"></a>IDL_Variable::Diff</h1>
        <p>IDL_Variable::Diff returns the number of unique elements which have been added or removed from a variable. The actual values can be captured with output keywords.</p>
        <h2 class="API">Examples</h2>
        <p>Imagine we have a list of files:</p>
        <p class="Code">file_list = ['file_1.dat','file_2.dat','/processed/file.dat']</p>
        <p>Sometime later, we want to find out if our list of files has changed:</p>
        <p class="Code">file_list_new = ['file_2.dat','file_3.dat', $</p>
        <p class="Code_Indented">'/processed/file.dat','/processed/file_1.dat']</p>
        <p class="Code">count = file_list.Diff( file_list_new, ADDED=add, REMOVED=remove )</p>
        <p>The value for count, add, and remove are:</p>
        <p class="Code">PRINT, /IMPLIED, count, add, remove</p>
        <p>IDL prints:</p>
        <p class="Code">3</p>
        <p class="Code">&#160;</p>
        <p class="Code">file_3.dat</p>
        <p class="Code">/processed/file_1.dat</p>
        <p class="Code">&#160;</p>
        <p class="Code">file_1.dat</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Diff( Arg, ADDED=<i>variable</i>, REMOVED=<i>variable</i>, NADDED=<i>variable</i>, NREMOVED=<i>variable</i>)</p>
        <h2 class="API">Return Value</h2>
        <p>The result is a scalar value representing the number of unique elements which have changed (i.e., the sum of NADDED&#160;and NREMOVED).</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Arg</h3>
        <p>The comparison array.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Argument">ADDED</h3>
        <p>A named variable that will contain the values which are present in <i>Arg</i> but not in the variable.</p>
        <h3 class="Argument">NADDED</h3>
        <p>A named variable that will contain the number of values in ADDED.</p>
        <h3 class="Argument">REMOVED</h3>
        <p>A named variable that will contain the values which are present in the variable but not in <i>Arg</i>.</p>
        <h3 class="Argument">NREMOVED</h3>
        <p style="font-style: italic;">Output, Optional</p>
        <p>A named variable that will contain the number of values in REMOVED.</p>
        <h1 class="ObjMethod"><a name="kanchor5968"></a><a name="Equals"></a>IDL_Variable::Equals</h1>
        <p>The IDL_Variable::Equals method returns 1 (true) if the variable is equal to the supplied input argument. The ::Equals method uses the same rules as the <a href="../A/ARRAY_EQUAL.htm">ARRAY_EQUAL</a> function:</p>
        <ul>
            <li value="1">If both variables are arrays then they must have the same number of elements, and all of the corresponding elements must be equal.</li>
            <li value="2">If one variable is an array and the other is a scalar, then every element of the array must be equal to that scalar value.</li>
            <li value="3">If both variables are scalars then the values must be equal.</li>
        </ul>
        <p>For all cases, if the data types are different, then the ::Equals method does automatic type promotion before comparing the values.</p>
        <h2 class="API">Examples</h2>
        <p>Compare two arrays of different data types:</p>
        <p class="Code">var1 = [1.0, 2.0, 3.0, 4.0]</p>
        <p class="Code">var2 = [1, 2, 3, 4]</p>
        <p class="Code">PRINT, var1.Equals(var2)</p>
        <p>IDL prints:</p>
        <p class="Code">1</p>
        <p>Compare an array and a scalar:</p>
        <p class="Code">var = STRARR(100)</p>
        <p class="Code">PRINT, var.Equals("")</p>
        <p>IDL prints:</p>
        <p class="Code">1</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Equals(<i>Value</i>)</p>
        <h2 class="API">Return Value</h2>
        <p>A boolean value of 0 (false) or 1 (true).</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Value</h3>
        <p>An IDL variable to compare to <i>var</i>.</p>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>If you are comparing an array to a scalar, you should make sure that the scalar has the same data type as the array. If the scalar is a more precise data type, then ::Equals will convert the entire array to that type before doing the comparison.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5969"></a><a name="Filter"></a>IDL_Variable::Filter</h1>
        <p>The IDL_Variable::Filter method passes each data value through a boolean filter function or <a href="../L/LAMBDA.htm">Lambda</a> function and returns only values that pass the test.</p>
        <h2 class="API">Examples</h2>
        <p>Create a new file called <code>myfilterfunction.pro</code> that keeps only prime numbers:</p>
        <p class="Code">function myfilterfunction, value</p>
        <p class="Code_Indented">return, value le 3 || MIN(value mod [2:FIX(SQRT(value))])</p>
        <p class="Code">end</p>
        <p>Use your function to return only the prime numbers in an array:</p>
        <p class="Code">var = [2:50]</p>
        <p class="Code">newvar = var.Filter('myfilterfunction')</p>
        <p class="Code">PRINT, newvar</p>
        <p>IDL prints:</p>
        <p class="Code">2  3  5  7 11 13 17 19 23 29 31 37 41 43 47</p>
        <p>Now use a Lambda function to avoid creating a separate routine:</p>
        <p class="Code">var = [2:50]</p>
        <p class="Code">newvar = var.Filter(Lambda(n:n le 3 || MIN(n mod [2:FIX(SQRT(n))])))</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Filter( <i>Function</i>, <i>Args</i> , /VECTOR )</p>
        <h2 class="API">Return Value</h2>
        <p>The result is a vector of the same type as the input containing only the values where the filter function returned a non-zero number for that input value. If none of the values are good then the method returns <a href="../../Creating IDL Programs/Components of the IDL Language/The_Null_Variable.htm">!NULL</a>.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Function</h3>
        <p>A string or Lambda expression giving the name of the user-defined function to call for each value. For user-defined functions, your function should have the form:</p>
        <p class="Code">function myfunction, value</p>
        <p class="Code_Indented">result = ...</p>
        <p class="Code_Indented">return, result</p>
        <p class="Code">end</p>
        <p>The result should be a scalar value containing a non-zero value if the input value "passes" your filter test, and a zero value if the input value "fails" your filter test.</p>
        <h3 class="Argument">Args</h3>
        <p>You can specify any number of additional arguments to be passed on to your filter or Lambda function. Each argument must be either a scalar or an array of the same length as your input. For scalar arguments, ::Filter will pass in that same scalar value to each call of the filter function. For vector arguments, ::Filter will pull out the value corresponding to the current input value and pass that into your filter function as a scalar.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">VECTOR</h3>
        <p>Set this keyword if your <i>Function</i> is "vectorized". In other words, it will give the same result if all of the values are passed in at once instead of looping over each value. By default, IDL&#160;will pass in each value as a separate call.</p>
        <h1 class="ObjMethod"><a name="kanchor5970"></a><a name="Finite"></a>IDL_Variable::Finite</h1>
        <p>The IDL_Variable::Finite method returns an array containing only the finite values within the variable. A value is finite if it is not equal to NaN (not-a-number) or infinity.</p>
        <p>This method is equivalent to calling <code>var[</code><a href="../W/WHERE.htm" style="font-family: monospace;">WHERE</a><code>(</code><a href="../F/FINITE.htm" style="font-family: monospace;">FINITE</a><code>(</code><i style="font-family: monospace;">var</i><code>), /NULL)]</code>.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If the input variable is type integer or string then the method simply returns the original variable.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">var = FINDGEN(10, 20)</p>
        <p class="Code">newvar = var.Finite( )</p>
        <p class="Code">HELP, newvar</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Now make some values be non-finite.</p>
        <p class="Code">var[[5, 10, 15, 20]] = !VALUES.F_NaN</p>
        <p class="Code">newvar = var.Finite( )</p>
        <p class="Code">HELP, newvar</p>
        <p>IDL prints:</p>
        <p class="Code">NEWVAR          FLOAT     = Array[10, 20]</p>
        <p class="Code">NEWVAR          FLOAT     = Array[196]</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Finite( )</p>
        <h2 class="API">Return Value</h2>
        <p>If every element of the input variable is finite, then the result is an array of the same type and dimensions as the input. If the input contains any non-finite elements, then the result is a one-dimensional array (a vector) containing only the finite values.</p>
        <p>If none of the values are finite then the result is set to <a href="../../Creating IDL Programs/Components of the IDL Language/The_Null_Variable.htm">!NULL</a>.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5971"></a><a name="FromBits"></a>IDL_Variable::FromBits</h1>
        <p>The IDL_Variable::FromBits method converts a variable from its bit representation to a scalar value or an array of values.</p>
        <h2 class="API">Example</h2>
        <p class="Code">var = "IDL"</p>
        <p class="Code">newvar = var.ToBits()</p>
        <p class="Code">HELP, newvar</p>
        <p class="Code">var1 = newvar.FromBits(/BYTE)</p>
        <p class="Code">var2 = newvar.FromBits(/STRING)</p>
        <p class="Code">PRINT, var1, var2</p>
        <p>IDL prints:</p>
        <p class="Code">NEWVAR          BYTE      = Array[8, 3]</p>
        <p class="Code">73&#160;&#160;68&#160;&#160;76</p>
        <p class="Code">IDL</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.FromBits( )</p>
        <h2 class="API">Return Value</h2>
        <p>Assume that the input variable has dimensions [N, D<sub>1</sub>, D<sub>2</sub>, ...], where N is the number of bits per element (usually a multiple of 8) and  [D<sub>1</sub>, D<sub>2</sub>, ...] are the additional dimensions. The result is then an array of dimensions  [D<sub>1</sub>, D<sub>2</sub>, ...].</p>
        <p>If the input variable is just a vector of length N then the result is a scalar.</p>
        <p>By default the result will have type LONG, unless one of the type keywords is set.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>You can specify either the TYPE keyword or one of the individual type keywords. If you don't set any keywords then type LONG is used.</p>
        <h3 class="Keyword">TYPE</h3>
        <p>Set this keyword to an integer giving the IDL type code of the result. Possible values are:</p>
        <ul>
            <li value="1">1 - BYTE</li>
            <li value="2">2 - INT</li>
            <li value="3">3 - LONG</li>
            <li value="4">4 - FLOAT</li>
            <li value="5">5 - DOUBLE</li>
            <li value="6">7 - STRING</li>
            <li value="7">12 - UINT</li>
            <li value="8">13 - ULONG</li>
            <li value="9">14 - LONG64</li>
            <li value="10">15 - ULONG64</li>
        </ul>
        <h3 class="Keyword">BYTE, INT, LONG, FLOAT, DOUBLE, STRING, UINT, ULONG, L64, UL64</h3>
        <p>Instead of using the TYPE keyword, you can set one of these keywords to return a variable of that type.</p>
        <h1 class="ObjMethod"><a name="kanchor5972"></a><a name="Hashcode"></a>IDL_Variable::Hashcode</h1>
        <p>The IDL_Variable::Hashcode method returns an unsigned integer (32-bit) hash code for the variable's value. The hash code is computed using Bob Jenkins' One-At-A-Time hash, downloaded from http://www.burtleburtle.net/bob/hash/doobs.html.</p>
        <p>The hash code computation has the following properties:</p>
        <ul>
            <li value="1">All numeric values (except complex) are converted to double-precision floating-point numbers. Therefore, all numbers which have the same value (regardless of IDL type) will produce the same hash. For example, 254b, 254L, and 254.0d will all produce the same hash code.</li>
            <li value="2">Complex numbers (single or double precision) are converted to double-precision complex. Complex numbers which have a zero imaginary part will produce the same hash as their real value.</li>
            <li value="3">Strings are case sensitive.</li>
            <li value="4">For pointers and objects the hash code is computed using the heap id number, and is not guaranteed to be the same across IDL sessions.</li>
            <li value="5">Structures are not allowed.</li>
            <li value="6">For arrays a single hash code is computed using all of the values. Two arrays with matching values will produce the same hash code. Arrays with different elements or elements in a different order will typically produce different hash codes, but this is not guaranteed since there are only 2<sup>32</sup> possible hash values.</li>
            <li value="7">Hash codes for numbers, strings, and arrays should not change across different platforms or IDL versions.</li>
        </ul>
        <h2 class="API">Examples</h2>
        <p class="Code">var1 = "abcd"</p>
        <p class="Code">var2 = "dcba"</p>
        <p class="Code">PRINT, var1.Hashcode( )</p>
        <p class="Code">PRINT, var2.Hashcode( )</p>
        <p>IDL prints:</p>
        <p class="Code">3448463878</p>
        <p class="Code"> 1944347701</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Hashcode( )</p>
        <h2 class="API">Return Value</h2>
        <p>An unsigned long integer.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5973"></a><a name="HasValue"></a>IDL_Variable::HasValue</h1>
        <p>The IDL_Variable::HasValue method determines whether the array contains a given value or values.</p>
        <h2 class="API">Examples</h2>
        <p>Determine whether a string array contains a specific set of values:</p>
        <p class="Code">str = ['3', '1', '2', '5', '4']</p>
        <p class="Code">PRINT, str.HasValue([1,2,3])</p>
        <p>IDL prints:</p>
        <p class="Code">1</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.HasValue( <i>Value</i>  )</p>
        <h2 class="API">Return Value</h2>
        <p>A boolean value of 1 (true) or 0 (false). If the <i>Value</i> argument is an array, each of its values must be contained within <i>var</i> for the result to be true.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Value</h3>
        <p>A scalar or array of any IDL data type except objects or structures.</p>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>You should make sure that <i>Value</i> has the same data type as the variable <i>var</i>. Otherwise, if the <i>Value</i> is a more precise data type, then ::HasValue will convert the entire <i>var</i> array to that type before doing the comparison.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5974"></a><a name="IsFinite"></a>IDL_Variable::IsFinite</h1>
        <p>The IDL_Variable::IsFinite method returns 1 (true) if every element of a variable is finite or 0 (false) if any element is NaN or Infinity.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">var1 = [1.0, 2.0, 3.0]</p>
        <p class="Code">var2 = [1.0, !VALUES.F_NaN, 3.0]</p>
        <p class="Code">PRINT, var1.IsFinite( ), var2.IsFinite( )</p>
        <p>IDL prints:</p>
        <p class="Code">1&#160;&#160;0</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.IsFinite( )</p>
        <h2 class="API">Return Value</h2>
        <p>A boolean value of 0 (false) or 1 (true).</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5975"></a><a name="IsInfinite"></a>IDL_Variable::IsInfinite</h1>
        <p>The IDL_Variable::IsInfinite method returns 1 (true) if every element of the variable is equal to Infinity or 0 (false) if any element is finite.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">var1 = !VALUES.D_Infinity</p>
        <p class="Code">var2 = [1, 2, 3, !VALUES.F_Infinity]</p>
        <p class="Code">PRINT, var1.IsInfinite( ), var2.IsInfinite( )</p>
        <p>IDL prints:</p>
        <p class="Code">1&#160;&#160;0</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.IsInfinite( )</p>
        <h2 class="API">Return Value</h2>
        <p>A boolean value of 0 (false) or 1 (true).</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5976"></a><a name="IsNaN"></a>IDL_Variable::IsNaN</h1>
        <p>The IDL_Variable::IsNaN method returns 1 (true) if every element of the variable is equal to NaN or 0 (false) if any element is finite.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">var1 = !VALUES.F_NaN</p>
        <p class="Code">var2 = [!VALUES.F_NaN, !VALUES.F_NaN, 1.23, !VALUES.F_NaN]</p>
        <p class="Code">PRINT, var1.IsNaN( ), var2.IsNaN( )</p>
        <p>IDL prints:</p>
        <p class="Code">1&#160;&#160;0</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.IsNaN( )</p>
        <h2 class="API">Return Value</h2>
        <p>A boolean value of 0 (false) or 1 (true).</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5977"></a><a name="IsReal"></a>IDL_Variable::IsReal</h1>
        <p>The IDL_Variable::IsReal method returns 1 (true) if every element of the variable has a zero imaginary part.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>For non-complex data, ::IsReal will simply return 1 (true), without examining any of the data. For complex and double-complex data, each element is examined. If all of the elements have zero imaginary, then 1 (true) is returned. As soon as an element is reached that has a non-zero imaginary part, then 0 (false) is returned.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">var1 = 255b</p>
        <p class="Code">var2 = [dcomplex(1, 0), dcomplex(2, 0)]</p>
        <p class="Code">var3 = [dcomplex(1, 0), dcomplex(2, 1)]</p>
        <p class="Code">PRINT, var1.IsReal(), var2.IsReal(), var3.IsReal()</p>
        <p>IDL prints:</p>
        <p class="Code">1&#160;&#160;1&#160;&#160;0</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.IsReal( )</p>
        <h2 class="API">Return Value</h2>
        <p>A boolean value of 1 (true) or 0 (false).</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5978"></a><a name="Map"></a>IDL_Variable::Map</h1>
        <p>The IDL_Variable::Map method passes each data value through a user-defined function or <a href="../L/LAMBDA.htm">Lambda</a> function.</p>
        <h2 class="API">Examples</h2>
        <p>Create a new file called <code>mymapfunction.pro</code> that returns a cubic polynomial:</p>
        <p class="Code">function mymapfunction, x, a, b, c</p>
        <p class="Code_Indented">return, (x - a)^3.0 + (x - b)^2 + (x - c)</p>
        <p class="Code">end</p>
        <p>Use your function to map an array to the new values:</p>
        <p class="Code">var = [-2: 2: 0.01]</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Each var value is passed in separately</p>
        <p class="Code">newvar = var.Map('mymapfunction', 1, 2, 0)</p>
        <p class="Code">PRINT, var, newvar</p>
        <p>IDL prints:</p>
        <p class="Code">-2.00000     -1.99000     -1.98000     -1.97000     -1.96000 ...</p>
        <p class="Code">-13.0000     -12.8008     -12.6032     -12.4072     -12.2127 ...</p>
        <p>Now use a Lambda function to avoid creating a separate routine:</p>
        <p class="Code">var = [-2: 2: 0.01]</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Each var value is passed in separately</p>
        <p class="Code">newvar = var.Map(Lambda(x,a,b,c:(x-a)^3.0+(x-b)^2+(x-c)), 1, 2, 0)</p>
        <p>This function is actually vectorizable, so we can use /VECTOR:</p>
        <p class="Code">var = [-2: 2: 0.01]</p>
        <p class="Code">lcubic = Lambda(x,a,b,c:(x-a)^3.0+(x-b)^2+(x-c))</p>
        <p class="Code">&#160;</p>
        <p class="Code">; All of the var values are pass in at once.</p>
        <p class="Code">newvar = var.Map(lcubic, 1, 2, 0, /VECTOR)</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Map( <i>Function</i>, <i>Args</i> , /VECTOR )</p>
        <h2 class="API">Return Value</h2>
        <p>If the user-defined function returns scalars, then the result is a variable of the same dimensions as the input. If the user-defined function returns an array, then the result is a variable with the combined dimensions of the function's result and the original input.</p>
        <p>The data type of the result is determined by the first call to the <i>Function</i>.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Function</h3>
        <p>A string or Lambda expression giving the name of the user-defined function to call for each value. For user-defined functions, your function should have the form:</p>
        <p class="Code">function myfunction, value</p>
        <p class="Code_Indented">result = ...</p>
        <p class="Code_Indented">return, result</p>
        <p class="Code">end</p>
        <p>The result should be a scalar value.</p>
        <h3 class="Argument">Args</h3>
        <p>You can specify any number of additional arguments to be passed on to your user-defined function or Lambda function. Each argument must be either a scalar or an array of the same length as your input. For scalar arguments, ::Map will pass in that same scalar value to each call of the function. For vector arguments, ::Map will pull out the value corresponding to the current input value and pass that into your function as a scalar.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">VECTOR</h3>
        <p>Set this keyword if your <i>Function</i> is "vectorized". In other words, it will give the same result if all of the values are passed in at once instead of looping over each value. By default, IDL&#160;will pass in each value as a separate call.</p>
        <h2 class="API">More Examples</h2>
        <p>Construct a mapping that returns a three-element array for each input value containing the original value along with the sine and cosine:</p>
        <p class="Code">a = [1:100]</p>
        <p class="Code">r = a.Map(Lambda(a: [a, sin(a), cos(a)]))</p>
        <p class="Code">HELP, r</p>
        <p>IDL&#160;prints:</p>
        <p class="Code">R               FLOAT     = Array[3, 100]</p>
        <p>We could also return the result as a structure array with three fields:</p>
        <p class="Code">a = [1:100]</p>
        <p class="Code">r = a.Map(Lambda(a: {Data: a, SinA: sin(a), CosA: cos(a)}))</p>
        <p class="Code">HELP, r</p>
        <p class="Code">HELP, r.A, r.SINA, r.COSA</p>
        <p>IDL&#160;prints:</p>
        <p class="Code">R               STRUCT    = -&gt; &lt;Anonymous&gt; Array[100]</p>
        <p class="Code">&lt;Expression&gt;    INT       = Array[100]</p>
        <p class="Code">&lt;Expression&gt;    FLOAT     = Array[100]</p>
        <p class="Code">&lt;Expression&gt;    FLOAT     = Array[100]</p>
        <h1 class="ObjMethod"><a name="NestedMap"></a><a name="kanchor5979"></a>IDL_Variable::NestedMap</h1>
        <p>The IDL_Variable::NestedMap method passes each array value along with up to eight other arguments through a user-defined function or <a href="../L/LAMBDA.htm">Lambda</a> function. Each array value is combined with every element from the other arguments using a nested loop. This operation also goes by the name "list comprehension" or "Cartesian product". You can also supply an optional filter function to remove unwanted results.</p>
        <h4>Difference between Map and NestedMap</h4>
        <p>Assume we have two arrays, <code>a</code> and <code>b</code>, with three elements each. For a given map function <code>F(a,b)</code>:</p>
        <p><code>a.Map(F, b)</code> returns a vector containing:</p>
        <p class="Code">[F(a[0], b[0]), F(a[1], b[1]), F(a[2], b[2])]</p>
        <p><code>a.NestedMap(F, b)</code> returns a 2D array containing:</p>
        <p class="Code">[[ F(a[0], b[0]), F(a[1], b[0]), F(a[2], b[0]) ],</p>
        <p class="Code">&#160;[ F(a[0], b[1]), F(a[1], b[1]), F(a[2], b[1]) ],</p>
        <p class="Code">&#160;[ F(a[0], b[2]), F(a[1], b[2]), F(a[2], b[2]) ]]</p>
        <h2 class="API">Example</h2>
        <p>Return a new array containing every combination of items from two array:</p>
        <p class="Code">a = ['a', 'b', 'c']</p>
        <p class="Code">b = ['d', 'e', 'f']</p>
        <p class="Code">c = a.NestedMap(Lambda(x,y:x+y), b)</p>
        <p class="Code">HELP, c</p>
        <p class="Code">PRINT, c</p>
        <p>IDL prints:</p>
        <p class="Code">C               STRING    = Array[3, 3]</p>
        <p class="Code">&#160;&#160;ad&#160;&#160;bd&#160;&#160;cd</p>
        <p class="Code">&#160;&#160;ae&#160;&#160;be&#160;&#160;ce</p>
        <p class="Code">&#160;&#160;af&#160;&#160;bf&#160;&#160;cf</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.NestedMap( <i>Function</i>, <i>Args</i> , FILTER=<i>string</i>)</p>
        <h2 class="API">Return Value</h2>
        <p>The result is an array containing the new values. The data type of the result is determined by the first call to the <i>Function</i>.</p>
        <p>If FILTER is not supplied then the result is a multi-dimensional array, with each dimension given by the number of elements of <i>var</i> and each additional argument. For example, if <i>var</i> has 10 elements, <i>argument 1</i> has 7 elements, and <i>argument 2</i> has 4 elements, then the result is a [10, 7, 4] array.</p>
        <p>If FILTER is supplied then the result is a vector containing all of the retained results. Note that even if <i>all</i> of the results survive the filter, the result will still be a vector.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Function</h3>
        <p>A string or Lambda expression giving the name of the user-defined function to call for each value. For user-defined functions, your function should have the form:</p>
        <p class="Code">function myfunction, value, arg1, arg2, ...</p>
        <p class="Code_Indented">result = ...</p>
        <p class="Code_Indented">return, result</p>
        <p class="Code">end</p>
        <h3 class="Argument">Args</h3>
        <p>You can specify up to eight additional arguments. Each argument must be either a scalar, array, or list of any length. For scalar arguments, ::NestedMap will pass in that same scalar value to each call of the function. For vector arguments, ::NestedMap will perform a nested loop over all elements of that argument plus all other arguments. The nested loop is performed from left to right across the arguments, starting with the original <i>var</i> variable.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">FILTER</h3>
        <p>Set this keyword to a string or Lambda expression giving the name of a user-defined filter function. The function should have the form:</p>
        <p class="Code">function myfilter, result</p>
        <p class="Code_Indented">good = <i>some function of result...</i></p>
        <p class="Code_Indented">return, good ? 1 : 0</p>
        <p class="Code">end</p>
        <p>This function will be called for each result value. The function should return 1 (true) if the result should be added to the <i>Result</i> array, 0 (false) if the result should be discarded, or –1 if the NestedMap should stop early and return just the results up to (but not including) that result.</p>
        <h2 class="API">More Examples</h2>
        <p>Use a Lambda function to return triangles that satisfy the Pythagorean theorem. First construct a new array containing triplets of all combinations of numbers between 1 and 20:</p>
        <p class="Code">x = [1:20]</p>
        <p class="Code">p = x.NestedMap(Lambda(x,y,z:[x,y,z]), x, x)</p>
        <p class="Code">HELP, p</p>
        <p>IDL prints:</p>
        <p class="Code">P               INT       = Array[3, 20, 20, 20]</p>
        <p>This is not what we want. We need to keep only triplets that satisfy x^2 + y^2 = z^2. Use the FILTER keyword to keep only these values:</p>
        <p class="Code">p = x.NestedMap(Lambda(x,y,z:[x,y,z]), x, x, $</p>
        <p class="Code"> &#160;FILTER=Lambda(r:r[2]^2 eq r[0]^2+r[1]^2))</p>
        <p class="Code">HELP, p</p>
        <p class="Code">PRINT, p[*, 0:1] ; print the first two triplets</p>
        <p>IDL prints:</p>
        <p class="Code">P               INT       = Array[3, 12]
</p>
        <p class="Code">4&#160;&#160;&#160;3&#160;&#160;&#160;5</p>
        <p class="Code">3&#160;&#160;&#160;4&#160;&#160;&#160;5</p>
        <p>This still isn't what we want because it has duplicate triplets. Change the filter function to exclude duplicates:</p>
        <p class="Code">p = x.NestedMap(Lambda(x,y,z:[x,y,z]), x, x, $</p>
        <p class="Code_Indented">FILTER=Lambda(r:(r[0] le r[1]) &amp;&amp; (r[2]^2 eq r[0]^2+r[1]^2)))</p>
        <p class="Code">HELP, p</p>
        <p class="Code">PRINT, p</p>
        <p>IDL prints:</p>
        <p class="Code">P               INT       = Array[3, 6]
</p>
        <p class="Code">3&#160;&#160;&#160;&#160;4&#160;&#160;&#160;&#160;5</p>
        <p class="Code">6&#160;&#160;&#160;&#160;8&#160;&#160;&#160;10</p>
        <p class="Code">5&#160;&#160;&#160;12&#160;&#160;&#160;13</p>
        <p class="Code">9&#160;&#160;&#160;12&#160;&#160;&#160;15</p>
        <p class="Code">8&#160;&#160;&#160;15&#160;&#160;&#160;17</p>
        <p class="Code">12&#160;&#160;16&#160;&#160;&#160;20</p>
        <h1 class="ObjMethod"><a name="PtrValid"></a><a name="kanchor5980"></a>IDL_Variable::PtrValid</h1>
        <p>The IDL_Variable::PtrValid method returns the validity of its pointer arguments.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">var = PTR_NEW(228l)</p>
        <p class="Code">PRINT, var.PtrValid( )</p>
        <p>IDL prints:</p>
        <p class="Code">1</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.PtrValid( )</p>
        <h2 class="API">Return Value</h2>
        <p>A boolean value of 0 (false) or 1 (true). If <i>var</i> is not of type pointer, then 0 is returned. If <i>var</i> is an array then ::PtrValid returns an array of 0's and 1's.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5981"></a><a name="Reduce"></a>IDL_Variable::Reduce</h1>
        <p>The IDL_Variable::Reduce method passes each data value cumulatively from left to right through a user-defined function or <a href="../L/LAMBDA.htm">Lambda</a> function and returns a single result.</p>
        <h2 class="API">Examples</h2>
        <p>Create a new file called <code>myreducefunction.pro</code> that adds up arrays (or concatenates strings):</p>
        <p class="Code">function myreducefunction, accumvalue, value</p>
        <p class="Code_Indented">return, accumvalue + value</p>
        <p class="Code">end</p>
        <p>Use your function on an integer array and a string array:</p>
        <p class="Code">var = [1:100]</p>
        <p class="Code">newvar = var.Reduce('myreducefunction')</p>
        <p class="Code">PRINT, newvar</p>
        <p class="Code">var = ['a','b','r','a','c','a','d','a','b','r','a']</p>
        <p class="Code">newvar = var.Reduce('myreducefunction')</p>
        <p class="Code">PRINT, newvar</p>
        <p>IDL prints:</p>
        <p class="Code">5050</p>
        <p class="Code">abracadabra</p>
        <p>Now use a Lambda function to avoid creating a separate routine:</p>
        <p class="Code">var = ['a','b','r','a','c','a','d','a','b','r','a']</p>
        <p class="Code">newvar = var.Reduce(Lambda(x,y:x+y))</p>
        <p>Finally, use the /CUMULATIVE to return all of the intermediate results:</p>
        <p class="Code">newvar = var.Reduce(Lambda(x,y:x+y), /CUMULATIVE, VALUE="IDL: ")</p>
        <p class="Code">PRINT, newvar</p>
        <p>IDL prints:</p>
        <p class="Code">IDL: a</p>
        <p class="Code">IDL: ab</p>
        <p class="Code">IDL: abr</p>
        <p class="Code">IDL: abra</p>
        <p class="Code">IDL: abrac</p>
        <p class="Code">IDL: abraca</p>
        <p class="Code">IDL: abracad</p>
        <p class="Code">IDL: abracada</p>
        <p class="Code">IDL: abracadab</p>
        <p class="Code">IDL: abracadabr</p>
        <p class="Code">IDL: abracadabra</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Reduce( <i>Function</i>, <i>Args</i>, /CUMULATIVE, VALUE=<i>value</i>)</p>
        <h2 class="API">Return Value</h2>
        <p>The result is a value containing the cumulative result. The data type and dimensions of the result will depend upon your calling function's result type and dimensions.</p>
        <p>If your input contains a single element then this value will be returned as the result without calling the function, unless the VALUE keyword is set, in which case the function will be called once.</p>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>You can use the /CUMULATIVE keyword to return all of the intermediate results instead of just the final result.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Function</h3>
        <p>A string or Lambda expression giving the name of the user-defined function to call for each value. For user-defined functions, your function should have the form:</p>
        <p class="Code">function myfunction, accumvalue, value</p>
        <p class="Code_Indented">result = ...</p>
        <p class="Code_Indented">return, result</p>
        <p class="Code">end</p>
        <p>The result should be a scalar value that combines the current accumulated value (the first argument) and the current input value (the second argument).</p>
        <h3 class="Argument">Args</h3>
        <p>You can specify any number of additional arguments to be passed on to your user-defined function or Lambda function. Each argument must be either a scalar or an array of the same length as your input. For scalar arguments, ::Reduce will pass in that same scalar value to each call of the filter function. For vector arguments, ::Reduce will pull out the value corresponding to the current input value and pass that into your function as a scalar.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">CUMULATIVE</h3>
        <p>If this keyword is set, then the <i>Result</i> will be a vector containing all of the intermediate cumulative results instead of just the final result.</p>
        <h3 class="Keyword">VALUE</h3>
        <p>Set this keyword to the starting value. If this keyword is set then this value will be passed into your function along with the first element of your input. If this keyword is not set then the first two elements will be passed into your function.</p>
        <h1 class="ObjMethod"><a name="kanchor5982"></a><a name="Reform"></a>IDL_Variable::Reform</h1>
        <p>The IDL_Variable::Reform method changes the dimensions of an array without changing the total number of elements.</p>
        <p>This method is equivalent to calling the <a href="../R/REFORM.htm">REFORM</a> function.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">var = FINDGEN(100)</p>
        <p class="Code">&#160;</p>
        <p class="Code">; This is equivalent to var.Reform([5, 20])</p>
        <p class="Code">newvar = var.Reform(5, 20)</p>
        <p class="Code">HELP, newvar</p>
        <p>IDL prints:</p>
        <p class="Code">NEWVAR          FLOAT     = Array[5, 20]</p>
        <p>Now remove a leading dimension of 1, replacing the original variable:</p>
        <p class="Code">var = FLTARR(1, 20)</p>
        <p class="Code">var = var.Reform(/OVERWRITE)</p>
        <p class="Code">HELP, var</p>
        <p>IDL prints:</p>
        <p class="Code">VAR             FLOAT     = Array[20]</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Reform( /OVERWRITE )</p>
        <p>or</p>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Reform( <i>Dimensions</i>, /OVERWRITE )</p>
        <p>or</p>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Reform( <i>Dim1</i>, <i>Dim2</i>, <i>Dim3</i>, ..., /OVERWRITE )</p>
        <h2 class="API">Return Value</h2>
        <p>An array of the specified dimensions.</p>
        <h2 class="API">Arguments</h2>
        <p>If the Reform method is called with no arguments, then the method simply removes any dimensions of length 1 and returns.</p>
        <p>You can specify the result dimensions as either a single argument containing a vector of dimensions, or as separate arguments, one for each dimension.</p>
        <h3 class="Argument">Dimensions</h3>
        <p>Set this argument to a vector containing the new dimensions. The total number of elements must be the same as the original variable.</p>
        <h3 class="Argument">Dim1</h3>
        <p>Set the <i>Dim1</i>, <i>Dim2</i>, ... arguments to integers giving the size of each dimension. The total number of elements must be the same as the original variable.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">OVERWRITE</h3>
        <p>Set this keyword to change the dimensions of the variable "in place" instead of making a copy.</p>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>For the OVERWRITE keyword to be effective, you should use the same name for the result variable as the input variable. For example:</p>
        <p class="Code">myvar = FINDGEN(100)</p>
        <p class="Code">myvar = myvar.Reform(10, 10, /OVERWRITE)</p>
        <h1 class="ObjMethod"><a name="kanchor5983"></a><a name="Shift"></a>IDL_Variable::Shift</h1>
        <p>The IDL_Variable::Shift method shifts elements of vectors or arrays along any dimension by any number of elements. Positive shifts are to the right while negative shifts are to the left. All shifts are circular: Elements shifted off one end wrap around and are shifted onto the other end. </p>
        <p>This method is equivalent to calling the <a href="../S/SHIFT.htm">SHIFT</a> function.</p>
        <h2 class="API">Example</h2>
        <p>Take a two-dimensional array, and shift the columns 2 spaces to the left, and the rows down by 1.</p>
        <p class="Code">var = BINDGEN(10, 5)</p>
        <p class="Code">PRINT, var</p>
        <p class="Code">PRINT, var.Shift(-2, 1)</p>
        <p class="Code">; we could also have done var.Shift([-2, 1])</p>
        <p>IDL prints:</p>
        <p class="Code">&#160;0&#160;&#160;1&#160;&#160;2&#160;&#160;3&#160;&#160;4&#160;&#160;5&#160;&#160;6&#160;&#160;7&#160;&#160;8&#160;&#160;9</p>
        <p class="Code">10  11  12  13  14  15  16  17  18  19</p>
        <p class="Code">20  21  22  23  24  25  26  27  28  29</p>
        <p class="Code">30  31  32  33  34  35  36  37  38  39</p>
        <p class="Code">40  41  42  43  44  45  46  47  48  49</p>
        <p class="Code">&#160;</p>
        <p class="Code">42  43  44  45  46  47  48  49  40  41</p>
        <p class="Code">&#160;2&#160;&#160;3&#160;&#160;4&#160;&#160;5&#160;&#160;6&#160;&#160;7&#160;&#160;8&#160;&#160;9&#160;&#160;0&#160;&#160;1</p>
        <p class="Code">12  13  14  15  16  17  18  19  10  11</p>
        <p class="Code">22  23  24  25  26  27  28  29  20  21</p>
        <p class="Code">32  33  34  35  36  37  38  39  30  31</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Shift( <i>S1</i>, <i>S2</i>, <i>S3</i>, ... )</p>
        <h2 class="API">Return Value</h2>
        <p>An array of the same dimensions as the variable.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">S1, S2, S3, ...</h3>
        <p>The shift parameters. The <i>Si</i> arguments can be either a vector containing the shift parameters for each dimension, or a sequence of up to eight scalar shift values.</p>
        <p>A shift specification of 0 means that no shift is to be performed along that dimension.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5984"></a><a name="Sort"></a>IDL_Variable::Sort</h1>
        <p>The IDL_Variable::Sort method returns a sorted copy of the input array using either IDL's built-in comparison rules or a user-defined compare function.</p>
        <p>This method is equivalent to calling <code>var[</code><a href="../S/SORT.htm" style="font-family: monospace;">SORT</a><code>(var)]</code>.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>String arrays are sorted using the ASCII collating sequence. Complex arrays are sorted by their magnitude. Array values which are NaN (not-a-number) are moved to the end of the result.</p>
        <h2 class="API">Example</h2>
        <p class="Code">var = [0.7, 0.2, 0.4, 0.9, 0.0]</p>
        <p class="Code">newvar = var.Sort( )</p>
        <p class="Code">PRINT, newvar</p>
        <p>IDL prints:</p>
        <p class="Code">0.000000     0.200000     0.400000     0.700000     0.900000</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Sort( [COMPARE_FUNCTION=<i>string</i>] [, COUNT=<i>integer</i>] [, INDICES=<i>variable</i>] [, /REVERSE] )</p>
        <h2 class="API">Return Value</h2>
        <p>A one-dimensional array (a vector) of the same type as the input, containing all of the sorted values.</p>
        <p>If the input variable is a scalar then the variable is returned unchanged.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">COMPARE_FUNCTION</h3>
        <p>A string or <a href="../L/LAMBDA.htm">Lambda function</a> giving the name of a user-defined "compare" function. The function should have the form:</p>
        <p class="Code">function myfunc, value1, value2</p>
        <p>The function should return –1 if <code>value1</code> should be considered "less than" <code>value2</code>, +1 if <code>value1</code> is "greater than" <code>value2</code>, or 0 if the two array elements are "equal". By default, the ::Sort method uses IDL's standard rules for comparing values.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If <i>var</i> is a pointer array, then by default the Sort method will simply sort the pointer identifiers, not the actual data within the pointers. However, if you pass in a compare function, then IDL will instead de-reference the pointers and pass in the actual data values to your function. In this case, your comparison function must be able to handle any data types that could be contained within your pointer array.</p>
        <h3 class="Keyword">COUNT</h3>
        <p>Set this keyword to an integer giving the number of elements to sort. You can use this keyword to sort just the first part of an array.</p>
        <h3 class="Keyword">INDICES</h3>
        <p>Set this keyword to a named variable. On return this variable will contain a one-dimensional integer array of subscripts that were used to sort the original values. This variable is identical to the result of calling SORT(var).</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If the number of elements in the input variable is smaller than the largest 32-bit integer, then INDICES will contain 32-bit integers (type LONG), otherwise INDICES will contain 64-bit integers (type LONG64).</p>
        <h3 class="Keyword">REVERSE</h3>
        <p>Set this keyword to sort the array in reverse order.</p>
        <h2 class="API">Examples</h2>
        <p>Do a sort of a string array, but use a compare function to sort on string length. First create a function:</p>
        <p class="Code">function string_compare, a, b</p>
        <p class="Code_Indented">; Return -1, 0, or 1 depending upon the string length</p>
        <p class="Code_Indented">return, (s1.Strlen()).Compare(s2.Strlen())</p>
        <p class="Code">end</p>
        <p>Now do the sort:</p>
        <p class="Code">var = ['abcd', 'dcb', 'z', 'aa']</p>
        <p class="Code">newvar = var.Sort(COMPARE_FUNCTION='string_compare')</p>
        <p class="Code">PRINT, newvar</p>
        <p>IDL prints:</p>
        <p class="Code">z aa dcb abcd</p>
        <p>Now do the same sort, but using a Lambda function:</p>
        <p class="Code">lam = Lambda(a,b: (a.Strlen()).Compare(b.Strlen()))</p>
        <p class="Code">newvar = var.Sort(COMPARE_FUNCTION=lam)</p>
        <h1 class="ObjMethod"><a name="kanchor5985"></a><a name="ToBits"></a>IDL_Variable::ToBits</h1>
        <p>The IDL_Variable::ToBits method converts the variable to an array of bits.</p>
        <h2 class="API">Example</h2>
        <p class="Code">var = [0b, 1b, 3b, 85b, 255b]</p>
        <p class="Code">newvar = var.ToBits()</p>
        <p class="Code">HELP, newvar</p>
        <p class="Code">PRINT, newvar</p>
        <p>IDL prints:</p>
        <p class="Code">NEWVAR          BYTE      = Array[8, 5]</p>
        <p class="Code">0   0   0   0   0   0   0   0</p>
        <p class="Code">0   0   0   0   0   0   0   1</p>
        <p class="Code">0   0   0   0   0   0   1   1</p>
        <p class="Code">0   1   0   1   0   1   0   1</p>
        <p class="Code">1   1   1   1   1   1   1   1</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.ToBits( )</p>
        <h2 class="API">Return Value</h2>
        <p>For byte, integer, and floating-point data, the result is a byte array of dimensions [N, D<sub>1</sub>, D<sub>2</sub>, ...], N is the number of bits per element (either 8, 16, 32, or 64) and the [D<sub>1</sub>, D<sub>2</sub>, ...] are the dimensions of the original variable.</p>
        <p>For string variables the result is a byte array of dimensions [8, M], where each character is converted to its extended-ASCII 8-bit representation, and M is the total number of characters within the entire string array.</p>
        <p>Variables of type complex or type pointer will throw an error.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>This routine will only work with scalars or arrays up to 7 dimensions. Arrays with 8 dimensions will throw an error.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5986"></a><a name="ToDouble"></a>IDL_Variable::ToDouble</h1>
        <p>The IDL_Variable::ToDouble method converts the variable to the double-precision data type.</p>
        <p>This method is equivalent to calling the <a href="../D/DOUBLE.htm">DOUBLE</a> function.</p>
        <h2 class="API">Example</h2>
        <p class="Code">var = ['3.14', '1.23', '-1d100']</p>
        <p class="Code">newvar = var.ToDouble( )</p>
        <p class="Code">PRINT, newvar</p>
        <p>IDL prints:</p>
        <p class="Code">3.1400000       1.2300000 -1.0000000e+100</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.ToDouble( )</p>
        <h2 class="API">Return Value</h2>
        <p>A scalar or array of the same dimensions as the variable.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5987"></a><a name="ToInteger"></a>IDL_Variable::ToInteger</h1>
        <p>The IDL_Variable::ToInteger method converts non-integer variables to type LONG (32-bit signed). Integer variables are returned unchanged.</p>
        <p>This method is equivalent to calling the <a href="../L/LONG.htm">LONG</a> function if the variable is type floating point, complex, or string.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">var = ['-3.14', '1.23', '12.5']</p>
        <p class="Code">PRINT, var.ToInteger( )</p>
        <p class="Code">PRINT, var.ToInteger(/FLOOR)</p>
        <p class="Code">PRINT, var.ToInteger(/CEIL)</p>
        <p class="Code">PRINT, var.ToInteger(/ROUND)</p>
        <p>IDL prints:</p>
        <p class="Code">-3       1 12</p>
        <p class="Code">-4 1 12</p>
        <p class="Code">-3 2 13</p>
        <p class="Code">-3 1 13</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.ToInteger( [/CEIL] [, /FLOOR] [, /ROUND] )</p>
        <h2 class="API">Return Value</h2>
        <p>A scalar or array of the same dimensions as the variable.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If no keywords are specified, the integer portion of each value is kept (for example, [12.9, -12.9] would equate to [12, -12]).</p>
        <h3 class="Keyword">CEIL</h3>
        <p>Set this keyword to return the ceiling, or the closest integer greater than or equal to the value. This is equivalent to calling the <a href="../C/CEIL.htm">CEIL</a> function.</p>
        <h3 class="Keyword">FLOOR</h3>
        <p>Set this keyword to return the floor, or the closest integer less than or equal to the value. This is equivalent to calling the <a href="../F/FLOOR.htm">FLOOR</a> function.</p>
        <h3 class="Keyword">ROUND</h3>
        <p>Set this keyword to round each value. This is equivalent to calling the <a href="../R/ROUND.htm">ROUND</a> function.</p>
        <h1 class="ObjMethod"><a name="kanchor5988"></a><a name="ToList"></a>IDL_Variable::ToList</h1>
        <p>The IDL_Variable::ToList method converts the variable to a <a href="../L/LIST.htm">LIST</a>. This method is equivalent to calling the <a href="../L/LIST.htm">LIST</a> function with the EXTRACT keyword.</p>
        <h2 class="API">Examples</h2>
        <p>Convert a string array to a list:</p>
        <p class="Code">IDL&gt; var = ['My data', '3.14', '1.23', '-1d100']</p>
        <p class="Code">IDL&gt; newvar = var.ToList()</p>
        <p class="Code">IDL&gt; newvar</p>
        <p>IDL prints:</p>
        <p class="Code">[</p>
        <p class="Code_Indented">"My data",</p>
        <p class="Code_Indented">"3.14",</p>
        <p class="Code_Indented">"1.23",</p>
        <p class="Code_Indented">"-1d100"</p>
        <p class="Code">]</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.ToList( /NO_COPY )</p>
        <h2 class="API">Return Value</h2>
        <p>The result is a list with the same number of elements and data types as the original variable.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Because lists are one-dimensional, multidimensional arrays will be collapsed to a single dimension.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">NO_COPY</h3>
        <p>If this keyword is set then the original variable will be destoyed.</p>
        <h1 class="ObjMethod"><a name="kanchor5989"></a><a name="ToString"></a>IDL_Variable::ToString</h1>
        <p>The IDL_Variable::ToString method converts the variable to type STRING with an optional format. By default, for numeric input the ::ToString method removes all extra whitespace, unless you have specified your own <i>Format</i> argument.</p>
        <h2 class="API">Examples</h2>
        <p>Convert a scalar number:</p>
        <p class="Code">var = !Const.Pi</p>
        <p class="Code">PRINT, var.ToString( )</p>
        <p class="Code">PRINT, var.ToString("('Pi=',F7.5)")</p>
        <p>IDL prints:</p>
        <p class="Code">3.1415926535897931</p>
        <p class="Code">Pi=3.14159</p>
        <p>Convert an array of numbers:</p>
        <p class="Code">var = [0:11]</p>
        <p class="Code">HELP, var.ToString( )</p>
        <p class="Code">HELP, var.ToString("(4I3)")</p>
        <p class="Code">PRINT, var.ToString("(4I3)")</p>
        <p>IDL prints:</p>
        <p class="Code">&lt;Expression&gt;    STRING    = Array[12]</p>
        <p class="Code">&lt;Expression&gt;    STRING    = Array[3]</p>
        <p class="Code">&#160;&#160;0&#160;&#160;1&#160;&#160;2&#160;&#160; 3</p>
        <p class="Code">&#160;&#160;4&#160;&#160;5&#160;&#160;6&#160;&#160;7</p>
        <p class="Code">&#160;&#160;8&#160; &#160;9&#160;10&#160;11</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.ToString( [<i>Format</i>] )</p>
        <h2 class="API">Return Value</h2>
        <p>A scalar or array of the same dimensions as the variable. If the <i>Format</i> argument is set then the dimensions of the result will depend upon the format string.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Format</h3>
        <p>A formatting string. See <a href="../../Creating IDL Programs/Components of the IDL Language/Using_Explicitly_Formatt.htm#files_2839720996_168597">Using Explicitly Formatted Input/Output</a>.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor5990"></a><a name="Uniq"></a>IDL_Variable::Uniq</h1>
        <p>The IDL_Variable::Uniq method removes all duplicate values from the input array and returns an array containing only the unique elements, sorted into increasing order.</p>
        <p>This method is equivalent to calling <code>var[</code><a href="../U/UNIQ.htm" style="font-family: monospace;">UNIQ</a><code>(var, </code><a href="../S/SORT.htm" style="font-family: monospace;">SORT</a><code>(var))]</code>.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>String arrays are sorted using the ASCII collating sequence. Complex arrays are sorted by their magnitude. Array values which are NaN (not-a-number) are moved to the end of the result.</p>
        <h2 class="API">Example</h2>
        <p>Construct an array of 1000 elements, containing the values 0...9. Then remove all duplicates.</p>
        <p class="Code">var = LONG(10 * RANDOMU(seed, 1000))</p>
        <p class="Code">PRINT, var</p>
        <p class="Code">newvar = var.Uniq( )</p>
        <p class="Code">PRINT, newvar</p>
        <p>IDL prints:</p>
        <p class="Code"> 4           6           6           7           3           8           4           8           3           6           5           5           6 8           3           8           1           6           6           1 ...</p>
        <p class="Code">0           1           2           3           4           5           6           7           8           9</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = <i>var</i>.Uniq( /NO_SORT )</p>
        <h2 class="API">Return Value</h2>
        <p>A one-dimensional array (a vector) of the same type as the input, containing only the unique values.</p>
        <p>If the input variable is a scalar then the variable is returned unchanged.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">NO_SORT</h3>
        <p>Set this keyword if the original variable is already sorted or you do not want ::Uniq to perform any sorting.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>The ::Uniq method works by examining neighboring values to see if they are equal, and then removing duplicates. If your original variable is not sorted, you may get unexpected results if you set NO_SORT.</p>
        <h2>Version History</h2>
        <table style="caption-side: top;mc-table-style: url('../../Resources/TableStyles/VersionTable.css');" cellspacing="0" class="TableStyle_VersionTable">
            <col />
            <col />
            <tbody>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_ColSep">
                        <p>8.4</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_ColEnd">
                        <p>Introduced</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">8.5</td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">
                        <p>Added ::ToList method</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <h2>See Also</h2>
        <p><a href="../Functional List of IDL Routines/Static_Methods.htm#Static_Methods_and_Attributes">Static Methods and Attributes</a>, <a href="Variable Attributes.htm#Variable_Attributes">Variable Attributes</a>, <a href="IDL_Integer.htm">IDL_Integer</a>, <a href="IDL_Number.htm">IDL_Number</a>, <a href="IDL_Pointer.htm">IDL_Pointer</a>, <a href="IDL_String.htm">IDL_String</a>, <a href="../I/ISA.htm">ISA</a>, <a href="../L/LAMBDA.htm">Lambda</a></p>
        <div class="mp_footer">© <span class="DocumentTitleCopyrightYear">2015</span>&#160;<span class="DocumentTitleCopyrightCompanyName">Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation</span>. All Rights Reserved. This information is not subject to the controls of the International Traffic in Arms Regulations (ITAR) or the Export Administration Regulations (EAR). However, this information may be restricted from transfer to various embargoed countries under U.S. laws and regulations.</div>
    </body>
</html>