<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-US" xml:lang="en-US" data-mc-search-type="Stem" data-mc-help-system-file-name="idl.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="Routines (alphabetical)|Routines: H">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>HASH</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/Doc_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix"> </span><a class="MCBreadcrumbsLink" href="../../images/ref_part1.htm">Routines (alphabetical)</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="H_list.htm">Routines: H</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">HASH</span>
        </div>
        <h1 class="Routine"><a name="L_826528365_1077832"></a><a name="L_826528365_61288"></a><a name="kanchor1106"></a>HASH</h1>
        <p>The HASH function creates a new hash. A <i>hash</i> is a compound data type that contains key-value pairs of different data types, including any mixture of scalars, arrays, structures, pointers, object references, <a href="../L/LIST.htm">lists</a>, and other hashes. </p>
        <p>Hashes have the following properties:</p>
        <ul>
            <li value="1">Elements in a hash are unordered, and are indexed by a scalar key. You can use <a href="../O/ORDEREDHASH.htm">ORDEREDHASH</a> if you need to preserve order.</li>
            <li value="2">The key can be a scalar string or number. String keys are case sensitive unless the FOLD_CASE keyword is set. You can use <a href="../D/DICTIONARY.htm">DICTIONARY</a> if you want case-insensitive keys that can also be accessed using "dot" notation.</li>
            <li value="3">Hashes can change their size, growing and shrinking as elements are added or deleted.</li>
            <li value="4">Individual hash elements can change their value and data type without a performance penalty.</li>
        </ul>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>While you can use IDL's array syntax to access elements in a hash, it is important to remember that a hash does not behave like an array in all cases. See below for a full description of the characteristics of a hash.</p>
        <h3>Methods and Additional Information</h3>
        <ul>
            <li value="1"><a href="#Syntax" class="selected">HASH( )</a>
            </li>
            <li value="2"><a href="#CountMethod" class="selected">Hash::Count</a>
            </li>
            <li value="3"><a href="#Filter" class="selected">Hash::Filter</a>
            </li>
            <li value="4"><a href="#HasKeyMethod" class="selected">Hash::HasKey</a>
            </li>
            <li value="5"><a href="#IsEmptyMethod" class="selected">Hash::IsEmpty</a>
            </li>
            <li value="6"><a href="#KeysMethod" class="selected">Hash::Keys</a>
            </li>
            <li value="7"><a href="#Map" class="selected">Hash::Map</a>
            </li>
            <li value="8"><a href="#Reduce" class="selected">Hash::Reduce</a>
            </li>
            <li value="9"><a href="#RemoveMethod" class="selected">Hash::Remove</a>
            </li>
            <li value="10"><a href="#ToStructMethod" class="selected">Hash::ToStruct</a>
            </li>
            <li value="11"><a href="#ValuesMethod" class="selected">Hash::Values</a>
            </li>
            <li value="12"><a href="#WhereMethod" class="selected">Hash::Where</a>
            </li>
            <li value="13"><a href="#Concatenating" class="selected">Concatenating Hashes</a>
            </li>
            <li value="14">
                <p><a href="#Comparing" class="selected">Comparing Hashes</a>
                </p>
                <ul>
                    <li value="1">EQ Operator</li>
                    <li value="2">NE Operator</li>
                </ul>
            </li>
            <li value="15">
                <p><a href="#HashAccess" class="selected">Hash Access</a>
                </p>
                <ul>
                    <li value="1">Retrieve a Single Element</li>
                    <li value="2">Insert a Single Element</li>
                    <li value="3">Change the Value of a Single Element</li>
                    <li value="4">Retrieve Multiple Elements and Create a New Hash</li>
                    <li value="5">Insert or Change the Value of Multiple Elements</li>
                    <li value="6">Copy a Hash</li>
                    <li value="7">Iterate Through a Hash</li>
                    <li value="8">Access and Change Array Elements within a Hash</li>
                    <li value="9">Auto-Instantiation of Nested Hash Elements</li>
                </ul>
            </li>
            <li value="16">
                <p><a href="#HashInformation" class="selected">Information about Hashes</a>
                </p>
                <ul>
                    <li value="1">Logical Truth</li>
                    <li value="2">Logical Negation</li>
                    <li value="3">N_ELEMENTS</li>
                    <li value="4">ISA</li>
                    <li value="5">TYPENAME</li>
                    <li value="6">HELP</li>
                    <li value="7">PRINT</li>
                    <li value="8">Implied Print</li>
                </ul>
            </li>
        </ul>
        <h2 class="API">Examples</h2>
        <h4>Create a hash containing three key-value pairs, with strings for keys</h4>
        <p class="Code">hash = HASH("one", 1.0, "blue", [255,0,0], "Pi", !DPI)</p>
        <p class="Code">PRINT, N_ELEMENTS(hash)</p>
        <p>IDL Prints:</p>
        <p class="Code">3</p>
        <h4>Create a hash with a mixture of number and string keys</h4>
        <p class="Code">hash = HASH(80301, 'Boulder', 'Joe', 48236)</p>
        <p class="Code">PRINT, hash[80301]</p>
        <p class="Code">PRINT, hash['Joe']</p>
        <p>IDL Prints:</p>
        <p class="Code">Boulder</p>
        <p class="Code">48236</p>
        <h4>Create a hash containing all of the elements of a list</h4>
        <p class="Code">keys = ['A', 'B', 'C', 'D', 'E', 'F', 'G']</p>
        <p class="Code">values = LIST('one', 2.0, 3, 4l, PTR_NEW(5), {n:6}, COMPLEX(7,0))</p>
        <p class="Code">hash = HASH(keys, values)</p>
        <p class="Code">PRINT, N_ELEMENTS(hash)</p>
        <p>IDL Prints:</p>
        <p class="Code">7</p>
        <h4>Create a hash from a structure, and also convert any substructures into hashes</h4>
        <p class="Code">struct = {FIELD1: 4.0, FIELD2: {SUBFIELD1: "hello", SUBFIELD2: 3.14}}</p>
        <p class="Code">hash = HASH(struct, /EXTRACT)</p>
        <p class="Code">PRINT, hash</p>
        <p class="Code">PRINT, hash['FIELD2']</p>
        <p>IDL Prints:</p>
        <p class="Code">FIELD2: HASH  &lt;ID=25  NELEMENTS=2&gt;</p>
        <p class="Code">FIELD1:       4.00000</p>
        <p class="Code">&#160;</p>
        <p class="Code">SUBFIELD1: hello</p>
        <p class="Code">SUBFIELD2:       3.14000</p>
        <h2 class="API"><a name="Syntax"></a>Syntax</h2>
        <p class="Syntax"><i>Result</i> = HASH( <i>Key</i><sub class="italic">1</sub>, <i>Value</i><sub class="italic">1</sub>, <i>Key</i><sub class="italic">2</sub>,
		<i>Value</i><sub class="italic">2</sub>, ... <i>Key</i><sub class="italic">n</sub>, <i>Value</i><sub class="italic">n</sub>,&#160;/<a href="#EXTRACT" class="selected">EXTRACT</a>,&#160;/<a href="#FOLD_CASE" class="selected">FOLD_CASE</a>, /<a href="#NO_COPY" class="selected">NO_COPY</a> )</p>
        <p>or</p>
        <p class="Syntax"><i>Result</i> = HASH( <i>Keys</i>, <i>Values</i>,&#160;/<a href="#EXTRACT" class="selected">EXTRACT</a>,&#160;/<a href="#FOLD_CASE" class="selected">FOLD_CASE</a> )</p>
        <p>or</p>
        <p class="Syntax"><i>Result</i> = HASH( <i>Keys</i> ,&#160;/<a href="#FOLD_CASE" class="selected">FOLD_CASE</a> )</p>
        <p>or</p>
        <p class="Syntax"><i>Result</i> = HASH( <i>Structure</i>,&#160;/<a href="#EXTRACT" class="selected">EXTRACT</a>,&#160;/<a href="#FOLD_CASE" class="selected">FOLD_CASE</a>, /<a href="#LOWERCASE" class="selected">LOWERCASE</a>)</p>
        <h2 class="API">Return Value </h2>
        <p>Returns a <i>reference</i> to a newly-created hash.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Key<sub>n</sub></h3>
        <p>Each <i>Key</i> argument can be a scalar string or number. The corresponding <i>Value</i> can be a scalar or array of any IDL data type including !NULL.</p>
        <p>Each <i>Key</i> argument can also be an array or list, in which case the corresponding <i>Value</i> must be a scalar, an array or a list. If <i>Value</i> is a scalar, then that value is copied into every key. Otherwise, if <i>Value</i> is an array or a list, it must contain the same number of elements as the keys. In this case each element of the <i>Key</i> and <i>Value</i> is inserted as a separate key-value pair. If a given key occurs more than once within the input arguments, the last value will be retained.</p>
        <p>If only <i>Keys</i> is supplied (as either a scalar, an array, or a list), then the corresponding values will be set to the default value of !NULL.</p>
        <p> If no keys or values are supplied, an empty hash is returned.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>For strings, the key is case sensitive unless the FOLD_CASE keyword is set. For example, "Abc" and "abc" will be considered as two separate keys. For numbers, the actual data type does not matter, only the numeric value is used. For example, 1b (byte), 1 (int), and 1.0 (float) will all equate to the same key. Note however that because of the precision of floating-point arithmetic, single-precision and double-precision keys may be considered as different numbers. For example, 0.1 (float) and 0.1d (double) will not equate to the same key.</p>
        <h3 class="Argument">Value<sub>n</sub></h3>
        <p>Each <i>Value</i> argument can be a variable or expression of any IDL data type including <a href="../../Creating IDL Programs/Components of the IDL Language/The_Null_Variable.htm">!NULL</a>.</p>
        <h3 class="Argument">Structure</h3>
        <p>Instead of passing in keys or values, a single IDL structure may be passed in. In this case, each tag/value pair within the structure will be inserted within the hash.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Even though the structure itself is decomposed into key/value pairs, any substructures within the structure will be passed in as a single "value" for that particular key, unless you set the EXTRACT keyword.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword"><a name="EXTRACT"></a>EXTRACT</h3>
        <p>By default, all values are put into the hash unchanged. If the EXTRACT keyword is set, then for any value which is a structure, that structure will be decomposed into key/value pairs (and also recursively for any substructures). </p>
        <h3 class="Keyword"><a name="FOLD_CASE"></a>FOLD_CASE</h3>
        <p>By default, string keys are case sensitive. For example, "Abc" and "abc" will be considered as two separate keys. If the FOLD_CASE keyword is set, then the case for string keys will be ignored when accessing keys, adding new keys, removing keys, or changing values. For example:</p>
        <p class="Code">h = HASH('My key', 1, /FOLD_CASE)</p>
        <p class="Code">h['MY KEY'] = 2</p>
        <p class="Code">print, h['my key']</p>
        <p class="Code">print, h.Keys()</p>
        <p>IDL prints:</p>
        <p class="Code">2</p>
        <p class="Code">My key</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>As shown in the example, even though the key matching is case insensitive, HASH always preserves the case of the key when it was originally set.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If FOLD_CASE is set, then any other hashes returned by this HASH (for example with array indexing or the "+" operator) will also have the FOLD_CASE flag set.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>The FOLD_CASE keyword has no effect for numeric keys.</p>
        <h3 class="Keyword"><a name="NO_COPY"></a>NO_COPY</h3>
        <p>If the NO_COPY keyword is set, the value data is taken away from the <i>Value</i> variable and attached directly to the hash variable. The default behavior is to make a copy of the input values. </p>
        <h3 class="Keyword"><a name="LOWERCASE"></a>LOWERCASE</h3>
        <p>By default, when extracting key/value pairs from a structure, the keys are all uppercase. Set this keyword to use lowercase for all of the keys. This keyword is ignored if the input is not a structure.</p>
        <h1 class="ObjMethod"><a name="kanchor1107"></a><a name="CountMethod"></a>Hash::Count</h1>
        <p>The Hash::Count function method returns the number of elements in the hash. Optionally, the Hash::Count method can return the number of matches to a given value.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= hash.Count( [<i>Value</i>] )</p>
        <h2 class="API">Return Value</h2>
        <p>By default, returns an integer containing the number of elements in the hash. If <i>Value </i>is supplied, then returns an integer giving the number of occurrences of <i>Value </i>within the hash.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>See the Hash::Where method for the rules that are used for comparing values.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Value</h3>
        <p>A value to search for within the hash.</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h1 class="ObjMethod"><a name="kanchor1108"></a><a name="Filter"></a>Hash::Filter</h1>
        <p>The Hash::Filter method passes each hash value through a boolean filter function or <a href="../L/LAMBDA.htm">Lambda</a> function and returns only values that pass the test.</p>
        <h2 class="API">Examples</h2>
        <p>Create a new file called <code>myfilterfunction.pro</code> that keeps only prime numbers:</p>
        <p class="Code">function myfilterfunction, value</p>
        <p class="Code_Indented">return, value le 3 || MIN(value mod [2:FIX(SQRT(value))])</p>
        <p class="Code">end</p>
        <p>Use your function to return only the prime numbers in hash:</p>
        <p class="Code">var = HASH('A', 4, 'B', 5, 'C', 499, 'D', 1000)</p>
        <p class="Code">newvar = var.Filter('myfilterfunction')</p>
        <p>IDL prints:</p>
        <p class="Code">IDL&gt; newvar</p>
        <p class="Code">{</p>
        <p class="Code_Indented">"B": 5,</p>
        <p class="Code_Indented">"C": 499</p>
        <p class="Code">}</p>
        <p>Now use a Lambda function to avoid creating a separate routine:</p>
        <p class="Code">var = HASH('A', 4, 'B', 5, 'C', 499, 'D', 1000)</p>
        <p class="Code">newvar = var.Filter(Lambda(n:n le 3 || MIN(n mod [2:FIX(SQRT(n))])))</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = hash.Filter( <i>Function</i>, <i>Args</i> )</p>
        <h2 class="API">Return Value</h2>
        <p>The result is a hash containing only the key-value pairs where the filter function returned a non-zero number for that input value. If none of the values are good then the method returns an empty hash.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Function</h3>
        <p>A string or Lambda expression giving the name of the user-defined function to call for each value. For user-defined functions, your function should have the form:</p>
        <p class="Code">function myfunction, value</p>
        <p class="Code_Indented">result = ...</p>
        <p class="Code_Indented">return, result</p>
        <p class="Code">end</p>
        <p>The result should be a scalar value containing a non-zero value if the input value "passes" your filter test, and a zero value if the input value "fails" your filter test.</p>
        <h3 class="Argument">Args</h3>
        <p>You can specify any number of additional arguments to be passed on to your filter or Lambda function. Each argument must be either a scalar or a hash. For scalar arguments, ::Filter will pass in that same scalar value to each call of the filter function. For hash arguments, ::Filter will pull out the value corresponding to the current key and pass that into your filter function as a scalar.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If your argument is a hash, it must contain the same keys as the input hash.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="HasKeyMethod"></a>Hash::HasKey</h1>
        <p>The Hash::HasKey function method tests whether a key or set of keys exists in a hash.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">hash = HASH('black', 0, 'gray', 128, 'grey', 128, 'white', 255)</p>
        <p class="Code">print, hash.HasKey('gray')</p>
        <p class="Code">print, hash.HasKey(['grey','red','white'])</p>
        <p>IDL Prints:</p>
        <p class="Code">1</p>
        <p class="Code">1 0 1</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = hash.HasKey(<i>Keys </i>)</p>
        <h2 class="API">Return Value </h2>
        <p>If <i>Keys</i> is a scalar, then returns a scalar 1 if the key exists in the hash, or a 0 otherwise. If <i>Keys</i> is an array or list, then returns an array of 0's or 1's.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Keys</h3>
        <p>A scalar key, or an array or list of keys.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="IsEmptyMethod"></a>Hash::IsEmpty</h1>
        <p>The Hash::IsEmpty function method tests whether the hash is empty or not.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= hash.IsEmpty( )</p>
        <h2 class="API">Return Value</h2>
        <p>Returns 1 if the hash contains zero elements, and 0 otherwise.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="KeysMethod"></a>Hash::Keys</h1>
        <p>The Hash::Keys function method returns a <a href="../L/LIST.htm">LIST</a> containing all keys in a hash. The order of key/value pairs within hash.Keys() and hash.Values() is guaranteed to remain the same as long as no items are added or removed from the hash.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If this is an <a href="../O/ORDEREDHASH.htm">Ordered Hash</a> then the order of the key/value pairs will always be the same.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">hash = HASH('black', 0, 'gray', 128, 'grey', 128, 'white', 255)</p>
        <p class="Code">list = hash.Keys()</p>
        <p class="Code">print, list</p>
        <p>IDL Prints:</p>
        <p class="Code">white</p>
        <p class="Code">black</p>
        <p class="Code">gray</p>
        <p class="Code">grey</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = hash.Keys( )</p>
        <h2 class="API">Return Value </h2>
        <p>Returns a list containing all of the keys. If the hash is empty then an empty list is returned.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor1109"></a><a name="Map"></a>Hash::Map</h1>
        <p>The Hash::Map method passes each hash value through a user-defined function or <a href="../L/LAMBDA.htm">Lambda</a> function.</p>
        <h2 class="API">Examples</h2>
        <p>Create a new file called <code>mymapfunction.pro</code> that adds a file suffix to a file name:</p>
        <p class="Code">function mymapfunction, x, suffix</p>
        <p class="Code_Indented">return, x +&#160;"." + suffix</p>
        <p class="Code">end</p>
        <p>Use your function to map a hash to the new values:</p>
        <p class="Code">var = HASH('File1', 'a', 'File2', 'b')</p>
        <p class="Code">; Each var value is passed in separately</p>
        <p class="Code">newvar = var.Map('mymapfunction', 'pro')</p>
        <p>IDL prints:</p>
        <p class="Code">IDL&gt; var</p>
        <p class="Code">{</p>
        <p class="Code_Indented">"File1": "a",</p>
        <p class="Code_Indented">"File2": "b"</p>
        <p class="Code">}</p>
        <p class="Code">IDL&gt; newvar</p>
        <p class="Code">{</p>
        <p class="Code_Indented">"File1": "a.pro",</p>
        <p class="Code_Indented">"File2": "b.pro"</p>
        <p class="Code">}</p>
        <p>Now use a Lambda function to avoid creating a separate routine:</p>
        <p class="Code">var = HASH('File1', 'a', 'File2', 'b')</p>
        <p class="Code">; Each var value is passed in separately</p>
        <p class="Code">newvar = var.Map(Lambda(x,suffix:x +&#160;"." + suffix), 'pro')</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = hash.Map( <i>Function</i>, <i>Args</i> )</p>
        <h2 class="API">Return Value</h2>
        <p>The result is a hash containing the new key-value pairs.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Function</h3>
        <p>A string or Lambda expression giving the name of the user-defined function to call for each value. For user-defined functions, your function should have the form:</p>
        <p class="Code">function myfunction, value</p>
        <p class="Code_Indented">result = ...</p>
        <p class="Code_Indented">return, result</p>
        <p class="Code">end</p>
        <p>The result should be a scalar value.</p>
        <h3 class="Argument">Args</h3>
        <p>You can specify any number of additional arguments to be passed on to your user-defined function or Lambda function. Each argument must be either a scalar or a hash. For scalar arguments, ::Map will pass in that same scalar value to each call of the function. For hash arguments, ::Map will pull out the value corresponding to the current key and pass that into your function as a scalar.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If your argument is a hash, it must contain the same keys as the input hash.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor1110"></a><a name="Reduce"></a>Hash::Reduce</h1>
        <p>The Hash::Reduce method passes each data value cumulatively through a user-defined function or <a href="../L/LAMBDA.htm">Lambda</a> function and returns a single scalar result.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>The Reduce method passes in the values in the order that they are stored within the hash, not in the order in which the values were originally added to the hash. If you need to preserve the order, you should use an <a href="../O/ORDEREDHASH.htm">OrderedHash</a> instead. </p>
        <h2 class="API">Examples</h2>
        <p>Create a new file called <code>myreducefunction.pro</code> that adds up arrays (or concatenates strings):</p>
        <p class="Code">function myreducefunction, accumvalue, value</p>
        <p class="Code_Indented">return, accumvalue + value</p>
        <p class="Code">end</p>
        <p>Use your function on a hash of key-value pairs:</p>
        <p class="Code">var = HASH('key1', 1, 'key2', 2, 'key3', 3, 'key4', 4)</p>
        <p class="Code">newvar = var.Reduce('myreducefunction')</p>
        <p class="Code">PRINT, newvar</p>
        <p>IDL prints:</p>
        <p class="Code">10</p>
        <p>Now use a Lambda function to avoid creating a separate routine:</p>
        <p class="Code">var = HASH('key1', 1, 'key2', 2, 'key3', 3, 'key4', 4)</p>
        <p class="Code">newvar = var.Reduce(Lambda(x,y:x+y))</p>
        <p>Now try the same reduce function but with string keys. Notice that the order in which the strings are stored within the hash is not the same as the order that the values were originally added:</p>
        <p class="Code">var = HASH('key1', 'a', 'key2', 'b', 'key3', 'c', 'key4', 'd')</p>
        <p class="Code">newvar = var.Reduce(Lambda(x,y:x+y))</p>
        <p>IDL prints:</p>
        <p class="Code">badc</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = hash.Reduce( <i>Function</i>, <i>Args</i>, VALUE=<i>value</i>)</p>
        <h2 class="API">Return Value</h2>
        <p>The result is a scalar value containing the cumulative result. The data type of the result will depend upon your calling function's result type.</p>
        <p>If your input contains a single element then this value will be returned as the result without calling the function, unless the VALUE keyword is set, in which case the function will be called once.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Function</h3>
        <p>A string or Lambda expression giving the name of the user-defined function to call for each value. For user-defined functions, your function should have the form:</p>
        <p class="Code">function myfunction, accumvalue, value</p>
        <p class="Code_Indented">result = ...</p>
        <p class="Code_Indented">return, result</p>
        <p class="Code">end</p>
        <p>The result should be a scalar value that combines the current accumulated value (the first argument) and the current input value (the second argument).</p>
        <h3 class="Argument">Args</h3>
        <p>You can specify any number of additional arguments to be passed on to your user-define function or Lambda function. Each argument must be either a scalar or a hash. For scalar arguments, ::Reduce will pass in that same scalar value to each call of the filter function. For hash arguments, ::Reduce will pull out the value corresponding to the current key and pass that into your function as a scalar.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If your argument is a hash, it must contain the same keys as the input hash.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">VALUE</h3>
        <p>Set this keyword to the starting value. If this keyword is set then this value will be passed into your function along with the first element of your input. If this keyword is not set then the first two elements will be passed into your function.</p>
        <h1 class="ObjMethod"><a name="kanchor1111"></a><a name="RemoveMethod"></a>Hash::Remove</h1>
        <p>The Hash::Remove method removes elements from a hash and optionally returns the removed value.</p>
        <h2 class="API">Examples</h2>
        <p>Create a hash and print its contents:</p>
        <p class="Code">hash = HASH("one", 1.0, "blue", [255,0,0], "Pi", !DPI)</p>
        <p class="Code">PRINT, hash</p>
        <p>IDL Prints:</p>
        <p class="Code">Pi, 3.141592798.6</p>
        <p class="Code">blue, 255       0       0</p>
        <p class="Code">one, 1.00000</p>
        <p>Now delete some hash elements and print the contents again:</p>
        <p class="Code">hash.Remove, ["one", "Pi"]</p>
        <p class="Code">PRINT, hash</p>
        <p class="Code">PRINT, N_ELEMENTS(hash)</p>
        <p>IDL Prints:</p>
        <p class="Code">blue, 255       0       0</p>
        <p class="Code">1</p>
        <p>Now remove the last element off the hash, printing the removed value:</p>
        <p class="Code">PRINT, hash.Remove()</p>
        <p>IDL Prints:</p>
        <p class="Code">255       0       0</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax">hash.Remove [,&#160;<i>Keys</i>] [,&#160;/ALL]</p>
        <p>or</p>
        <p class="Syntax"><i>Result</i> = hash.Remove( [, <i>Keys</i>] [,&#160;/ALL] )</p>
        <h2 class="API">Return Value </h2>
        <p>If <i>Keys</i> is a scalar or 1-element array, then the result is the value itself. If <i>Keys</i> is an array or list of keys, then the result is a hash containing the removed key-value pairs.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If the hash is empty, calling the Hash::Remove() function method will throw an error. The Hash::Remove procedure method will quietly return.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Keys</h3>
        <p>A scalar key or an array or list of keys to be removed. If no <i>Keys</i> are supplied, an arbitrarily-chosen element is removed.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">ALL</h3>
        <p>Set this keyword to remove all entries in <i>Hash</i>, leaving the hash empty, but still in existence.</p>
        <h1 class="ObjMethod"><a name="ToStructMethod"></a>Hash::ToStruct</h1>
        <p>The Hash::ToStruct function method returns an IDL structure containing all of the hash elements converted into tag/value pairs. Keys which are not strings will not be included in the structure. For string keys, any special characters in the string will be converted to underscores to produce a valid IDL tag name. If a value is undefined (!NULL) it will also be skipped (unless the MISSING keyword is set).</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Since the hash stores its key/value pairs in an arbitrary order, the order of tags within the resulting structure will also be arbitrary, even if the same structure was used to create the hash.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If this is an <a href="../O/ORDEREDHASH.htm">Ordered Hash</a> then the order of tags will be the same as the input structure.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">hash = HASH('black', 0, 'gray', 128, 'grey', 128, 'white', 255, 'light red', 200)</p>
        <p class="Code">HELP, hash.ToStruct()</p>
        <p class="Code">&#160;</p>
        <p>IDL Prints:</p>
        <p class="Code">** Structure &lt;332a8ca8&gt;, 5 tags, length=10, data length=10, refs=1:</p>
        <p class="Code">LIGHT_RED       INT            200</p>
        <p class="Code">WHITE &#160;&#160;&#160;&#160;          INT            255</p>
        <p class="Code">BLACK&#160;&#160;&#160;&#160;&#160;         INT              0</p>
        <p class="Code">GRAY&#160;&#160;&#160;&#160;&#160;&#160;           INT            128</p>
        <p class="Code">GREY&#160;&#160;&#160;&#160;&#160;&#160;           INT            128</p>
        <p class="Code">&#160;</p>
        <p>An example using the RECURSIVE keyword:</p>
        <p class="Code">struct = {FIELD1: 4.0, FIELD2: {SUBFIELD1: "hello", SUBFIELD2: 3.14}}</p>
        <p class="Code">hash = HASH(struct, /EXTRACT)</p>
        <p class="Code">PRINT, hash.ToStruct(/RECURSIVE)</p>
        <p>IDL Prints:</p>
        <p class="Code">{{ hello      3.14000}      4.00000}</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = hash.ToStruct(&#160;[, MISSING=<i>value</i>] [, /NO_COPY] [, /RECURSIVE] [, SKIPPED=<i>variable</i>] )</p>
        <h2 class="API">Return Value</h2>
        <p>The result is an IDL structure containing the key/value pairs. If the hash is empty or contains no valid keys then !NULL&#160;is returned.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">MISSING</h3>
        <p>Set this keyword to the value to be returned for missing (!NULL) values. The default behavior of the Hash::ToStruct method is to skip any keys whose value is !NULL.</p>
        <h3 class="Keyword">NO_COPY</h3>
        <p>Set this keyword to move each element from the hash to the output structure. When finished, the hash will be empty.</p>
        <h3 class="Keyword">RECURSIVE</h3>
        <p>If this keyword is set, then any HASH values within the structure are also converted into structures using the ToStruct() method. The MISSING, NO_COPY, and RECURSIVE keywords are passed on to the recursive ToStruct() calls.</p>
        <h3 class="Keyword">SKIPPED</h3>
        <p>Set this keyword to a named variable in which to return a variable of type LIST containing all of the skipped keys. A key will be skipped (not included in the result structure) under the following circumstances:</p>
        <ul>
            <li value="1">The key is not a string;</li>
            <li value="2">The key is already present in the structure (this can happen because keys are case sensitive while structure tags are case insensitive);</li>
            <li value="3">The value associated with a key is !NULL (unless the MISSING keyword is set).</li>
        </ul>
        <h1 class="ObjMethod"><a name="ValuesMethod"></a>Hash::Values</h1>
        <p>The Hash::Values function method returns a <a href="../L/LIST.htm">LIST</a> containing all values in a hash.The order of key/value pairs within hash.Keys() and hash.Values() is guaranteed to remain the same as long as no items are added or removed from the hash.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If this is an <a href="../O/ORDEREDHASH.htm">Ordered Hash</a> then the order of the key/value pairs will always be the same.</p>
        <h2 class="API">Examples</h2>
        <p class="Code">hash = HASH('black', 0, 'gray', 128, 'grey', 128, 'white', 255)</p>
        <p class="Code">list = hash.Values()</p>
        <p class="Code">PRINT, list</p>
        <p>IDL Prints:</p>
        <p class="Code">255</p>
        <p class="Code">0</p>
        <p class="Code">128</p>
        <p class="Code">128</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = hash.Values( )</p>
        <h2 class="API">Return Value </h2>
        <p>Returns a list containing all of the values. If the hash is empty then an empty list is returned.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="WhereMethod"></a>Hash::Where</h1>
        <p>The Hash::Where function method returns a <a href="../L/LIST.htm">LIST</a> of all keys that contain a certain value.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>This method returns a result that is equivalent to using the <a href="../../Creating IDL Programs/Components of the IDL Language/Relational_Operators.htm#hashes_3331144781_1000441">EQ</a> operator, but also provides additional keywords that are not available with the operator.</p>
        <h2 class="API">Examples</h2>
        <p>The following example generates a random integer and an array of ten random integers (both between 0 and 9). The sample uses Hash::Where to determine if there are any matches of the value in the hash (the hash keys are the array indices).</p>
        <p class="Code">keys = 'key' + STRTRIM(SINDGEN(10),2)</p>
        <p class="Code">rndmVal = FIX(10 * RANDOMU(seed, 1))</p>
        <p class="Code">rndmArr = FIX(10 * RANDOMU(seed, 10))</p>
        <p class="Code">h = HASH(keys, rndmArr)</p>
        <p class="Code">matches = h.Where(rndmVal)</p>
        <p class="Code">PRINT, 'Random value = ', rndmVal</p>
        <p class="Code">PRINT, 'Random array = ', rndmArr</p>
        <p class="Code">HELP, matches</p>
        <p class="Code">PRINT, 'Matching keys: ', matches, FORMAT=('(A)')</p>
        <p>Sample output:</p>
        <p class="Code">Random value =        8</p>
        <p class="Code">Random array =        2       7       8       8       0       4       8       3       7       1</p>
        <p class="Code">Matching keys:</p>
        <p class="Code">key3</p>
        <p class="Code">key2</p>
        <p class="Code">key6</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= hash.Where( <i>Value </i>[, COMPLEMENT=<i>variable</i>] [, COUNT=<i>variable</i>] [, NCOMPLEMENT=<i>variable</i>] )</p>
        <h2 class="API">Return Value</h2>
        <p>Returns a list containing all of the keys that contain the value. If there are no matches, an empty list is returned. The following rules are used when comparing values:</p>
        <ul>
            <li value="1">If <i>Value </i>is a scalar number or string, the corresponding hash element must be equal to the same value (although the types may differ).</li>
            <li value="2">If <i>Value </i>is an array, the corresponding hash element must be an array of the same length, with identical values (although the types may differ).</li>
            <li value="3">If <i>Value </i>is a pointer or object, the corresponding hash element must be the same pointer or object reference.</li>
            <li value="4">If <i>Value </i>is a structure, it is compared to the corresponding hash element on a tag-by-tag basis (including nested structures) using the same rules as above.</li>
            <li value="5">If <i>Value </i>is another hash, the two hashes are compared on a key-by-key basis (using the above rules), and the result is a list containing the hash keys which exist in both hashes and have the same value.</li>
        </ul>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Value</h3>
        <p>A variable or expression of any IDL data type, including !NULL.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">COMPLEMENT</h3>
        <p>Set this keyword to a named variable that will return a list of keys that do not contain the value.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If <i>Value </i>is another hash, the COMPLEMENT is a list containing all of the keys in both hashes that either do not exist in the other hash, or have a different value. In this case the number of keys in the COMPLEMENT may be greater than the number of keys in either original hash.</p>
        <h3 class="Keyword">COUNT</h3>
        <p>Set this keyword to a named variable that will return the number of matches.</p>
        <h3 class="Keyword">NCOMPLEMENT</h3>
        <p>Set this keyword to a named variable that will return the number of keys within the COMPLEMENT list.</p>
        <h1>Additional Information on Hashes</h1>
        <h2 class="API"><a name="Concatenating"></a>Concatenating Hashes</h2>
        <p>To combine two hashes to make a new hash, use the + operator:</p>
        <p class="Code">hash1 = HASH('key1', 1, 'key2', 2, 'keydup', 'abc')</p>
        <p class="Code">hash2 = HASH('key3', 'three', 'key4', 4.0, 'keydup', 'xyz')</p>
        <p class="Code">hash3 = hash1 + hash2</p>
        <p class="Code">PRINT, hash3</p>
        <p>IDL Prints:</p>
        <p class="Code">keydup, xyz</p>
        <p class="Code">key2, 2</p>
        <p class="Code">key1, 1</p>
        <p class="Code">key4, 4.00000</p>
        <p class="Code">key3, three</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If the two hashes have duplicate keys, the values will be taken from the second operand.</p>
        <p>The + operator may also be used to combine a hash and an IDL structure to make a new hash:</p>
        <p class="Code">hash1 = HASH('key1', 1, 'key2', 2, 'keydup', 'abc')</p>
        <p class="Code">struct = {tag1: 'mytagvalue', tag2: 2.0}</p>
        <p class="Code">hash3 = hash1 + struct</p>
        <p class="Code">PRINT, hash3</p>
        <p>IDL Prints:</p>
        <p class="Code">keydup: abc</p>
        <p class="Code">key2:        2</p>
        <p class="Code">key1:        1</p>
        <p class="Code">TAG2:       2.00000</p>
        <p class="Code">TAG1: mytagvalue</p>
        <h2 class="API"><a name="Comparing"></a>Comparing Hashes</h2>
        <h3>EQ</h3>
        <p>The <a href="../../Creating IDL Programs/Components of the IDL Language/Relational_Operators.htm">EQ operator</a> does a comparison of two hashes, or a hash and a value. For the case of two hashes, EQ returns a list of keys that exist in both hashes and have the same value. For the case of a hash and a value, EQ returns a list of keys that contain that value. In either case, if there are no matches, an empty list is returned.</p>
        <p>For example, to compare two hashes:</p>
        <p class="Code">hash1 = HASH('key1', 1, 'key2', 2, 'key3', 3, 'anotherkey', 3.14)</p>
        <p class="Code">hash2 = HASH('key1', 1, 'key2', 2, 'key3', 3.5)</p>
        <p class="Code">result = hash1 EQ hash2</p>
        <p class="Code">HELP, result</p>
        <p class="Code">PRINT, result</p>
        <p>IDL Prints:</p>
        <p class="Code">RESULT          LIST  &lt;ID=114775  NELEMENTS=2&gt;</p>
        <p class="Code">key2</p>
        <p class="Code">key1</p>
        <p>To compare a hash and a value:</p>
        <p class="Code">hash = HASH('key1', 1.414, 'key2', 3.14, 'key3', 1.414)</p>
        <p class="Code">result = hash EQ 1.414&#160;&#160;&#160;&#160;; (or 1.414 EQ hash)</p>
        <p class="Code">HELP, result</p>
        <p class="Code">PRINT, result</p>
        <p>IDL Prints:</p>
        <p class="Code">RESULT          LIST  &lt;ID=114789  NELEMENTS=2&gt;</p>
        <p class="Code">key1</p>
        <p class="Code">key3</p>
        <p>To compare a hash and a value that is not in the hash:</p>
        <p class="Code">hash = HASH('key1', 1.414, 'key2', 3.14, 'key3', 1.414)</p>
        <p class="Code">result = hash EQ 2.718&#160;&#160;&#160;&#160;; (or 2.718 EQ hash)</p>
        <p class="Code">HELP, result</p>
        <p>IDL Prints:</p>
        <p class="Code">RESULT          LIST  &lt;ID=114817  NELEMENTS=0&gt;</p>
        <p class="Code">&#160;</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>See the Hash::Where method for the rules that are used for comparing values.</p>
        <h3>NE</h3>
        <p>The <a href="../../Creating IDL Programs/Components of the IDL Language/Relational_Operators.htm">NE operator</a> behaves in the opposite manner of EQ. For NE with two hashes, the result is a list containing all of the keys in both hashes that either do not exist in the other hash, or have a different value. For NE with a hash and a value, the result is a list containing all of the keys that do not contain that value. In either case, if every element is a match, then an empty list is returned.</p>
        <p>For example, to compare two hashes:</p>
        <p class="Code">hash1 = HASH('key1', 1, 'key2', 2, 'key3', 3, 'anotherkey', 3.14)</p>
        <p class="Code">hash2 = HASH('key1', 1, 'key2', 2, 'key3', 3.5)</p>
        <p class="Code">result = hash1 NE hash2</p>
        <p class="Code">HELP, result</p>
        <p class="Code">PRINT, result</p>
        <p>IDL Prints:</p>
        <p class="Code">RESULT          LIST  &lt;ID=114843  NELEMENTS=2&gt;</p>
        <p class="Code">anotherkey</p>
        <p class="Code">key3</p>
        <p>To compare a hash and a value:</p>
        <p class="Code">hash = HASH('key1', 1.414, 'key2', 3.14, 'key3', 1.414)</p>
        <p class="Code">result = hash NE 1.414&#160;&#160;&#160;&#160;; (or 1.414 NE hash)</p>
        <p class="Code">HELP, result</p>
        <p class="Code">PRINT, result</p>
        <p>IDL Prints:</p>
        <p class="Code">RESULT          LIST  &lt;ID=114857  NELEMENTS=1&gt;</p>
        <p class="Code">key2</p>
        <p>To compare a hash and a !NULL value:</p>
        <p class="Code">hash = HASH('key1', 1.414, 'key2', 3.14, 'key3', !NULL, 'key4', !NULL)</p>
        <p class="Code">result = hash NE !NULL&#160;&#160;&#160;&#160;; (or !NULL NE hash)</p>
        <p class="Code">HELP, result</p>
        <p class="Code">PRINT, result</p>
        <p>IDL Prints:</p>
        <p class="Code">RESULT          LIST  &lt;ID=114817  NELEMENTS=2&gt;</p>
        <p class="Code">key2</p>
        <p class="Code">key1</p>
        <h2 class="API"><a name="HashAccess"></a>Hash Access</h2>
        <p>In many cases, you can access elements of a hash variable using standard IDL array syntax, as if the hash were a one-dimensional array.</p>
        <h3>Retrieve a Single Element</h3>
        <p>To copy the value of a single hash element into a new variable, leaving the hash unchanged, use array syntax:</p>
        <p class="Code">value = hash[<i>Key</i>]</p>
        <p>where <i>Key</i> is the scalar key of the desired element within the hash.</p>
        <p>To retrieve an arbitrary element in a hash and remove it, use the hash.Remove() method:</p>
        <p class="Code">value = hash.Remove()</p>
        <p>To retrieve a specific element in a hash and remove it:</p>
        <p class="Code">value = hash.Remove(<i>Key</i>)</p>
        <p>where <i>Key</i> is the scalar key of the desired element within the hash.</p>
        <h3>Insert a Single Element</h3>
        <p>To insert a single value into a hash, creating a new hash element, use array syntax:</p>
        <p class="Code">hash[<i>Key</i>] = <i>Value</i></p>
        <p>where <i>Value</i> is the value to be stored in the new hash element.</p>
        <h3>Change the Value of a Single Element</h3>
        <p>To change the value of a single hash element, use array syntax:</p>
        <p class="Code">hash[<i>Key</i>] = <i>Value</i></p>
        <p>where <i>Key</i> is the scalar key of the desired element within the hash and <i>Value</i> is the new value.</p>
        <h3>Retrieve Multiple Elements and Create a New Hash</h3>
        <p>To create a new hash that is a subset of an existing hash, use array syntax:</p>
        <p class="Code">newHash = origHash[ <i>Keys</i> ]</p>
        <p>where <code><i>Keys</i></code> is an array or list of keys. Here <code>newHash</code> is a new hash variable that contains copies of the key-value pairs from <code>origHash</code>.</p>
        <h3>Insert or Change the Value of Multiple Elements</h3>
        <p>Insert or change the value of multiple hash elements in a single operation by specifying an array or list of keys to be replaced and/or added in the existing hash and providing the replacement values in an array or list:</p>
        <p class="Code">hash[ <i>Keys</i> ] = <i>Values</i></p>
        <p>where <code><i>Keys</i></code> is an array or list of keys, and <code><i>Values</i></code> is a scalar, an array or a list of values. If <code><i>Values</i></code> is a scalar, then that value is copied into every key. Otherwise, if <code><i>Values</i></code> is an array or a list, it must contain the same number of elements as the keys. In this case each element of <code><i>Keys</i></code> and <code><i>Values</i></code> is inserted as a separate key-value pair. For each key-value pair, if the key already exists in the hash then the value is replaced, and if the key does not exist then it is added. If a given key occurs more than once within the new keys, the last value will be retained.</p>
        <h3>Copy a Hash</h3>
        <p>To copy a hash reference, simply assign it to a new variable:</p>
        <p class="Code">newHash = origHash</p>
        <p>It is important to understand that with this operation, <code>newHash</code> and <code>origHash</code> are references to the same hash; modifying an element in one hash modifies the same element in the other hash. For example, if we create <code>hash2</code> as a copy of <code>hash1</code> and then change the value of an element in <code>hash2</code>, the same element in <code>hash1</code> also changes:</p>
        <p class="Code">hash1 = HASH('key1', 1, 'key2', 2)</p>
        <p class="Code">hash2 = hash1</p>
        <p class="Code">hash2['key1'] = 'hello'</p>
        <p class="Code">HELP, hash1['key1'], hash2['key1']</p>
        <p>IDL Prints:</p>
        <p class="Code">&lt;Expression&gt;    STRING    = 'hello'</p>
        <p class="Code">&lt;Expression&gt;    STRING    = 'hello'</p>
        <p>Note that both hashes contain the new value for that key.</p>
        <p>To create a new hash variable whose elements are copies of the values in the original hash, you could use the following:</p>
        <p class="Code">newHash = HASH(origHash.Keys(), origHash.Values())</p>
        <p>Another method to copy a hash is to use array syntax to copy all of the elements:</p>
        <p class="Code">newHash = origHash[*]</p>
        <p>For example:</p>
        <p class="Code">hash1 = HASH('key1', 1, 'key2', 2)</p>
        <p class="Code">hash2 = hash1[*]</p>
        <p class="Code">hash2['key1'] = 'hello'</p>
        <p class="Code">HELP, hash1['key1'], hash2['key1']</p>
        <p>IDL Prints:</p>
        <p class="Code">&lt;Expression&gt;    STRING    = 1</p>
        <p class="Code">&lt;Expression&gt;       STRING    = 'hello'</p>
        <p>Note that the value in <code>hash1</code> remains unchanged.</p>
        <h3>Iterate Through a Hash</h3>
        <p>To iterate through the elements in a hash, loop over the keys and use standard array syntax:</p>
        <p class="Code">hash = HASH('Mercury', 1, 'Venus', 2, 'Earth', 3, 'Mars', 4)</p>
        <p class="Code">keys = hash.Keys()</p>
        <p class="Code">FOR i=0,N_ELEMENTS(hash)-1 DO PRINT, hash[keys[i]]</p>
        <p>A more efficient method of iteration is to use FOREACH:</p>
        <p class="Code">  hash = HASH('Mercury', 1, 'Venus', 2, 'Earth', 3, 'Mars', 4)</p>
        <p class="Code">  FOREACH value, hash DO     &#160;&#160;&#160;&#160;&#160;&#160;&#160;PRINT, 'Value = ', value</p>
        <p>You may also use the optional argument to FOREACH to retrieve the key associated with each value:</p>
        <p class="Code">  hash = HASH('Mercury', 1, 'Venus', 2, 'Earth', 3, 'Mars', 4)</p>
        <p class="Code">  FOREACH value, hash, key DO PRINT, key + ' is planet #', value</p>
        <p class="Code">&#160;</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>While iterating through a hash you should avoid adding or removing elements. If the hash is changed during the FOREACH, the behavior  is undefined.</p>
        <h3>Access and Change Array Elements within a Hash</h3>
        <p>If a hash item contains an array, another hash, or a list, individual elements within that item may be accessed and modified using standard array syntax. In this case, the first dimension must be a hash key (a scalar string or number) that specifies the hash element, and the higher dimensions are used to index into the array itself. The higher dimensions may be any combination of scalars, subscript ranges, or index arrays. The syntax looks like:</p>
        <p class="Code">values = hash[key, sub0, sub1,...]</p>
        <p class="Code">hash[key, sub0, sub1,...] = values</p>
        <p>where <i>key </i>is a scalar string or number that specifies the hash element, and <i>sub0</i>, <i>sub1</i>,... are the subscript ranges or indices for the contained array.</p>
        <p>For example, to create a "ragged" array, where each element is a vector of a different length:</p>
        <p class="Code">hash = HASH( 'Array1', FINDGEN(100), 'Array2', FINDGEN(67), 'Array3', FINDGEN(93), $</p>
        <p class="Code"> 'Array4', FINDGEN(120) )</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Print the 6th element of the first vector</p>
        <p class="Code">PRINT, hash['Array1', 5]</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Print every other element of the third vector</p>
        <p class="Code">PRINT, hash['Array3', 0:*:2]</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Change several elements of the fourth vector</p>
        <p class="Code">HASH['Array4', [5,10,15,20]] = -1</p>
        <p>In this example, we create a hash that contains a one-dimensional array, a string, and a two-dimensional array:</p>
        <p class="Code">hash = HASH( 'Data', FINDGEN(10), 'Date', 'April 1, 2001', 'Hanning', HANNING(100, 50) )</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Modify an element in the center of the 2D array</p>
        <p class="Code">hash['Hanning', 50, 25] = 0.0</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Change an entire column of the 2D array</p>
        <p class="Code">hash['Hanning', 99, *] = -1.0</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Extract a subset of the 2D array</p>
        <p class="Code">HELP, hash['Hanning', 10:15, 7:11]</p>
        <p>IDL prints:</p>
        <p class="Code">&lt;Expression&gt;    FLOAT     = Array[6, 5]</p>
        <p>In this example, we create a hash that contains a one-dimensional array, a string, a list, (which contains a two-dimensional array), and another  hash:</p>
        <p class="Code">hash = HASH('Data', FINDGEN(10), 'Date', 'April 2', $</p>
        <p class="Code">&#160;&#160;'List', LIST('MyData', DIST(20, 30)), $</p>
        <p class="Code">&#160;&#160;'Properties', HASH('LINESTYLE', 3, 'THICK', 2) )</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Extract the entire 2D array from the sub-list</p>
        <p class="Code">HELP, hash['List', 1]</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Extract a subset of the 2D array within the sub-list</p>
        <p class="Code">HELP, hash['List', 1, 10:15, [20,21,22] ]</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Add a new key-value to the hash within the hash</p>
        <p class="Code">hash['Properties', 'COLOR'] = 'blue'</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Extract a value from the hash within the hash</p>
        <p class="Code">HELP, HASH['Properties', 'COLOR' ]</p>
        <p>IDL prints:</p>
        <p class="Code">&lt;Expression&gt;    FLOAT     = Array[20, 30]</p>
        <p class="Code">&lt;Expression&gt;    FLOAT     = Array[6, 3]</p>
        <p class="Code">&lt;Expression&gt;    STRING    = 'blue'</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>When indexing into an array contained within a hash, the first dimension must always be the hash key. Since IDL can only handle a maximum of eight dimensions, you can only use up to seven dimensions when indexing into an array within a hash. If the array is contained within a hash or list (which is itself contained within a hash), the maximum number of dimensions will be six, and so on.</p>
        <h3>Auto-Instantiation of Nested Hash Elements</h3>
        <p>Imagine that we create a nested hash:</p>
        <p class="Code">h = HASH('a', HASH('b', HASH('c', 5)))</p>
        <p>We can then access our nested value using multiple-array subscripts:</p>
        <p class="Code">PRINT, h['a', 'b', 'c']</p>
        <p>We could also have created the nested hash using multiple statements:</p>
        <p class="Code">h = HASH()</p>
        <p class="Code">h['a'] = HASH()</p>
        <p class="Code">h['a', 'b'] = HASH()</p>
        <p class="Code">h['a', 'b', 'c'] = 5</p>
        <p>Both of the above methods are cumbersome and error prone. Instead, just like inserting an unknown hash key will add that hash key, we can also nest "unknown" subscripts and IDL will create the necessary nested hash. For example:</p>
        <p class="Code">h = HASH()</p>
        <p class="Code">h['a', 'b', 'c'] = 5</p>
        <p class="Code">PRINT, h, /IMPLIED</p>
        <p>IDL prints:</p>
        <p class="Code">{</p>
        <p class="Code_Indented">"a": {</p>
        <p class="Code_Indented2">"b": {</p>
        <p class="Code_Indented2">&#160;&#160;"c": 5</p>
        <p class="Code_Indented2">}</p>
        <p class="Code_Indented">}</p>
        <p class="Code">}</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If your object is a subclass of hash, such as an <a href="../O/ORDEREDHASH.htm">ORDEREDHASH</a> or a <a href="../D/DICTIONARY.htm">DICTIONARY</a>, then IDL will actually create a nested container of that same subclass.</p>
        <h2 class="API"><a name="HashInformation"></a>Information about Hashes</h2>
        <h3>Logical Truth</h3>
        <p>The <a href="../../Creating IDL Programs/Components of the IDL Language/Logical_Operators.htm">logical truth operator</a> evaluates a hash. It returns a value of 1 (TRUE) if the hash is non-empty, and returns 0 (FALSE) if the hash is empty.</p>
        <p class="Code">IF (hash) THEN . . .</p>
        <h3>Logical Negation</h3>
        <p>The <a href="../../Creating IDL Programs/Components of the IDL Language/Logical_Operators.htm">logical negation operator</a> negates the logical value of a hash:</p>
        <p class="Code">IF (~hash) THEN . . .</p>
        <p>If <i>hash</i> is TRUE, the statement evaluates as FALSE, and so on.</p>
        <h3>N_ELEMENTS</h3>
        <p>The N_ELEMENTS function returns the number of elements in a hash:</p>
        <p class="Code">Result = N_ELEMENTS(hash)</p>
        <p>If <code>hash</code> contains zero elements, or if <code>hash</code> is an undefined variable, 0 is returned.</p>
        <p>For more information, see <a href="../N/N_ELEMENTS.htm#N_830853741_953695">N_ELEMENTS</a>.</p>
        <h3>ISA</h3>
        <p>The ISA function can determine whether the given variable is a hash:</p>
        <p class="Code">x = HASH('key1', 1, 'key2', 2)<br />PRINT, ISA(x, 'HASH')</p>
        <p>IDL prints:</p>
        <p class="Code">1</p>
        <p>For more information, see <a href="../I/ISA.htm#I_833016429_1127569">ISA</a>.</p>
        <h3>TYPENAME</h3>
        <p>The TYPENAME function returns the type HASH for a hash variable:</p>
        <p class="Code">x = HASH('key1', 1, 'key2', 2)<br />PRINT, TYPENAME(x)</p>
        <p>IDL prints:</p>
        <p class="Code">HASH</p>
        <p>For more information, see <a href="../T/TYPENAME.htm#T_809226861_1160964">TYPENAME</a>.</p>
        <h3>HELP</h3>
        <p>The <a href="HELP.htm">HELP procedure</a> provides general information about a hash variable:</p>
        <p class="Code">newHash = HASH('key1', 1, 'key2', [1,2,3])<br />HELP, newHash</p>
        <p>IDL prints:</p>
        <p class="Code">NEWHASH         HASH  &lt;ID=1 NELEMENTS=2&gt;</p>
        <p>In this case, the variable name is NEWHASH. the type name is HASH, the heap ID is 1, and there are two elements in the hash.</p>
        <h3>PRINT</h3>
        <p>The <a href="../P/PRINT.htm">PRINT procedure</a> gives the value for each hash element:</p>
        <p class="Code">newHash = HASH('Mercury', 1, 'Venus', 2, 'Earth', 3, 'Mars', 4)<br />PRINT, newHash</p>
        <p>IDL prints:</p>
        <p class="Code">Earth, 3</p>
        <p class="Code">Mars, 4</p>
        <p class="Code">Venus, 2</p>
        <p class="Code">Mercury, 1</p>
        <h3>Implied Print</h3>
        <p>Using <a href="../../Creating IDL Programs/Components of the IDL Language/ImpliedPrint.htm">Implied Print</a> with a hash will print out the hash key/values in standard <a href="../J/JSON_PARSE.htm">JSON</a> notation. For example, enter the following lines at the IDL&#160;command prompt:</p>
        <p class="Code">img = HASH()</p>
        <p class="Code">img["src"] = "Images/Sun.png"</p>
        <p class="Code">img["name"] = "sun1"</p>
        <p class="Code">img["hOffset"] = LIST(250, 500, 1000)</p>
        <p class="Code">img["alignment"] = "center"</p>
        <p class="Code">newHash = HASH()</p>
        <p class="Code">newHash["image"] = img</p>
        <p class="Code">newHash<br /></p>
        <p>IDL prints:</p>
        <p class="Code">{</p>
        <p class="Code_Indented">"image":</p>
        <p class="Code_Indented">{</p>
        <p class="Code_Indented2">"src":          "Images/Sun.png",</p>
        <p class="Code_Indented2">"name":         "sun1",</p>
        <p class="Code_Indented2">"hOffset":</p>
        <p class="Code_Indented2">[</p>
        <p class="Code_Indented2">&#160;&#160;250,</p>
        <p class="Code_Indented2">&#160;&#160;500,</p>
        <p class="Code_Indented2">&#160;&#160;1000</p>
        <p class="Code_Indented2">],</p>
        <p class="Code_Indented2">"alignment":    "center"</p>
        <p class="Code_Indented">}</p>
        <p class="Code">}</p>
        <h2 class="API">Version History</h2>
        <table style="caption-side: top;mc-table-style: url('../../Resources/TableStyles/VersionTable.css');" cellspacing="0" class="TableStyle_VersionTable">
            <col />
            <col />
            <tbody>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_ColSep">
                        <p>8.0</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_ColEnd">
                        <p>Introduced</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowSep_ColSep">
                        <p>8.1</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowSep_ColEnd">
                        <p>Added NO_COPY keyword to ToStruct function method</p>
                        <p>Added Count, FindValue, IsEmpty methods</p>
                        <p>Added ability to index into arrays within a hash</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_ColSep">8.2</td>
                    <td class="TableStyle_VersionTable_Body_0_0_ColEnd">Added the Where method, deprecated the FindValue method</td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowSep_ColSep">8.3</td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowSep_ColEnd">Added Implied Print to JSON format</td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_ColSep">8.4</td>
                    <td class="TableStyle_VersionTable_Body_0_0_ColEnd">Added FOLD_CASE keyword</td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">8.5</td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">Added auto-instantiation of nested hash elements</td>
                </tr>
            </tbody>
        </table>
        <h2 class="API">See Also</h2>
        <p><a href="../../Creating IDL Programs/Components of the IDL Language/The_Null_Variable.htm">!NULL</a>, <a href="../D/DICTIONARY.htm">DICTIONARY</a>, <a href="../L/LIST.htm#L_826528365_1077832">LIST</a>, <a href="../O/ORDEREDHASH.htm">ORDEREDHASH</a>, <a href="../../Creating IDL Programs/Components of the IDL Language/Logical_Operators.htm">Logical Operators</a>, <a href="../../Creating IDL Programs/Components of the IDL Language/Relational_Operators.htm">Relational Operators</a></p>
        <div class="mp_footer">© <span class="DocumentTitleCopyrightYear">2015</span>&#160;<span class="DocumentTitleCopyrightCompanyName">Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation</span>. All Rights Reserved. This information is not subject to the controls of the International Traffic in Arms Regulations (ITAR) or the Export Administration Regulations (EAR). However, this information may be restricted from transfer to various embargoed countries under U.S. laws and regulations.</div>
    </body>
</html>