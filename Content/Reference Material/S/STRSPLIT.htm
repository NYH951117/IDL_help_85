<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-US" xml:lang="en-US" data-mc-search-type="Stem" data-mc-help-system-file-name="idl.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="Routines (alphabetical)|Routines: S">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>STRSPLIT </title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/Doc_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix"> </span><a class="MCBreadcrumbsLink" href="../../images/ref_part1.htm">Routines (alphabetical)</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="S_list.htm">Routines: S</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">STRSPLIT</span>
        </div>
        <h1 class="Routine"><a name="S_820040301_679167"></a><a name="S_820040301_82197"></a><a name="kanchor2473"></a>STRSPLIT </h1>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>See also the <a href="../Static Methods/IDL_String.htm#Extract">IDL_String::Extract</a> and <a href="../Static Methods/IDL_String.htm#Split">IDL_String::Split</a> methods, which provide similar functionality but with an object-oriented interface.</p>
        <p>The STRSPLIT function splits its input <i>String</i> argument into separate substrings, according to the specified delimiter or regular expression. By default, an array of the position of the substrings is returned. The EXTRACT keyword can be used to cause STRSPLIT to return an array containing the substrings.</p>
        <p>STRSPLIT can also be used to split an array of strings. In this case a <a href="../L/LIST.htm">LIST</a> is returned with the results.</p>
        <h2 class="API">Example</h2>
        <p>To split a string on spans of whitespace and replace them with hyphens:</p>
        <p class="Code">Str = 'STRSPLIT chops up strings.'<br />print, STRJOIN(STRSPLIT(Str, /EXTRACT), '-')</p>
        <p>IDL prints:</p>
        <p class="Code">STRSPLIT-chops-up-strings.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = STRSPLIT( <i>String</i> [,&#160;<i>Pattern</i>] [,&#160;<a href="#S_820040301_1071730" class="selected">COUNT</a>=<i>variable</i>] [,&#160;<a href="#S_820040301_1153687" class="selected">ESCAPE</a>=<i>string</i> | ,&#160;/<a href="#S_820040301_1071772" class="selected">REGEX</a> [,&#160;/<a href="#S_820040301_1071757" class="selected">FOLD_CASE</a>]] [,&#160;/<a href="#S_820040301_1071749" class="selected">EXTRACT</a> | ,&#160;<a href="#S_820040301_1071761" class="selected">LENGTH</a>=<i>variable</i>] [,&#160;/<a href="#S_820040301_1071767" class="selected">PRESERVE_NULL</a>] )</p>
        <h2 class="API">Return Value</h2>
        <p>If <i>String</i> is a scalar string or 1-element string array, then STRSPLIT returns an array containing either the positions of the substrings or the substrings themselves (if the EXTRACT keyword is specified).</p>
        <p>If <i>String</i> is an array of strings, then STRSPLIT returns a variable of type <a href="../L/LIST.htm">LIST</a>, where each element of the list contains the result of calling STRSPLIT on a particular element of <i>String</i>.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">String</h3>
        <p>A scalar string or a string array to be split into substrings.</p>
        <h3 class="Argument">Pattern</h3>
        <p>A scalar string or a string array that can contain one of two types of information: </p>
        <ul>
            <li value="1">One or more <i>single characters</i>, each of which is considered to be a separator. <i>String</i> will be split when any of the characters is detected. For example, if <i>Pattern</i> is <code>"&#160;,"</code><i>String</i> will be split whenever <i>either</i> a space or a comma is detected. In this case, IDL performs a simple string search for the specified characters. This method is simple and fast.</li>
            <li value="2">If the REGEX keyword is specified, <i>Pattern</i> is considered to be a single regular expression (as implemented by the <a href="STREGEX.htm#S_820040301_1077065">STREGEX</a> function). This method is slower and more complex, but can handle extremely complicated <i>Pattern</i> strings.</li>
        </ul>
        <p>In either case, if the EXTRACT keyword is specified, the separator characters are <i>not</i> included in the result.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span><i>Pattern</i> is an optional argument. If it is not specified, STRSPLIT defaults to splitting on spans of whitespace (space or tab characters) in <i>String</i>.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If <i>String</i> is a string array, and <i>Pattern</i> is a scalar, then the same pattern is used for each string. If <i>Pattern</i> is an array, then it must have the same number of elements as <i>String</i>. In this case each element in <i>Pattern</i> is matched up with its corresponding element in <i>String</i>.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword"><a name="S_820040301_1071730"></a><a name="S_820040301_1071730_Keywords_STRSPLIT__"></a>COUNT</h3>
        <p>Set this keyword to a named variable that will contain the number of matched substrings returned by STRSPLIT. This value will be 0 if either of the <i>String</i> or <i>Pattern</i> arguments is null. Otherwise, it will contain the number of elements in the <i>Result</i> array. If <i>String</i> is an array, then COUNT will be an array with the same number of elements.</p>
        <h3 class="Keyword"><a name="S_820040301_1153687"></a><a name="S_820040301_1153687_Keywords_STRSPLIT__"></a>ESCAPE</h3>
        <p>When doing simple pattern matching, the ESCAPE keyword can be used to specify any characters that should be considered to be “escape” characters. Preceding any character with an escape character prevents STRSPLIT from treating it as a separator character even if it is found in <i>Pattern</i>.</p>
        <p>Note that if the EXTRACT keyword is set, STRSPLIT will automatically remove the escape characters from the resulting substrings. If EXTRACT is not specified, STRSPLIT cannot perform this editing, and the returned position and offsets will include the escape characters.</p>
        <p>For example:</p>
        <p class="Code">print, STRSPLIT('a\,b,c', ',', ESCAPE='\', /EXTRACT)</p>
        <p>IDL prints:</p>
        <p class="Code">a,b c</p>
        <p>ESCAPE cannot be specified with the FOLD_CASE or REGEX keywords.</p>
        <h3 class="Keyword"><a name="S_820040301_1071749"></a><a name="S_820040301_1071749_Keywords_STRSPLIT__"></a>EXTRACT</h3>
        <p>By default, STRSPLIT returns an array of character offsets into <i>String</i> that indicate where the substrings are located. These offsets, along with the lengths available from the LENGTH keyword can be used later with STRMID to extract the substrings. Set EXTRACT to bypass this step, and cause STRSPLIT to return the substrings.</p>
        <h3 class="Keyword"><a name="S_820040301_1071757"></a><a name="S_820040301_1071757_Keywords_STRSPLIT__"></a>FOLD_CASE</h3>
        <p>Indicates that the regular expression matching should be done in a case-insensitive fashion. FOLD_CASE can only be specified if the REGEX keyword is set, and cannot be used with the ESCAPE keyword.</p>
        <h3 class="Keyword"><a name="S_820040301_1071761"></a><a name="S_820040301_1071761_Keywords_STRSPLIT__"></a>LENGTH</h3>
        <p>Set this keyword to a named variable to receive the lengths of the substrings. Together with this result of this function, LENGTH can be used with the STRMID function to extract the matched substrings.</p>
        <p>If String is an array, then LENGTH will be a LIST, where each element of the list is an array of the lengths of the substrings for a particular element of <i>String</i>.</p>
        <h3 class="Keyword"><a name="S_820040301_1071767"></a><a name="S_820040301_1071767_Keywords_STRSPLIT__"></a>PRESERVE_NULL</h3>
        <p>Normally, STRSPLIT will not return null length substrings unless there are no non-null values to report, in which case STRSPLIT will return a single empty string. Set PRESERVE_NULL to cause all null substrings to be returned.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>With PRESERVE_NULL set, null strings are returned when the search pattern occurs at either end of the input string, or when the search pattern occurs multiple times sequentially.</p>
        <h3 class="Keyword"><a name="S_820040301_1071772"></a><a name="S_820040301_1071772_Keywords_STRSPLIT__"></a>REGEX</h3>
        <p>For complex splitting tasks, the REGEX keyword can be specified. In this case, <i>Pattern</i> is taken to be a regular expression to be matched against <i>String</i> to locate the separators. If REGEX is specified and <i>Pattern</i> is not, the default <i>Pattern</i> is the regular expression:</p>
        <p class="Code">'[ ' + STRING(9B) + ']+'</p>
        <p>which means “any series of one or more space or tab characters” (9B is the byte value of the ASCII TAB character).</p>
        <p>Note that the default <i>Pattern</i> contains a space after the [ character.</p>
        <p>The REGEX keyword cannot be used with the ESCAPE keyword.</p>
        <p>For more information about regular expressions, see <a href="../../Creating IDL Programs/Components of the IDL Language/Learning_About_Regular_E.htm#strings_3486979161_298753">Learning About Regular Expressions</a>.</p>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>If you want STRSPLIT to split on a multi-character separator pattern (instead of a list of two or more individual separator characters), you will need to use the REGEX keyword.</p>
        <h2 class="API">Additional Examples</h2>
        <p>1. As an example of a more complex splitting task that can be handled with the simple character-matching mode of STRSPLIT, consider a sentence describing different colored ampersand characters. For unknown reasons, the author used commas to separate all the words, and used ampersands or backslashes to escape the commas that actually appear in the sentence (which therefore should not be treated as separators). The unprocessed string looks like:</p>
        <p class="Code">Str = 'There,was,a,red,&amp;&amp;&amp;,,a,yellow,&amp;&amp;\,,and,a,blue,\&amp;&amp;.'</p>
        <p>We use STRSPLIT to break this line apart, and STRJOIN to reassemble it as a standard blank-separated sentence:</p>
        <p class="Code">S = STRSPLIT(Str, ',', ESCAPE='&amp;\', /EXTRACT)<br />PRINT, STRJOIN(S, ' ')</p>
        <p>IDL prints:</p>
        <p class="Code">There was a red &amp;, a yellow &amp;, and a blue &amp;.</p>
        <p>2. Strings separated by multi-character delimiters cannot be split using the simple character matching mode of STRSPLIT. Such delimiters require the use of a regular expression. For instance, consider splitting the following string on double ampersand boundaries. </p>
        <p class="Code">str = 'red&amp;&amp;blue&amp;&amp;yellow&amp;&amp;odds&amp;ends'</p>
        <p>The desired result of such splitting would be four strings, with the values ‘red’, ‘blue’, ‘yellow’, and ‘odds&amp;ends’. You might be tempted to use STRSPLIT as follows:</p>
        <p class="Code">PRINT, STRSPLIT(str,'&amp;&amp;',/EXTRACT)</p>
        <p>which causes IDL to print:</p>
        <p class="Code">red blue yellow odds ends</p>
        <p>IDL split the string on single ampersand boundaries, yielding 5 strings instead of the desired 4. When using the simple character matching mode of STRSPLIT, the characters in the Pattern argument specify a set of possible single character delimiters. The order of these characters is unimportant, and specifying a character more than once has no effect (the extras are ignored).</p>
        <p>To properly split the above string using a regular expression:</p>
        <p class="Code">print, strsplit(str,'&amp;&amp;',/EXTRACT, /REGEX)</p>
        <p>producing the desired IDL output:</p>
        <p class="Code">red blue yellow odds&amp;ends</p>
        <p>3. Suppose you had a complicated string, in which every token was preceded by the count of characters in that token, with the count enclosed in angle brackets:</p>
        <p class="Code">str = '&lt;4&gt;What&lt;1&gt;a&lt;7&gt;tangled&lt;3&gt;web&lt;2&gt;we&lt;6&gt;weave.'</p>
        <p>This is too complex to handle with simple character matching, but can be easily handled using the regular expression '&lt;[0-9]+&gt;' to match the separators. This regular expression can be read as “an opening angle bracket, followed by one or more numeric characters between 0 and 9, followed by a closing angle bracket.” The STRJOIN function is used to glue the resulting substrings back together:</p>
        <p class="Code">S = STRSPLIT(str,'&lt;[0-9]+&gt;',/EXTRACT,/REGEX)<br />PRINT, STRJOIN(S, ' ')</p>
        <p>IDL prints:</p>
        <p class="Code">What a tangled web we weave.</p>
        <p>4. Here we take a string array, and split each element. The result is a variable of type LIST, where each element is the result of STRSPLIT on the corresponding string:</p>
        <p class="Code">str = ['Hwæt! We Gardena         in geardagum,', $</p>
        <p class="Code">'þeodcyninga,         þrym gefrunon,', $</p>
        <p class="Code">'hu ða æþelingas         ellen fremedon.', $</p>
        <p class="Code">'Oft Scyld Scefing         sceaþena þreatum,', $</p>
        <p class="Code">'monegum mægþum,         meodosetla ofteah,', $</p>
        <p class="Code">'egsode eorlas.         Syððan ærest wearð', $</p>
        <p class="Code">'feasceaft funden,         he þæs frofre gebad,', $</p>
        <p class="Code">'weox under wolcnum,         weorðmyndum þah,', $</p>
        <p class="Code">'oðþæt him æghwylc         þara ymbsittendra', $</p>
        <p class="Code">'ofer hronrade         hyran scolde,', $</p>
        <p class="Code">'gomban gyldan.         þæt wæs god cyning!']</p>
        <p class="Code">&#160;</p>
        <p class="Code">result = STRSPLIT(str, ' ', /EXTRACT, COUNT=count, LENGTH=length)</p>
        <p class="Code">&#160;</p>
        <p class="Code">HELP, result, count, length</p>
        <p class="Code">FOREACH item, result DO PRINT, STRJOIN(item,'|')</p>
        <p class="Code">&#160;</p>
        <p>IDL prints:</p>
        <p class="Code">RESULT          LIST  &lt;ID=1  NELEMENTS=11&gt;</p>
        <p class="Code">COUNT           LONG      = Array[11]</p>
        <p class="Code">LENGTH          LIST  &lt;ID=2  NELEMENTS=11&gt;</p>
        <p class="Code">&#160;</p>
        <p class="Code">Hwæt!|We|Gardena|in|geardagum,</p>
        <p class="Code">þeodcyninga,|þrym|gefrunon,</p>
        <p class="Code">hu|ða|æþelingas|ellen|fremedon.</p>
        <p class="Code">Oft|Scyld|Scefing|sceaþena|þreatum,</p>
        <p class="Code">monegum|mægþum,|meodosetla|ofteah,</p>
        <p class="Code">egsode|eorlas.|Syððan|ærest|wearð</p>
        <p class="Code">feasceaft|funden,|he|þæs|frofre|gebad,</p>
        <p class="Code">weox|under|wolcnum,|weorðmyndum|þah,</p>
        <p class="Code">oðþæt|him|æghwylc|þara|ymbsittendra</p>
        <p class="Code">ofer|hronrade|hyran|scolde,</p>
        <p class="Code">gomban|gyldan.|þæt|wæs|god|cyning!</p>
        <p>5. Using the <a href="#S_820040301_1071767" class="selected">PRESERVE_NULL</a> keyword:</p>
        <p class="Code">; Create a 5-element string array with nulls in the first and last elements.</p>
        <p class="Code">; Note that nulls are created only at the beginning and end of the string.</p>
        <p class="Code">string1 = ",one,two,three,"</p>
        <p class="Code">split1 = STRSPLIT(string1, ',', /PRESERVE_NULL, /EXTRACT)</p>
        <p class="Code">HELP, split1</p>
        <p class="Code">foreach s,split1 do print, strlen(s),':',s</p>
        <p>IDL Prints:</p>
        <p class="Code">SPLIT1&#160;&#160;           &#160;&#160;&#160;STRING    = Array[5]</p>
        <p class="Code">0:</p>
        <p class="Code">3:one</p>
        <p class="Code">3:two</p>
        <p class="Code">5:three</p>
        <p class="Code">0:</p>
        <p>Try a variation, showing how null strings are generated when the search pattern is repeated sequentially (i.e., twice in a row):</p>
        <p class="Code">; Create a 7-element string array with nulls in the first and last elements.</p>
        <p class="Code">; Note that nulls are created only at the beginning and end of the string.</p>
        <p class="Code">string2 = ",one,,two,,three,"</p>
        <p class="Code">split2 = STRSPLIT(string2, ',', /PRESERVE_NULL, /EXTRACT)</p>
        <p class="Code">HELP, split2</p>
        <p class="Code">foreach s,split2 do print, strlen(s),':',s</p>
        <p>IDL Prints:</p>
        <p class="Code">SPLIT2&#160;&#160;           &#160;&#160;&#160;STRING    = Array[7]</p>
        <p class="Code">0:</p>
        <p class="Code">3:one</p>
        <p class="Code">0:</p>
        <p class="Code">3:two</p>
        <p class="Code">0:</p>
        <p class="Code">5:three</p>
        <p class="Code">0:</p>
        <p>IDL creates the null elements when it encounters the two commas together: ',,'</p>
        <h2 class="API">Version History</h2>
        <table style="caption-side: top;mc-table-style: url('../../Resources/TableStyles/VersionTable.css');margin-left: 0;margin-right: auto;" cellspacing="0" class="TableStyle_VersionTable">
            <col />
            <col />
            <tbody>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_ColSep">
                        <p>5.3</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_ColEnd">
                        <p>Introduced</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowSep_ColSep">
                        <p>6.0</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowSep_ColEnd">
                        <p>Added COUNT keyword</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">
                        <p>8.0</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">
                        <p>Allow string arrays</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <h2 class="API">See Also</h2>
        <p><a href="../../Creating IDL Programs/Components of the IDL Language/String_Operations.htm">String Operations</a>, <a href="../Functional List of IDL Routines/String_Processing.htm">String Processing</a>, <a href="STRCMP.htm#S_820040301_679036">STRCMP</a>, <a href="STRJOIN.htm#S_820040301_1076861">STRJOIN</a>, <a href="STRMATCH.htm#S_820040301_679108">STRMATCH</a>, <a href="STREGEX.htm#S_820040301_1077065">STREGEX</a>, <a href="STRMID.htm#S_820040301_1074010">STRMID</a>, <a href="STRPOS.htm#S_820040301_679132">STRPOS</a>, <a href="../L/LIST.htm">LIST</a>, <a href="../../Creating IDL Programs/Components of the IDL Language/Learning_About_Regular_E.htm#strings_3486979161_298753">Learning About Regular Expressions</a>, <a href="../Static Methods/IDL_String.htm">IDL_String</a></p>
        <div class="mp_footer">© <span class="DocumentTitleCopyrightYear">2015</span>&#160;<span class="DocumentTitleCopyrightCompanyName">Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation</span>. All Rights Reserved. This information is not subject to the controls of the International Traffic in Arms Regulations (ITAR) or the Export Administration Regulations (EAR). However, this information may be restricted from transfer to various embargoed countries under U.S. laws and regulations.</div>
    </body>
</html>