<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-US" xml:lang="en-US" data-mc-search-type="Stem" data-mc-help-system-file-name="idl.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="Routines (alphabetical)|Routines: L">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>LIST</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/Doc_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix"> </span><a class="MCBreadcrumbsLink" href="../../images/ref_part1.htm">Routines (alphabetical)</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="L_list.htm">Routines: L</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">LIST</span>
        </div>
        <h1 class="Routine"><a name="L_826528365_1077832"></a><a name="L_826528365_61288"></a><a name="kanchor1674"></a>LIST</h1>
        <p>The LIST function creates a new list. A <i>list</i> is a compound data type that contains elements of different data types, including any mixture of scalars, arrays, structures, pointers, object references, and other lists or <a href="../H/HASH.htm">hashes</a>. </p>
        <p>Lists have the following properties:</p>
        <ul>
            <li value="1">Elements in a list are ordered, and are indexed in one dimension.</li>
            <li value="2">Lists can change their size, growing and shrinking as elements are added or deleted.</li>
            <li value="3">Individual list elements can change their value and data type without a performance penalty.</li>
            <li value="4">List is implemented as a singly-linked list of pointers.</li>
        </ul>
        <h4>Difference between Arrays and Lists</h4>
        <ul>
            <li value="1">IDL arrays can only contain elements of the same data type. The elements are stored in a contiguous block of memory. Adding or removing elements is always an expensive operation because the new memory must be allocated and all elements of the existing array must be copied. Indexing individual elements within an array is always fast, because simple math can be used to determine the memory locations.</li>
            <li value="2">IDL lists can contain elements of any data type. The elements are stored as a singly-linked list of pointers to the data. Adding or removing elements from the beginning or end of the list is fast, because the list contains a special pointer to the head and tail. Adding or removing elements from the middle of the list will be slower because the linked list must be traversed. However, even in this case, it may still be faster than using an array because no memory needs to be copied. Indexing into the middle of a list will be slower than an array.</li>
        </ul>
        <h3>Methods and Additional Information</h3>
        <ul>
            <li value="1"><a href="#AddMethod" class="selected">List::Add</a> - Add a new item to the list.</li>
            <li value="2"><a href="#CountMethod" class="selected">List::Count</a> - Return the number of items in the list.</li>
            <li value="3"><a href="#Filter" class="selected">List::Filter</a> - Pass the items through a filter function.</li>
            <li value="4"><a href="#IsEmptyMethod" class="selected">List::IsEmpty</a> - Test whether the list is empty.</li>
            <li value="5"><a href="#Map" class="selected">List::Map</a> - Pass the items through a user-defined function.</li>
            <li value="6"><a href="#MoveMethod" class="selected">List::Move</a> - Move items in the list.</li>
            <li value="7"><a href="#NestedMap" class="MCXref xref selected">List::NestedMap</a> - Pass the items through a user-defined function using a nested loop.</li>
            <li value="8"><a href="#Reduce" class="selected">List::Reduce</a> - Pass each item through a function, accumulating the result.</li>
            <li value="9"><a href="#RemoveMethod" class="selected">List::Remove</a> - Remove an item from the list.</li>
            <li value="10"><a href="#ReverseMethod" class="selected">List::Reverse</a> - Reverse all elements in the list.</li>
            <li value="11"><a href="#SortMethod" class="selected">List::Sort</a> - Sort the list.</li>
            <li value="12"><a href="#SwapMethod" class="selected">List::Swap</a> - Switch the positions of two items in the list.</li>
            <li value="13"><a href="#ToArrayMethod" class="selected">List::ToArray</a> - Convert the list to an IDL array.</li>
            <li value="14"><a href="#WhereMethod" class="selected">List::Where</a> - Find where items are equal to a certain value.</li>
            <li value="15"><a href="#Concaten" class="selected">Concatenating Lists</a>
            </li>
            <li value="16">
                <p><a href="#Comparin" class="selected">Comparing Lists</a>
                </p>
                <ul>
                    <li value="1">EQ Operator</li>
                    <li value="2">NE Operator</li>
                </ul>
            </li>
            <li value="17">
                <p><a href="#List" class="selected">List Access</a>
                </p>
                <ul>
                    <li value="1">Retrieve a Single Element</li>
                    <li value="2">Insert a Single Element</li>
                    <li value="3">Change the Value of a Single Element</li>
                    <li value="4">Create a Sub-List</li>
                    <li value="5">Insert  Multiple Elements</li>
                    <li value="6">Change the Value of Multiple Elements</li>
                    <li value="7">Copy a List</li>
                    <li value="8">Iterate Through a List</li>
                    <li value="9">Access and Change Array Elements within a List</li>
                </ul>
            </li>
            <li value="18">
                <p><a href="#Informat" class="selected">Information about Lists</a>
                </p>
                <ul>
                    <li value="1">Logical Truth</li>
                    <li value="2">Logical Negation</li>
                    <li value="3">N_ELEMENTS</li>
                    <li value="4">ISA</li>
                    <li value="5">TYPENAME</li>
                    <li value="6">HELP</li>
                    <li value="7">PRINT</li>
                    <li value="8">Implied Print</li>
                </ul>
            </li>
        </ul>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = LIST( [<i>Value<sub>1</sub></i>, <i>Value<sub>2</sub></i>, ... <i>Value<sub>n</sub></i>] [,&#160;/<a href="#EXTRACT" class="selected">EXTRACT</a>] [,&#160;<a href="#LENGTH" class="selected">LENGTH</a>=<i>value</i>] [,&#160;/<a href="#NO_COPY" class="selected">NO_COPY</a>])</p>
        <h2 class="API">Return Value </h2>
        <p>Returns a <i>reference</i> to a newly-created list.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Value<sub>n</sub></h3>
        <p>Each <i>Value</i> argument can be a variable or expression of any IDL data type including <a href="../../Creating IDL Programs/Components of the IDL Language/The_Null_Variable.htm">!NULL</a>. If no <i>Value</i> argument is supplied, a reference to an empty list is returned.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword"><a name="EXTRACT"></a>EXTRACT</h3>
        <p>Normally, if a <i>Value</i> argument refers to an array or a list, that array or list is inserted into the new list as a single element. If the EXTRACT keyword is specified, any <i>Value</i> argument that contains an array or a list will be disassembled, and each element of the array or list will be added to the new list as a separate element. The EXTRACT keyword has no effect if none of the <i>Value</i> arguments are arrays or lists.</p>
        <h3 class="Keyword"><a name="LENGTH"></a>LENGTH</h3>
        <p>Set this keyword to an integer value to create a list with the specified number of elements. If LENGTH is greater than the number of <i>Value</i> arguments, the <i>Value</i> arguments supplied are cyclically repeated to fill out the list. If no <i>Value</i> arguments are supplied, all list elements will contain the value !NULL.</p>
        <h3 class="Keyword"><a name="NO_COPY"></a>NO_COPY</h3>
        <p>If the NO_COPY keyword is set, the value data is taken away from the <i>Value</i> variable and attached directly to the list variable. The default behavior is to make a copy of the input values. </p>
        <h2 class="API">Examples</h2>
        <p>Create a list containing seven scalar values:</p>
        <p class="Code">list=LIST('one', 2.0, 3, 4l, PTR_NEW(5), {n:6}, COMPLEX(7,0))</p>
        <p>Create a list containing two arrays:</p>
        <p class="Code">array1 = [2,3,4,5]</p>
        <p class="Code">array2 = [2.0,3.0,4.0,5.0]</p>
        <p class="Code">list1 = LIST(array1, array2)</p>
        <p class="Code">PRINT, N_ELEMENTS(list1)</p>
        <p>IDL Prints:</p>
        <p class="Code">2</p>
        <p>Create a list containing all of the elements of an array:</p>
        <p class="Code">array1 = [2,3,4,5]</p>
        <p class="Code">list2 = LIST(array1, /EXTRACT)</p>
        <p class="Code">PRINT, N_ELEMENTS(list2)</p>
        <p>IDL Prints:</p>
        <p class="Code">4</p>
        <h1 class="ObjMethod"><a name="kanchor1675"></a><a name="AddMethod"></a>List::Add</h1>
        <p>The List::Add procedure method adds elements to an existing list. In its simplest form, List::Add places a single value on the end of the specified list. The optional <i>Index</i> argument allows you to insert an element at a specific list index. When used in conjunction with the List::Remove method, List::Add makes it easy to implement a stack or queue using a LIST variable.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax">list.Add,<i>Value </i>[,&#160;<i>Index</i>] [,&#160;/EXTRACT] [,&#160;/NO_COPY]</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Value</h3>
        <p>A variable or expression of any IDL data type including !NULL.</p>
        <h3 class="Argument">Index</h3>
        <p>The zero-based index at which to insert the <i>Value</i> argument. The element that previously occupied the position specified by <i>Index</i>, and all elements that follow it, will have their index values incremented by one. If <i>Index</i> is not specified, the <i>Value</i> argument is added to the end of the list.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">EXTRACT</h3>
        <p>Normally, if the <i>Value</i> argument refers to an array or a list, that array or list is inserted into the list as a single element. If the EXTRACT keyword is specified, a <i>Value</i> argument that contains an array or a list will be disassembled, and each element of the array or list will be added to the new list as a separate element. The EXTRACT keyword has no effect if the <i>Value</i> arguments is neither an array nor a list.</p>
        <h3 class="Keyword">NO_COPY</h3>
        <p>If the NO_COPY keyword is set, the value data is taken away from the <i>Value</i> variable and attached directly to the list variable. The default behavior is to make a copy of the input values. </p>
        <h2 class="API">Examples</h2>
        <p class="Code">list = LIST(1, 2, 3)</p>
        <p class="Code">list.Add, 4</p>
        <p class="Code">PRINT, list</p>
        <p>IDL Prints:</p>
        <p class="Code">1&#160;&#160;&#160;2&#160;&#160;&#160;3&#160;&#160;&#160;4</p>
        <p class="Code">&#160;</p>
        <p class="Code">list.Add, 100, 0</p>
        <p class="Code">PRINT, list</p>
        <p>IDL Prints:</p>
        <p class="Code">100&#160;&#160;&#160;1&#160;&#160;&#160;2&#160;&#160;&#160;3&#160;&#160;&#160;4</p>
        <p class="Code">&#160;</p>
        <p class="Code">list.Add, [2.1, 2.2, 2.3], 3, /EXTRACT</p>
        <p class="Code">PRINT, list</p>
        <p>IDL Prints:</p>
        <p class="Code">100&#160;&#160;&#160;1&#160;&#160;&#160;2&#160;&#160;&#160;2.1&#160;&#160;&#160;2.2&#160;&#160;&#160;2.3&#160;&#160;&#160;3&#160;&#160;&#160;4</p>
        <h1 class="ObjMethod"><a name="kanchor1676"></a><a name="CountMethod"></a>List::Count</h1>
        <p>The List::Count function method returns the number of elements in the list. Optionally, the List::Count method can return the number of matches to a given value.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= list.Count( [<i>Value</i>] )</p>
        <h2 class="API">Return Value</h2>
        <p>By default, returns an integer containing the number of elements in the list. If <i>Value </i>is supplied, returns an integer giving the number of occurrences of <i>Value </i>within the list.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>See the <a href="#WhereMethod" class="selected">List::Where</a> method for the rules that are used for comparing values.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Value</h3>
        <p>A value to search for within the list.</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h1 class="ObjMethod"><a name="kanchor1677"></a><a name="Filter"></a>List::Filter</h1>
        <p>The List::Filter method passes each list value through a boolean filter function or <a href="LAMBDA.htm">Lambda</a> function and returns only values that pass the test.</p>
        <h2 class="API">Examples</h2>
        <p>Create a new file called <code>myfilterfunction.pro</code> that keeps only prime numbers:</p>
        <p class="Code">function myfilterfunction, value</p>
        <p class="Code_Indented">return, value le 3 || MIN(value mod [2:FIX(SQRT(value))])</p>
        <p class="Code">end</p>
        <p>Use your function to return only the prime numbers in an array:</p>
        <p class="Code">var = LIST([2:50], /EXTRACT)</p>
        <p class="Code">newvar = var.Filter('myfilterfunction')</p>
        <p class="Code">PRINT, newvar.ToArray()</p>
        <p>IDL prints:</p>
        <p class="Code">2  3  5  7 11 13 17 19 23 29 31 37 41 43 47</p>
        <p>Now use a Lambda function to avoid creating a separate routine:</p>
        <p class="Code">var = LIST([2:50], /EXTRACT)</p>
        <p class="Code">newvar = var.Filter(Lambda(n:n le 3 || MIN(n mod [2:FIX(SQRT(n))])))</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = list.Filter( <i>Function</i>, <i>Args</i> )</p>
        <h2 class="API">Return Value</h2>
        <p>The result is a list containing only the values where the filter function returned a non-zero number for that input value. If none of the values are good then the method returns an empty list.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Function</h3>
        <p>A string or Lambda expression giving the name of the user-defined function to call for each value. For user-defined functions, your function should have the form:</p>
        <p class="Code">function myfunction, value</p>
        <p class="Code_Indented">result = ...</p>
        <p class="Code_Indented">return, result</p>
        <p class="Code">end</p>
        <p>The result should be a scalar value containing a non-zero value if the input value "passes" your filter test, and a zero value if the input value "fails" your filter test.</p>
        <h3 class="Argument">Args</h3>
        <p>You can specify any number of additional arguments to be passed on to your filter or Lambda function. Each argument must be either a scalar, an array of the same length as your input, or a list of the same length as your input. For scalar arguments, ::Filter will pass in that same scalar value to each call of the filter function. For array or list arguments, ::Filter will pull out the value corresponding to the current input value and pass that into your filter function as a scalar.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="IsEmptyMethod"></a>List::IsEmpty</h1>
        <p>The List::IsEmpty function method tests whether the list is empty or not.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= list.IsEmpty( )</p>
        <h2 class="API">Return Value</h2>
        <p>Returns 1 if the list contains zero elements, and 0 otherwise.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor1678"></a><a name="Map"></a>List::Map</h1>
        <p>The List::Map method passes each list value through a user-defined function or <a href="LAMBDA.htm">Lambda</a> function.</p>
        <h2 class="API">Examples</h2>
        <p>Create a new file called <code>mymapfunction.pro</code> that returns a cubic polynomial:</p>
        <p class="Code">function mymapfunction, x, a, b, c</p>
        <p class="Code_Indented">return, (x - a)^3.0 + (x - b)^2 + (x - c)</p>
        <p class="Code">end</p>
        <p>Use your function to map a list to the new values:</p>
        <p class="Code">var = LIST([-2: 2: 0.01], /EXTRACT)</p>
        <p class="Code">; Each var value is passed in separately</p>
        <p class="Code">newvar = var.Map('mymapfunction', 1, 2, 0)</p>
        <p class="Code">print, var.ToArray(), newvar.ToArray()</p>
        <p>IDL prints:</p>
        <p class="Code">-2.00000     -1.99000     -1.98000     -1.97000     -1.96000 ...</p>
        <p class="Code">-13.0000     -12.8008     -12.6032     -12.4072     -12.2127 ...</p>
        <p>Now use a Lambda function to avoid creating a separate routine:</p>
        <p class="Code">var = LIST([-2: 2: 0.01], /EXTRACT)</p>
        <p class="Code">; Each var value is passed in separately</p>
        <p class="Code">newvar = var.Map(Lambda(x,a,b,c:(x-a)^3.0+(x-b)^2+(x-c)), 1, 2, 0)</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = list.Map( <i>Function</i>, <i>Args</i> )</p>
        <h2 class="API">Return Value</h2>
        <p>The result is a list containing the new values.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Function</h3>
        <p>A string or Lambda expression giving the name of the user-defined function to call for each value. For user-defined functions, your function should have the form:</p>
        <p class="Code">function myfunction, value</p>
        <p class="Code_Indented">result = ...</p>
        <p class="Code_Indented">return, result</p>
        <p class="Code">end</p>
        <p>The result can be a value of any type. This result will be inserted into the returned list.</p>
        <h3 class="Argument">Args</h3>
        <p>You can specify any number of additional arguments to be passed on to your user-defined function or Lambda function. Each argument must be either a scalar, array, or list of the same length as your input. For scalar arguments, ::Map will pass in that same scalar value to each call of the function. For vector arguments, ::Map will pull out the value corresponding to the current input value and pass that into your function as a scalar.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h1 class="ObjMethod"><a name="kanchor1679"></a><a name="MoveMethod"></a>List::Move</h1>
        <p>The List::Move method moves an element from one index in the list to a new index. The order of the other elements in the list remains unchanged, although their indices may be shifted, based on the location of the moved element.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax">list.Move, <i>Source</i>, <i>Destination</i></p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Source</h3>
        <p>The zero-based index of the current location of the element that will move.</p>
        <h3 class="Argument">Destination</h3>
        <p>The zero-based index of the new location where the element will move.</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h2 class="API">Example</h2>
        <p class="Code">list = LIST(0, 1, 2, 3, 4)</p>
        <p class="Code">list.Move, 1,4</p>
        <p class="Code">PRINT, list</p>
        <p>IDL&#160;prints:</p>
        <p class="Code">0, 2, 3, 4, 1</p>
        <h1 class="ObjMethod"><a name="kanchor1680"></a><a name="NestedMap"></a>List::NestedMap</h1>
        <p>The List::NestedMap method passes each list value along with up to eight other arguments through a user-defined function or <a href="LAMBDA.htm">Lambda</a> function. Each list value is combined with every element from the other arguments using a nested loop. This operation also goes by the name "list comprehension" or "Cartesian product". You can also supply an optional filter function to remove unwanted results.</p>
        <h4>Difference between Map and NestedMap</h4>
        <p>Assume we have two lists, <code>a</code> and <code>b</code>, with three elements each. For a given map function <code>F(a,b)</code>:</p>
        <p><code>a.Map(F, b)</code> returns a list containing:</p>
        <p class="Code">[F(a[0], b[0]), F(a[1], b[1]), F(a[2], b[2])]</p>
        <p><code>a.NestedMap(F, b)</code> returns a list containing:</p>
        <p class="Code">[ F(a[0], b[0]), F(a[1], b[0]), F(a[2], b[0]),</p>
        <p class="Code">&#160; F(a[0], b[1]), F(a[1], b[1]), F(a[2], b[1]),</p>
        <p class="Code">&#160; F(a[0], b[2]), F(a[1], b[2]), F(a[2], b[2]) ]</p>
        <h2 class="API">Example</h2>
        <p>Return a new list containing every combination of items from two lists:</p>
        <p class="Code">l1 = LIST('a', 'b', 'c')</p>
        <p class="Code">l2 = LIST('d', 'e', 'f')</p>
        <p class="Code">l3 = l1.NestedMap(Lambda(x,y:x+y), l2)</p>
        <p class="Code">help, l3</p>
        <p class="Code">print, l3.ToArray()</p>
        <p>IDL prints:</p>
        <p class="Code">L3              LIST  &lt;ID=15  NELEMENTS=9&gt;</p>
        <p class="Code">ad bd cd ae be ce af bf cf
</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = list.NestedMap( <i>Function</i>, <i>Args</i> , FILTER=<i>string</i>)</p>
        <h2 class="API">Return Value</h2>
        <p>The result is a list containing the new values.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Function</h3>
        <p>A string or Lambda expression giving the name of the user-defined function to call for each value. For user-defined functions, your function should have the form:</p>
        <p class="Code">function myfunction, value, arg1, arg2, ...</p>
        <p class="Code_Indented">result = ...</p>
        <p class="Code_Indented">return, result</p>
        <p class="Code">end</p>
        <p>The result can be a value of any type. This result will be inserted into the returned list.</p>
        <h3 class="Argument">Args</h3>
        <p>You can specify up to eight additional arguments. Each argument must be either a scalar, array, or list of any length. For scalar arguments, ::NestedMap will pass in that same scalar value to each call of the function. For vector arguments, ::NestedMap will perform a nested loop over all elements of that argument plus all other arguments. The nested loop is performed from left to right across the arguments, starting with the original <i>list</i> variable.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">FILTER</h3>
        <p>Set this keyword to a string or Lambda expression giving the name of a user-defined filter function. The function should have the form:</p>
        <p class="Code">function myfilter, result</p>
        <p class="Code_Indented">good = <i>some function of result...</i></p>
        <p class="Code_Indented">return, good ? 1 : 0</p>
        <p class="Code">end</p>
        <p>This function will be called for each result value. The function should return 1 (true) if the result should be added to the <i>Result</i> list, 0 (false) if the result should be discarded, or –1 if the NestedMap should stop early and return just the results up to (but not including) that result.</p>
        <h2 class="API">More Examples</h2>
        <p>Use a Lambda function to return triangles that satisfy the Pythagorean theorem. First construct a new list containing triplets of all combinations of numbers between 1 and 20:</p>
        <p class="Code">x = LIST([1:20], /EXTRACT)</p>
        <p class="Code">p = x.NestedMap(Lambda(x,y,z:[x,y,z]), x, x)</p>
        <p class="Code">help, p</p>
        <p>IDL prints:</p>
        <p class="Code">P               LIST  &lt;ID=75  NELEMENTS=8000&gt;</p>
        <p>This is not what we want. We need to keep only triplets that satisfy x^2 + y^2 = z^2. Use the FILTER keyword to keep only these values:</p>
        <p class="Code">p = x.NestedMap(Lambda(x,y,z:[x,y,z]), x, x, FILTER=Lambda(r:r[2]^2 eq r[0]^2+r[1]^2))</p>
        <p class="Code">help, p</p>
        <p class="Code">print, p[0:1] ; print the first two triplets</p>
        <p>IDL prints:</p>
        <p class="Code">P               LIST  &lt;ID=29847  NELEMENTS=12&gt;</p>
        <p class="Code">4&#160;&#160;&#160;3&#160;&#160;&#160;5</p>
        <p class="Code">3&#160;&#160;&#160;4&#160;&#160;&#160;5</p>
        <p>This still isn't what we want because it has duplicate triplets. Change the filter function to exclude duplicates:</p>
        <p class="Code">p = x.NestedMap(Lambda(x,y,z:[x,y,z]), x, x, $</p>
        <p class="Code_Indented">FILTER=Lambda(r:(r[0] le r[1]) &amp;&amp; (r[2]^2 eq r[0]^2+r[1]^2)))</p>
        <p class="Code">help, p</p>
        <p class="Code">print, p</p>
        <p>IDL prints:</p>
        <p class="Code">P               LIST  &lt;ID=29877  NELEMENTS=6&gt;</p>
        <p class="Code">3&#160;&#160;&#160;&#160;4&#160;&#160;&#160;&#160;5</p>
        <p class="Code">6&#160;&#160;&#160;&#160;8&#160;&#160;&#160;10</p>
        <p class="Code">5&#160;&#160;&#160;12&#160;&#160;&#160;13</p>
        <p class="Code">9&#160;&#160;&#160;12&#160;&#160;&#160;15</p>
        <p class="Code">8&#160;&#160;&#160;15&#160;&#160;&#160;17</p>
        <p class="Code">12&#160;&#160;16&#160;&#160;&#160;20</p>
        <h1 class="ObjMethod"><a name="kanchor1681"></a><a name="Reduce"></a>List::Reduce</h1>
        <p>The List::Reduce method passes each data value cumulatively from left to right through a user-defined function or <a href="LAMBDA.htm">Lambda</a> function and returns a single scalar result.</p>
        <h2 class="API">Examples</h2>
        <p>Create a new file called <code>myreducefunction.pro</code> that adds up arrays (or concatenates strings):</p>
        <p class="Code">function myreducefunction, accumvalue, value</p>
        <p class="Code_Indented">return, accumvalue + value</p>
        <p class="Code">end</p>
        <p>Use your function on a string array:</p>
        <p class="Code">var = LIST('IDL', ' ', 'is', ' ', 'fun', '!')</p>
        <p class="Code">newvar = var.Reduce('myreducefunction')</p>
        <p class="Code">PRINT, newvar</p>
        <p>IDL prints:</p>
        <p class="Code">IDL is fun!</p>
        <p>Now use a Lambda function to avoid creating a separate routine:</p>
        <p class="Code">var = LIST('IDL', ' ', 'is', ' ', 'fun', '!')</p>
        <p class="Code">newvar = var.Reduce(Lambda(x,y:x+y))</p>
        <p>Finally, use the /CUMULATIVE to return all of the intermediate results:</p>
        <p class="Code">newvar = var.Reduce(Lambda(x,y:x+y), /CUMULATIVE)</p>
        <p class="Code">PRINT, newvar, /IMPLIED</p>
        <p>IDL prints:</p>
        <p class="Code">[</p>
        <p class="Code_Indented">"IDL",</p>
        <p class="Code_Indented">"IDL ",</p>
        <p class="Code_Indented">"IDL is",</p>
        <p class="Code_Indented">"IDL is ",</p>
        <p class="Code_Indented">"IDL is fun",</p>
        <p class="Code_Indented">"IDL is fun!"</p>
        <p class="Code">]</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = list.Reduce( <i>Function</i>, <i>Args</i>, /CUMULATIVE, VALUE=<i>value</i>)</p>
        <h2 class="API">Return Value</h2>
        <p>The result is a scalar value containing the cumulative result. The data type of the result will depend upon your calling function's result type.</p>
        <p>If your input contains a single element then this value will be returned as the result without calling the function, unless the VALUE keyword is set, in which case the function will be called once.</p>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>You can use the /CUMULATIVE keyword to return all of the intermediate results instead of just the final result.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Function</h3>
        <p>A string or Lambda expression giving the name of the user-defined function to call for each value. For user-defined functions, your function should have the form:</p>
        <p class="Code">function myfunction, accumvalue, value</p>
        <p class="Code_Indented">result = ...</p>
        <p class="Code_Indented">return, result</p>
        <p class="Code">end</p>
        <p>The result should be a scalar value that combines the current accumulated value (the first argument) and the current input value (the second argument).</p>
        <h3 class="Argument">Args</h3>
        <p>You can specify any number of additional arguments to be passed on to your user-define function or Lambda function. Each argument must be either a scalar or an array of the same length as your input. For scalar arguments, ::Reduce will pass in that same scalar value to each call of the filter function. For vector arguments, ::Reduce will pull out the value corresponding to the current input value and pass that into your function as a scalar.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">CUMULATIVE</h3>
        <p>If this keyword is set, then the <i>Result</i> will be a list containing all of the intermediate cumulative results instead of just the final result.</p>
        <h3 class="Keyword">VALUE</h3>
        <p>Set this keyword to the starting value. If this keyword is set then this value will be passed into your function along with the first element of your input. If this keyword is not set then the first two elements will be passed into your function.</p>
        <h1 class="ObjMethod"><a name="kanchor1682"></a><a name="RemoveMethod"></a>List::Remove</h1>
        <p>The List::Remove method removes elements from a list and optionally returns the removed value.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax">list.Remove [, /ALL]</p>
        <p>or</p>
        <p class="Syntax">list.Remove,&#160;<i>Indices</i></p>
        <p>or</p>
        <p class="Syntax"><i>Value</i> = list.Remove(  [,&#160;/ALL] )</p>
        <p>or</p>
        <p class="Syntax"><i>Value</i> = list.Remove( <i>Indices</i> )</p>
        <h2 class="API">Return Value </h2>
        <p>If List::Remove( ) is called with no arguments then the last element is removed and returned.</p>
        <p>If List::Remove( ) is called with a single <i>Index</i>, it returns the value of the specified element.</p>
        <p>If List::Remove( ) is called with multiple <i>Indices</i> (or the ALL keyword), it returns a new list containing the specified elements.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If the list is empty, calling the List::Remove() function method will throw an error (unless <i>Indices</i> is equal to <a href="../../Creating IDL Programs/Components of the IDL Language/The_Null_Variable.htm">!NULL</a>). The List::Remove procedure method will quietly return.</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Indices</h3>
        <p>A scalar index or array of indices of list elements to be removed. If no <i>Indices</i> are supplied, the last element is removed. If <i>Indices</i> is equal to <a href="../../Creating IDL Programs/Components of the IDL Language/The_Null_Variable.htm">!NULL</a> then nothing is removed and !NULL&#160;is returned from the function call.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">ALL</h3>
        <p>Set this keyword to remove all entries in <i>List</i>, leaving the list empty, but still in existence.</p>
        <h2 class="API">Examples</h2>
        <p>Create a list and print its contents:</p>
        <p class="Code">list = LIST(98.6, 'narwhal', [2, 4, 6, 8], COMPLEX(3,3))</p>
        <p class="Code">PRINT, list</p>
        <p>IDL Prints:</p>
        <p class="Code">&#160;&#160;&#160;&#160;98.6</p>
        <p class="Code">narwhal</p>
        <p class="Code">&#160;&#160;&#160;&#160;2&#160;4&#160;6&#160;8</p>
        <p class="Code">( 3.00000, 3.00000)</p>
        <p>Now delete some list elements and print the contents again:</p>
        <p class="Code">list.Remove, [1, 3]</p>
        <p class="Code">PRINT, list</p>
        <p>IDL Prints:</p>
        <p class="Code">&#160;&#160;&#160;&#160;98.6</p>
        <p class="Code">&#160;&#160;&#160;&#160;2&#160;4&#160;6&#160;8</p>
        <p>Show the number of elements in the list:</p>
        <p class="Code">PRINT, N_ELEMENTS(list)</p>
        <p>IDL Prints:</p>
        <p class="Code">&#160;&#160;&#160;&#160;2</p>
        <p>Now remove the last element off the list, printing the removed value:</p>
        <p class="Code">PRINT, list.Remove()</p>
        <p>IDL Prints:</p>
        <p class="Code">&#160;&#160;&#160;&#160;2&#160;4&#160;6&#160;8</p>
        <h1 class="ObjMethod"><a name="kanchor1683"></a><a name="ReverseMethod"></a>List::Reverse</h1>
        <p>The List::Reverse procedure method reverses the order of elements in a list.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax">list.Reverse</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <p>None.</p>
        <h2 class="API">Examples</h2>
        <p>Create a list, then reverse it and print its contents:</p>
        <p class="Code">list = LIST(98.6, 'narwhal', [2, 4, 6, 8], COMPLEX(3,3))</p>
        <p class="Code">list.Reverse</p>
        <p class="Code">PRINT, list</p>
        <p>IDL Prints:</p>
        <p class="Code">( 3.00000, 3.00000)</p>
        <p class="Code">&#160;&#160;&#160;&#160;2&#160;4&#160;6&#160;8</p>
        <p class="Code">narwhal</p>
        <p class="Code">&#160;&#160;&#160;&#160;98.6</p>
        <h1 class="ObjMethod"><a name="kanchor1684"></a><a name="SortMethod"></a>List::Sort</h1>
        <p>The List::Sort method sorts all of the list elements and returns a new list.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax">result = list.Sort( COMPARE_FUNCTION=<i>string</i>, COUNT=<i>integer</i>, INDICES=<i>variable</i>, /OVERWRITE, /REVERSE )</p>
        <h2 class="API">Arguments</h2>
        <p>None</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">COMPARE_FUNCTION</h3>
        <p>A string or <a href="LAMBDA.htm">Lambda function</a> giving the name of a user-defined "compare" function. The function should have the form:</p>
        <p class="Code">function myfunc, value1, value2</p>
        <p>The function should return –1 if <code>value1</code> should be considered "less than" <code>value2</code>, +1 if <code>value1</code> is "greater than" <code>value2</code>, or 0 if the two list elements are "equal". By default, the ::Sort method uses IDL's standard rules for comparing values.</p>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>The <a href="../Static Methods/IDL_Variable.htm#Compare">IDL_Variable::Compare</a> method may be helpful when constructing compare functions. See the examples below.</p>
        <h3 class="Keyword">COUNT</h3>
        <p>Set this keyword to an integer giving the number of elements to sort. You can use this keyword to sort just the first part of the list.</p>
        <h3 class="Keyword">INDICES</h3>
        <p>Set this keyword to a named variable. On return this variable will contain a one-dimensional integer array of subscripts that were used to sort the original values.</p>
        <h3 class="Keyword">OVERWRITE</h3>
        <p>Set this keyword to replace the contents of the list with the sorted result. This avoids creating a new list and can save a significant amount of memory.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>The result will be a reference to the original list. If you assign this result to a new variable then both the new variable and the original variable will point to the same list.</p>
        <h3 class="Keyword">REVERSE</h3>
        <p>Set this keyword to sort the list in reverse order.</p>
        <h2 class="API">Example</h2>
        <h6>Simple sort</h6>
        <p>Do a simple sort of an integer list:</p>
        <p class="Code">list = LIST(0, 4, 2, 1, 5)</p>
        <p class="Code">result = list.Sort( )</p>
        <p class="Code">PRINT, result</p>
        <p>IDL prints:</p>
        <p class="Code">0 1 2 4 5</p>
        <h6>Sort with a compare function</h6>
        <p>Now define a list of structures, and use a compare function to sort on one of the structure keys. Here we will use the <a href="../Static Methods/IDL_Variable.htm#Compare">IDL_Variable::Compare</a> method to perform the comparison. First create a named structure and construct a list of these structures:</p>
        <p class="Code">void = {Planet, NAME: "", MASS: 0.0}</p>
        <p class="Code">p = LIST({Planet, "Earth", 1}, {Planet, "Mercury", 0.055}, $</p>
        <p class="Code_Indented">{Planet, "Venus", 0.815}, {Planet, "Mars", 0.107})</p>
        <p>Now create the compare function:</p>
        <p class="Code">function struct_compare, v1, v2</p>
        <p class="Code_Indented">; Return -1, 0, or 1 depending upon the name field</p>
        <p class="Code_Indented">return, (v1.NAME).Compare(v2.NAME)</p>
        <p class="Code">end</p>
        <p>Now do the sort:</p>
        <p class="Code">result = p.Sort(COMPARE_FUNCTION='struct_compare')</p>
        <p class="Code">PRINT, result</p>
        <p>IDL prints:</p>
        <p class="Code">{ Earth      1.00000}</p>
        <p class="Code">{ Mars     0.107000}</p>
        <p class="Code">{ Mercury    0.0550000}</p>
        <p class="Code">{ Venus     0.815000}</p>
        <h6>Sort using a Lambda function</h6>
        <p>Now sort on the planet mass, but use a Lambda function:</p>
        <p class="Code">result = p.Sort(COMPARE_FUNCTION=Lambda(a,b:(a.MASS).Compare(b.MASS)))</p>
        <p class="Code">PRINT, result</p>
        <p>IDL prints:</p>
        <p class="Code"> { Mercury    0.0550000}</p>
        <p class="Code">{ Mars     0.107000}</p>
        <p class="Code">{ Venus     0.815000}</p>
        <p class="Code">{ Earth      1.00000}</p>
        <h1 class="ObjMethod"><a name="kanchor1685"></a><a name="SwapMethod"></a>List::Swap</h1>
        <p>The List::Swap method swaps two elements in the list. The order and indices of all other elements in the list remain unchanged.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax">list.Swap, <i>Index1</i>, <i>Index2</i></p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Index1</h3>
        <p>The zero-based index of the first element to swap.</p>
        <h3 class="Argument">Index2</h3>
        <p>The zero-based index of the second element to swap.</p>
        <h2 class="API">Keywords</h2>
        <p>None</p>
        <h2 class="API">Example</h2>
        <p class="Code">list = LIST(0, 1, 2, 3, 4)</p>
        <p class="Code">list.Swap, 1, 4</p>
        <p class="Code">PRINT, list</p>
        <p>IDL prints:</p>
        <p class="Code">0, 4, 2, 3, 1</p>
        <h1 class="ObjMethod"><a name="kanchor1686"></a><a name="ToArrayMethod"></a>List::ToArray</h1>
        <p>The List::ToArray function method returns an array containing all of the list values, converted to a single data type. The TYPE keyword may be used to control the result type, while the MISSING keyword may be used to control the behavior for missing or illegal values.</p>
        <p>If the list contains all scalar values then the result will be a vector with the same number of elements as the list. If the list contains arrays of the same shape then the result will be an array of one higher dimension, where the first dimension will contains the same number of elements as the list, and the higher dimensions will match the array dimensions. For example, if the list contains 5 elements, each of which is a [10, 20] array, then the List::ToArray method will return a [5,&#160;10,&#160;20] array.</p>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>The DIMENSION keyword may be used to concatenate list elements instead of creating an array of a higher dimension.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If the list contains only one element, and it is a scalar, then the result will be a 1-element array.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If the list contains only one element, and it is an array, then the result will be an array where the first dimension is 1. For example, if the list contains a single vector of length 100, then the result will be an array of dimensions [1,&#160;100]. If you also use the /TRANSPOSE keyword then the trailing dimension of 1 will be dropped, and the result will simply be an array of the same dimensions as the list element.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax">Result = list.ToArray( DIMENSION=<i>value</i>, MISSING=<i>value</i>, /NO_COPY, /PROMOTE_TYPE, /TRANSPOSE, TYPE=<i>value</i> )</p>
        <h2 class="API">Return Value </h2>
        <p>The result is an array containing all of the list values, converted to the same IDL data type. If the list is empty then !NULL&#160;is returned.</p>
        <h2 class="API">Arguments</h2>
        <p>None.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">DIMENSION</h3>
        <p>Set this keyword to the dimension over which to concatenate the arrays contained within the list. For this keyword to work correctly, each element of the list must have the same number of elements in each dimension except for the dimension given by DIMENSION. For example, assume your list contains three arrays and you wish to concatenate over the second dimension: </p>
        <p class="Code">l = LIST(FLTARR(3,10,5), FLTARR(3,12,5), FLTARR(3,7,5))</p>
        <p class="Code">result = l.ToArray(DIMENSION=2)</p>
        <p class="Code">help, result</p>
        <p>IDL prints:</p>
        <p class="Code">RESULT          FLOAT     = Array[3, 29, 5]</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span> If the DIMENSION keyword is specified, the MISSING and TRANSPOSE keywords are ignored.</p>
        <h3 class="Keyword">MISSING</h3>
        <p>Set this keyword to a value of the same type as the returned result. The default behavior of the List::ToArray method is to throw an error if a list element cannot be converted to the desired data type. If MISSING is set, and a list element cannot be converted, then the MISSING value is returned for that element. If the list contains arrays instead of scalars then MISSING may either be a scalar (in which case every element of a missing sub-array is set to that value) or MISSING may be an array of the same dimensions as the arrays within the list.</p>
        <h3 class="Keyword">NO_COPY</h3>
        <p>Set this keyword to move each element from the list to the output array. When finished, the list will be empty.</p>
        <h3 class="Keyword">PROMOTE_TYPE</h3>
        <p>By default, the data type of the result is just the type of the first element in the list (unless TYPE is set). Set the PROMOTE_TYPE keyword to true (1) to examine every element in the list to find the "highest" type. The ::ToArray method will set the result to this data type and will convert all of the result values to this type. When determining which of two data types is "higher", List::ToArray uses the following rules from top-to-bottom (stopping when a rule is matched):</p>
        <ul>
            <li value="1">STRING + any lower type = STRING</li>
            <li value="2">DCOMPLEX + any lower type = DCOMPLEX</li>
            <li value="3">DOUBLE + COMPLEX = DCOMPLEX</li>
            <li value="4">DOUBLE + any lower type = DOUBLE</li>
            <li value="5">COMPLEX + any lower type = COMPLEX</li>
            <li value="6">FLOAT + any lower type = FLOAT</li>
            <li value="7">LONG64 + any lower type = LONG64</li>
            <li value="8">ULONG64 + any lower type = ULONG64</li>
            <li value="9">LONG + any lower type = LONG</li>
            <li value="10">ULONG + any lower type = ULONG</li>
            <li value="11">INT + any lower type = INT</li>
            <li value="12">UINT + any lower type = UINT</li>
            <li value="13">BYTE + any lower type = BYTE</li>
            <li value="14">POINTER + any lower type = POINTER</li>
            <li value="15">OBJREF + any lower type = OBJREF</li>
            <li value="16">STRUCTURE + STRUCTURE = STRUCTURE</li>
        </ul>
        <h3 class="Keyword">TRANSPOSE</h3>
        <p>If the list contains arrays instead of scalars, then the default behavior is to have the first dimension contain the number of list elements. Set this keyword to transpose the resulting array so that the last dimension contains the list elements. For example, if the list contains 5 elements, each of which is a [10,&#160;20] array, then by default the List::ToArray method will return a [5,&#160;10,&#160;20] array. If TRANSPOSE is set then the result will be a [10,&#160;20,&#160;5] array.</p>
        <h3 class="Keyword">TYPE</h3>
        <p>Set this keyword to an integer or a string giving the IDL type code of the result array. All values within the list will then be converted to this type. The default behavior is to use the type of the first element in the list.</p>
        <h2 class="API">Examples</h2>
        <h4>Mixed Data Types</h4>
        <p>Create a list of mixed types, then return an array of a single type:</p>
        <p class="Code">list = LIST(1, 2uL, 3.14, COMPLEX(4))</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Default behavior is to return the same type as the first element</p>
        <p class="Code">arr = list.ToArray()</p>
        <p class="Code">&#160;</p>
        <p class="Code">HELP, arr</p>
        <p class="Code">PRINT, arr</p>
        <p>IDL prints:</p>
        <p class="Code">ARR&#160;&#160;&#160;&#160;&#160;         INT       = Array[4]</p>
        <p class="Code">1      2       3       4</p>
        <p>Now force the data type:</p>
        <p class="Code">list = LIST(1, 2uL, 3.14, COMPLEX(4))</p>
        <p class="Code">arr = list.ToArray(TYPE='FLOAT')</p>
        <p class="Code">HELP, arr</p>
        <p class="Code">PRINT, arr</p>
        <p>IDL prints:</p>
        <p class="Code">ARR&#160;&#160;&#160;&#160;&#160;FLOAT     = Array[4]</p>
        <p class="Code">1.00000      2.0000      3.14000      4.00000</p>
        <p>Now use PROMOTE_TYPE to pick the "highest" type:</p>
        <p class="Code">list = LIST(1, 2uL, 3.14, COMPLEX(4))</p>
        <p class="Code">arr = list.ToArray(/PROMOTE_TYPE)</p>
        <p class="Code">HELP, arr</p>
        <p class="Code">PRINT, arr</p>
        <p>IDL prints:</p>
        <p class="Code">ARR             COMPLEX   = Array[4]</p>
        <p class="Code">(      1.00000,     0.000000)(      2.00000,     0.000000)(      3.14000,     0.000000)(      4.00000,     0.000000)</p>
        <h4>Missing Values</h4>
        <p>Now add some non-numeric values, and use the MISSING keyword:</p>
        <p class="Code">list = LIST(1, 'oops', 3.14, !NULL)</p>
        <p class="Code">&#160;</p>
        <p class="Code">arr = list.ToArray(TYPE='INT', MISSING=-99)</p>
        <p class="Code">&#160;</p>
        <p class="Code">HELP, arr</p>
        <p class="Code">PRINT, arr</p>
        <p>IDL prints:</p>
        <p class="Code">ARR             INT       = Array[4]</p>
        <p class="Code">1     -99       3     -99</p>
        <p class="Code">&#160;</p>
        <p>Create a list of arrays, then return an array of higher dimension:</p>
        <p class="Code">list = LIST(FINDGEN(10), INDGEN(10), BYTARR(10))</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Default behavior is to return the same type as the first element</p>
        <p class="Code">HELP, list.ToArray()</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Now use the TRANSPOSE keyword to flip the dimensions</p>
        <p class="Code">HELP, list.ToArray(/TRANSPOSE)</p>
        <p>IDL prints:</p>
        <p class="Code">ARR&#160;&#160;&#160;&#160;&#160;         FLOAT      = Array[3, 10]</p>
        <p class="Code">ARR&#160;&#160;&#160;&#160;&#160;         FLOAT      = Array[10, 3]</p>
        <h4>Array Concatenation</h4>
        <p>Use the DIMENSION keyword to speed up array concatenation:</p>
        <p class="Code">; First use standard array concatenation,</p>
        <p class="Code">; building up a new array one chunk at a time.</p>
        <p class="Code">tic</p>
        <p class="Code">vertices = [ ]</p>
        <p class="Code">for i=0,9999 do begin &amp; $</p>
        <p class="Code_Indented">n = 10 + FIX(10*RANDOMU(seed)) &amp; $</p>
        <p class="Code_Indented">vert1 = RANDOMU(seed, 3, n) &amp; $</p>
        <p class="Code_Indented">vertices = [[vertices], [vert1]] &amp; $</p>
        <p class="Code">endfor</p>
        <p class="Code">HELP, vertices</p>
        <p class="Code">toc</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Now use ::ToArray to do the concatenation.</p>
        <p class="Code">tic</p>
        <p class="Code">vertexList = LIST()</p>
        <p class="Code">for i=0,9999 do begin &amp; $</p>
        <p class="Code_Indented">n = 10 + FIX(10*RANDOMU(seed)) &amp; $</p>
        <p class="Code_Indented">vert1 = RANDOMU(seed, 3, n) &amp; $</p>
        <p class="Code_Indented">vertexList.Add, vert1 &amp; $</p>
        <p class="Code">endfor</p>
        <p class="Code">vertices = vertexList.ToArray(DIMENSION=2)</p>
        <p class="Code">HELP, vertices</p>
        <p class="Code">toc</p>
        <p>IDL prints:</p>
        <p class="Code">VERTICES        FLOAT     = Array[3, 144747]</p>
        <p class="Code">% Time elapsed: 1.8260000 seconds.</p>
        <p class="Code">&#160;</p>
        <p class="Code">VERTICES        FLOAT     = Array[3, 145240]</p>
        <p class="Code">% Time elapsed: 0.20199990 seconds.</p>
        <p>Notice that using LIST concatenation is significantly faster than reallocating and copying the array each time through the loop.</p>
        <h1 class="ObjMethod"><a name="kanchor1687"></a><a name="WhereMethod"></a>List::Where</h1>
        <p>The List::Where function method returns an array of indices for those list elements that are equal to a certain value.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>The method call <code>list.Where(Value)</code> is equivalent to calling <code>WHERE(list EQ Value)</code>, and is simply provided as a programming convenience.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= list.Where( <i>Value </i>[, <a href="#COMPLEME" class="selected">COMPLEMENT</a>=<i>variable</i>] [, <a href="#COUNT" class="selected">COUNT</a>=<i>variable</i>] [, <a href="#NCOMPLEM" class="selected">NCOMPLEMENT</a>=<i>variable</i>] )</p>
        <h2 class="API">Return Value</h2>
        <p>Returns an array of integers containing the list subscripts. If there are no matches, !NULL is returned. The following rules are used when comparing values:</p>
        <ul>
            <li value="1">If <i>Value </i>is a scalar number or string, the corresponding list element must be equal to the same value (although the types may differ).</li>
            <li value="2">If <i>Value </i>is an array, the corresponding list element must be an array of the same length, with identical values (although the types may differ).</li>
            <li value="3">If <i>Value </i>is a pointer or object, the corresponding list element must be the same pointer or object reference.</li>
            <li value="4">If <i>Value </i>is a structure, it is compared to the corresponding list element on a tag-by-tag basis (including nested structures) using the same rules as above.</li>
            <li value="5">If <i>Value </i>is another list, the two lists are compared on an element-by-element basis (using the above rules), and the result is an array of integers containing the list subscripts where the values are equal. If the lists are not the same length then the shortest length is used.</li>
        </ul>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Value</h3>
        <p>A variable or expression of any IDL data type, including !NULL.</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword"><a name="COMPLEME"></a>COMPLEMENT</h3>
        <p>Set this keyword to a named variable that will return an array of integers containing the list subscripts that do not contain the value.</p>
        <h3 class="Keyword"><a name="COUNT"></a>COUNT</h3>
        <p>Set this keyword to a named variable that will return the number of matches.</p>
        <h3 class="Keyword"><a name="NCOMPLEM"></a>NCOMPLEMENT</h3>
        <p>Set this keyword to a named variable that will return the number of indices within the COMPLEMENT array.</p>
        <h2 class="API">Examples</h2>
        <p>The following example generates a random integer and an array of ten random integers (both between 0 and 9). The sample uses Where to determine if there are any matches of the value in the list.</p>
        <p class="Code">rndmVal = FIX(10 * RANDOMU(seed, 1))</p>
        <p class="Code">rndmArr = FIX(10 * RANDOMU(seed, 10))</p>
        <p class="Code">l = LIST(rndmArr, /EXTRACT)</p>
        <p class="Code">matches = l.Where(rndmVal)</p>
        <p class="Code">PRINT, 'Random value = ', rndmVal</p>
        <p class="Code">PRINT, 'Random array = ', rndmArr</p>
        <p class="Code">PRINT, 'Matching indices = ', matches</p>
        <p>Sample output:</p>
        <p class="Code">Random value =        7</p>
        <p class="Code">Random array =        6       9       4       7       2       5       9       5       7       8</p>
        <p class="Code">Matching indices =            3           8</p>
        <h1>Additional Information on Lists</h1>
        <h2 class="API"><a name="Concaten"></a>Concatenating Lists</h2>
        <p>To combine two lists to make a new list, use the + operator:</p>
        <p class="Code">list1 = LIST('zero', 1, 2.0)</p>
        <p class="Code">list2 = LIST(!PI, COMPLEX(4,4), [5,5,5,5,5])</p>
        <p class="Code">list3 = list1 + list2</p>
        <p class="Code">PRINT, list3</p>
        <p>IDL Prints:</p>
        <p class="Code">zero</p>
        <p class="Code">&#160;&#160;&#160;&#160;&#160;1</p>
        <p class="Code">&#160;&#160;&#160;&#160;&#160;2.00000</p>
        <p class="Code">&#160;&#160;&#160;&#160;&#160;3.14159</p>
        <p class="Code">( &#160;&#160;&#160;4.00000,&#160;&#160;4.00000)</p>
        <p class="Code">&#160;&#160;&#160;&#160;&#160;5&#160;&#160;&#160;&#160;&#160;5&#160;&#160;&#160;&#160;&#160;5&#160;&#160;&#160;&#160;&#160;5&#160;&#160;&#160;&#160;&#160;5</p>
        <p>Note that</p>
        <p class="Code">list3 = list1 + list2</p>
        <p>is exactly equivalent to:</p>
        <p class="Code">list3 = LIST()</p>
        <p class="Code">list3.Add, list1, /EXTRACT</p>
        <p class="Code">list3.Add, list2, /EXTRACT</p>
        <h2 class="API"><a name="Comparin"></a>Comparing Lists</h2>
        <h3>EQ</h3>
        <p>The <a href="../../Creating IDL Programs/Components of the IDL Language/Relational_Operators.htm">EQ operator</a> does an element-by-element comparison. The operator syntax is <i>list1</i> EQ <i>list2</i>, and EQ returns a byte array of 1s (the elements are equal) or 0s (the elements are not equal). The length of the result is the length of the shortest list. If both lists are empty lists, the scalar value 1 is returned.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>See the <a href="#WhereMethod" class="selected">List::Where</a> method for the rules that are used for comparing values.</p>
        <p>To compare two lists:</p>
        <p class="Code">list1 = LIST('alpha', 5, 19.9)</p>
        <p class="Code">list2 = LIST('alpha', 'abc', 19.9)</p>
        <p class="Code">PRINT, list1 EQ list2</p>
        <p>IDL Prints:</p>
        <p class="Code">1 0 1</p>
        <p>When comparing each element of a list with a value (a scalar or array of any type) of the form <i>list</i> EQ <i>value</i>, the EQ operator returns a byte array of 1s or 0s. The length of the result is the length of the list. If the list is an empty list, the scalar value 0 is returned.</p>
        <p>To compare a list with a scalar value:</p>
        <p class="Code">list3 = LIST('beta', 99, 300.73)</p>
        <p class="Code">value = 99</p>
        <p class="Code">PRINT, list3 EQ value</p>
        <p>IDL Prints:</p>
        <p class="Code">0 1 0</p>
        <p>To compare a list with an array:</p>
        <p class="Code">list4 = LIST(3, 7, 9, 12, [4, 33, 9, 64, 43], 'alpha')</p>
        <p class="Code">array = [4, 33, 9, 64, 43]</p>
        <p class="Code">PRINT, list4 EQ array</p>
        <p>IDL Prints:</p>
        <p class="Code">0 0 0 0 1 0</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>IDL treats the array as a single item for the comparison.</p>
        <h3>NE</h3>
        <p>The <a href="../../Creating IDL Programs/Components of the IDL Language/Relational_Operators.htm">NE operator</a> behaves in the opposite manner of EQ. Instead of returning the byte value 1 for a match, NE returns the byte value 1 if two list elements are not a match.</p>
        <h2 class="API"><a name="List"></a>List Access</h2>
        <p>In many cases, you can access elements of a list variable using standard IDL array syntax, as if the list were a one-dimensional array.</p>
        <h3><a name="lists_3331144781_998687"></a>Retrieve a Single Element</h3>
        <p>To copy the value of a single list element into a new variable, leaving the list unchanged, use array syntax:</p>
        <p class="Code">value = list[<i>Index</i>]</p>
        <p>where <i>Index</i> is the zero-based index of the desired element within the list. Negative indices may be used to index from the end. For example, <code>list[-1]</code> would retrieve the last element.</p>
        <p>To retrieve the last element in a list and remove it, use the list.Remove function method:</p>
        <p class="Code">value = list.Remove()</p>
        <p>To retrieve a specific element in a list and remove it:</p>
        <p class="Code">value = list.Remove(<i>Index</i>)</p>
        <p>where <i>Index</i> is the zero-based index of the desired element within the list.</p>
        <h3><a name="lists_3331144781_998773"></a>Insert a Single Element</h3>
        <p>To insert a single value at the end of a list, creating a new list element, use the list.Add method:</p>
        <p class="Code">list.Add, Value</p>
        <p>where <i>Value</i> is the value to be stored in the new list element.</p>
        <p>To insert a single value at a specified position within a list:</p>
        <p class="Code">list.Add, <i>Value</i>, <i>Index</i></p>
        <p>where <i>Value</i> is the value to be stored in the new list element, and <i>Index</i> is the zero-based index of the position at which the element should be inserted.</p>
        <h3><a name="lists_3331144781_998838"></a>Change the Value of a Single Element</h3>
        <p>To change the value of a single list element, use array syntax:</p>
        <p class="Code">list[<i>Index</i>] = <i>Value</i></p>
        <p>where <i>Index</i> is the zero-based index of the desired element within the list and <i>Value</i> is the new value.</p>
        <h3><a name="lists_3331144781_998763"></a>Create a Sub-list</h3>
        <p>To create a new list that is a subset of an existing list, use array syntax:</p>
        <p class="Code">newList = origList[ [Index<sub>0</sub>, Index<sub>1</sub>, ..., Index<sub>n-1</sub>] ]</p>
        <p>Here <code>newList</code> is a new list variable that contains copies of the elements from <code>origList</code> specified by the indices <code>Index<sub>0</sub>, Index<sub>1</sub>, ..., Index<sub>n-1</sub></code>.</p>
        <p>You can also create a sub-list using the array minimum and maximum index syntax:</p>
        <p class="Code">newList = origList[minIndex:maxIndex]</p>
        <p>For example:</p>
        <p class="Code">newList = origList[4:8]</p>
        <p>would create a new list variable consisting of the fifth through ninth elements of <code>origList</code>.</p>
        <p>Similarly, you can use the minimum, maximum, and stride syntax:</p>
        <p class="Code">newList = origList[minIndex:maxIndex:stride]</p>
        <p>For example:</p>
        <p class="Code">newList = origList[3:15:3]</p>
        <p>would create a new list variable consisting of elements 3, 6, 9, 12, and 15 of <code>origList</code>.</p>
        <h3><a name="lists_3331144781_998767"></a>Insert Multiple Elements</h3>
        <p>To insert multiple elements into an existing list, use list.Add with an array or list as the argument, and set the EXTRACT keyword. By default, elements are inserted at the end of the list; include the <i>Index</i> argument to specify where in the list the new elements should be inserted:</p>
        <p class="Code">list.Add, array, /EXTRACT</p>
        <p class="Code">list.Add, otherList, /EXTRACT</p>
        <p class="Code">list.Add, otherList, Index, /EXTRACT</p>
        <p>For example:</p>
        <p class="Code">list.Add, [2,3,6,8], /EXTRACT</p>
        <p>inserts four integers at the end of <code>list</code>.</p>
        <p>Similarly, to insert the values from another list at the beginning of the target list:</p>
        <p class="Code">subList = LIST('zero', 1, 2.0)</p>
        <p class="Code">list.Add, subList, 0, /EXTRACT</p>
        <p>Here, the string <code>'zero'</code>, the integer <code>1</code>, and the floating point number <code>2.0</code> are inserted into <code>list</code> as the first three elements.</p>
        <h3><a name="lists_3331144781_998841"></a>Change the Value of Multiple Elements</h3>
        <p>Change the value of multiple list elements in a single operation by specifying the indices to be replaced in the existing list and providing the replacement values in another list:</p>
        <p class="Code">list[[Index<sub>1</sub>, Index<sub>2</sub>, ..., Index<sub>n</sub>]] = otherList</p>
        <p class="Code">&#160;</p>
        <p class="Code">list[minIndex:maxIndex] = otherList</p>
        <p class="Code">&#160;</p>
        <p class="Code">list[minIndex:maxIndex:stride] = otherList</p>
        <p>Note that the expressions on the left and right sides of the equals sign must specify the same number of elements.</p>
        <h3><a name="lists_3331144781_998769"></a>Copy a List</h3>
        <p>To copy a list reference, simply assign it to a new variable:</p>
        <p class="Code">newList = origList</p>
        <p>It is important to understand that with this operation, <code>newList</code> and <code>origList</code> are references to the same list; modifying an element in one list modifies the same element in the other list. For example, if we create <code>list2</code> as a copy of <code>list1</code> and then change the value of an element in <code>list2</code>, the same element in <code>list1</code> also changes:</p>
        <p class="Code">list1 = LIST('zero', 1, 2.0)</p>
        <p class="Code">list2 = list1</p>
        <p class="Code">list2[0] = 0L</p>
        <p class="Code">HELP, list1[0], list2[0]</p>
        <p>IDL Prints:</p>
        <p class="Code">&lt;Expression&gt;    LONG      = &#160;0</p>
        <p class="Code">&lt;Expression&gt;    LONG      = &#160;0</p>
        <p>Note that both lists contain the new value for the first element.</p>
        <p>To create a new list variable whose elements are copies of the values in the original list, use array syntax to copy all of the elements of the original list:</p>
        <p class="Code">newList = origList[*]</p>
        <p>For example:</p>
        <p class="Code">list1 = LIST('zero', 1, 2.0)</p>
        <p class="Code">list2 = list1[*]</p>
        <p class="Code">list2[0] = 0l</p>
        <p class="Code">HELP, list1[0], list2[0]</p>
        <p>IDL Prints:</p>
        <p class="Code">&lt;Expression&gt;    STRING    = 'zero'</p>
        <p class="Code">&lt;Expression&gt;    LONG      = &#160;0</p>
        <p>Note that the value in <code>list1</code> remains unchanged.</p>
        <h3><a name="lists_3331144781_998822"></a>Iterate Through a List</h3>
        <p>To iterate through the elements in a list, use a loop and standard array syntax to index each list element:</p>
        <p class="Code">FOR i = 0, N_ELEMENTS(list)-1 DO BEGIN</p>
        <p class="Code">&#160;&#160;&#160;; do something with each element</p>
        <p class="Code">&#160;&#160;&#160;PRINT, list[i]</p>
        <p class="Code">ENDFOR</p>
        <p>For example:</p>
        <p class="Code">list = LIST('zero', 1, 2.0)<br />FOR i=0, N_ELEMENTS(list)-1 DO PRINT, list[i]</p>
        <p>&#160;</p>
        <p>You may also use FOREACH to iterate over the list elements:</p>
        <p class="Code">&#160;</p>
        <p class="Code">  list = LIST(77.97, 'Galactic', [2, 7, 1, 8, 2])</p>
        <p class="Code">  FOREACH element, list DO BEGIN</p>
        <p class="Code">    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PRINT, 'Element = ', element</p>
        <p class="Code">  ENDFOREACH</p>
        <p class="Code">&#160;</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>While iterating through a list you should avoid adding or removing elements. If the list is changed during the FOREACH, the behavior  is undefined.</p>
        <h3><a name="Access"></a>Access and Change Array Elements within a List</h3>
        <p>If a list item contains an array, another list, or a hash, individual elements within that item may be accessed and modified using standard array syntax. In this case, the first dimension must be a scalar that specifies the list element, and the higher dimensions are used to index into the array itself. The higher dimensions may be any combination of scalars, subscript ranges, or index arrays. The syntax looks like:</p>
        <p class="Code">values = list[index, sub0, sub1,...]</p>
        <p class="Code">list[index, sub0, sub1,...] = values</p>
        <p>where <i>index </i>is a scalar that specifies the list element, and <i>sub0</i>, <i>sub1</i>,... are the subscript ranges or indices for the contained array.</p>
        <p>For example, to create a "ragged" array, where each element is a vector of a different length:</p>
        <p class="Code">list = LIST( FINDGEN(100), FINDGEN(67), FINDGEN(93), FINDGEN(120) )</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Print the 6th element of the first vector</p>
        <p class="Code">print, list[0, 5]</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Print every other element of the 3rd vector</p>
        <p class="Code">print, list[2, 0:*:2]</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Change several elements of the 4th vector</p>
        <p class="Code">list[3, [5,10,15,20]] = -1</p>
        <p>In this example, we create a list that contains some strings and a two-dimensional array:</p>
        <p class="Code">list = LIST( 'Sensor Data', 'April 1, 2001', HANNING(100, 50) )</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Modify the element in the center of the array</p>
        <p class="Code">list[2, 50, 25] = 0.0</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Change an entire column of the array</p>
        <p class="Code">list[2, 99, *] = -1.0</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Extract a subset of the array</p>
        <p class="Code">help, list[2, 10:15, 7:11]</p>
        <p>IDL prints:</p>
        <p class="Code">&lt;Expression&gt;    FLOAT     = Array[6, 5]</p>
        <p>In this example, we create a list that contains another list (which contains an array) and a hash:</p>
        <p class="Code">list = LIST( 'Sensor Data', 'April 2', $</p>
        <p class="Code">&#160;&#160;LIST('MyData', DIST(20, 30)), $</p>
        <p class="Code">&#160;&#160;HASH('LINESTYLE', 3, 'THICK', 2) )</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Extract the entire array from the sub-list</p>
        <p class="Code">help, list[2, 1]</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Extract a subset of the array within the sub-list</p>
        <p class="Code">help, list[2, 1, 10:15, [20,21,22] ]</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Add a new key-value to the hash within the list</p>
        <p class="Code">list[3, 'COLOR'] = 'blue'</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Extract a value from the hash</p>
        <p class="Code">help, list[3, 'COLOR' ]</p>
        <p>IDL prints:</p>
        <p class="Code">&lt;Expression&gt;    FLOAT     = Array[20, 30]</p>
        <p class="Code">&lt;Expression&gt;    FLOAT     = Array[6, 3]</p>
        <p class="Code">&lt;Expression&gt;    STRING    = 'blue'</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>When indexing into an array contained within a list, the first dimension must always be the index of the list element. Since IDL can only handle a maximum of eight dimensions, you can only use up to seven dimensions when indexing into an array within a list. If the array is contained within a list (which is itself contained within a list), the maximum number of dimensions will be six, and so on.</p>
        <h2 class="API"><a name="Informat"></a>Information about Lists</h2>
        <h3><a name="Logical"></a>Logical Truth</h3>
        <p>The <a href="../../Creating IDL Programs/Components of the IDL Language/Logical_Operators.htm">logical truth operator</a> evaluates a list. It returns a value of 1 (TRUE) if the list is non-empty, and returns 0 (FALSE) if the list is empty.</p>
        <p class="Code">IF (list) THEN . . .</p>
        <h3><a name="lists_3331144781_1000539"></a>Logical Negation</h3>
        <p>The <a href="../../Creating IDL Programs/Components of the IDL Language/Logical_Operators.htm">logical negation operator</a> negates the logical value of a list:</p>
        <p class="Code">IF (~list) THEN . . .</p>
        <p>If <i>list</i> is TRUE, the statement evaluates as FALSE, and so on.</p>
        <h3><a name="N_ELEMEN"></a>N_ELEMENTS</h3>
        <p>The N_ELEMENTS function returns the number of elements in a list:</p>
        <p class="Code">Result = N_ELEMENTS(list)</p>
        <p>If <code>list</code> contains zero elements, or if <code>list</code> is an undefined variable, 0 is returned.</p>
        <p>For more information, see <a href="../N/N_ELEMENTS.htm#N_830853741_953695">N_ELEMENTS</a>.</p>
        <h3><a name="ISA"></a>ISA</h3>
        <p>The ISA function can determine whether the given variable is a list:</p>
        <p class="Code">x = LIST('apple', 99, 57.3)<br />PRINT, ISA(x, 'LIST')</p>
        <p>IDL prints:</p>
        <p class="Code">1</p>
        <p>For more information, see <a href="../I/ISA.htm#I_833016429_1127569">ISA</a>.</p>
        <h3><a name="TYPENAME"></a>TYPENAME</h3>
        <p>The TYPENAME function returns the type LIST for a list variable:</p>
        <p class="Code">x = LIST(1, 'hello', 5.0)<br />PRINT, TYPENAME(x)</p>
        <p>IDL prints:</p>
        <p class="Code">LIST</p>
        <p>For more information, see <a href="../T/TYPENAME.htm#T_809226861_1160964">TYPENAME</a>.</p>
        <h3><a name="HELP"></a>HELP</h3>
        <p>The <a href="../H/HELP.htm">HELP procedure</a> provides general information about a list variable:</p>
        <p class="Code">newList = LIST('apple', 99, 27.3, [10, 20, 30])<br />HELP, newList</p>
        <p>IDL prints:</p>
        <p class="Code">NEWLIST         LIST  &lt;LIST  ID=1  NELEMENTS=4&gt;</p>
        <p>In this case, the variable name is NEWLIST, the type name is LIST, the heap ID is 1, and there are four elements in the list.</p>
        <h3><a name="PRINT"></a>PRINT</h3>
        <p>The <a href="../P/PRINT.htm">PRINT procedure</a> gives the value for each list element:</p>
        <p class="Code">newList = LIST('apple', 99, 27.3, [10, 20, 30])<br />PRINT, newList</p>
        <p>IDL prints:</p>
        <p class="Code">apple</p>
        <p class="Code">      99</p>
        <p class="Code">      27.3000</p>
        <p class="Code">      10      20      30</p>
        <h3>Implied Print</h3>
        <p>Using <a href="../../Creating IDL Programs/Components of the IDL Language/ImpliedPrint.htm">Implied Print</a> with a list will print out each element in standard <a href="../J/JSON_PARSE.htm">JSON</a> notation:</p>
        <p class="Code">IDL&gt; newList = LIST('apple', 99, 27.3, [10, 20, 30])<br />IDL&gt; newList</p>
        <p>IDL prints:</p>
        <p class="Code">[</p>
        <p class="Code_Indented">"apple",</p>
        <p class="Code_Indented">99,</p>
        <p class="Code_Indented">27.299999,</p>
        <p class="Code_Indented">[</p>
        <p class="Code_Indented2">10,</p>
        <p class="Code_Indented2">20,</p>
        <p class="Code_Indented2">30</p>
        <p class="Code_Indented">]</p>
        <p class="Code">]</p>
        <h2 class="API"><a name="L_826528365_1077856"></a>Version History</h2>
        <table style="caption-side: top;mc-table-style: url('../../Resources/TableStyles/VersionTable.css');" cellspacing="0" class="TableStyle_VersionTable">
            <col />
            <col />
            <tbody>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_ColSep">
                        <p>8.0</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_ColEnd">
                        <p>Introduced</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowSep_ColSep">
                        <p>8.1</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowSep_ColEnd">
                        <p>Added NO_COPY keyword to the ToArray method</p>
                        <p>Added ability to index into arrays within a list</p>
                        <p>Added Count, FindValue, IsEmpty methods</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_ColSep">8.2</td>
                    <td class="TableStyle_VersionTable_Body_0_0_ColEnd">Added the Where method, deprecated the FindValue method</td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowSep_ColSep">8.2.3</td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowSep_ColEnd">Added DIMENSION keyword to the ToArray method</td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_ColSep">8.3</td>
                    <td class="TableStyle_VersionTable_Body_0_0_ColEnd">Added Move and Swap methods, added Implied Print to JSON format</td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">8.4</td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">
                        <p>Added Filter, Map, NestedMap, Reduce, and Sort methods.</p>
                        <p>Added PROMOTE_TYPE keyword to the ToArray method.</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <h2 class="API">See Also</h2>
        <p><a href="../../Creating IDL Programs/Components of the IDL Language/The_Null_Variable.htm">!NULL</a>, <a href="../D/DICTIONARY.htm">DICTIONARY</a>, <a href="../H/HASH.htm#L_826528365_1077832">HASH</a>, <a href="../O/ORDEREDHASH.htm">ORDEREDHASH</a>, <a href="../../Creating IDL Programs/Components of the IDL Language/Logical_Operators.htm">Logical Operators</a>, <a href="../../Creating IDL Programs/Components of the IDL Language/Relational_Operators.htm">Relational Operators</a>, <a href="LAMBDA.htm">LAMBDA</a></p>
        <div class="mp_footer">© <span class="DocumentTitleCopyrightYear">2015</span>&#160;<span class="DocumentTitleCopyrightCompanyName">Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation</span>. All Rights Reserved. This information is not subject to the controls of the International Traffic in Arms Regulations (ITAR) or the Export Administration Regulations (EAR). However, this information may be restricted from transfer to various embargoed countries under U.S. laws and regulations.</div>
    </body>
</html>