<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-US" xml:lang="en-US" data-mc-search-type="Stem" data-mc-help-system-file-name="idl.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="Routines (alphabetical)|Routines: C">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>CALL_EXTERNAL </title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/Doc_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix"> </span><a class="MCBreadcrumbsLink" href="../../images/ref_part1.htm">Routines (alphabetical)</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="C_list.htm">Routines: C</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">CALL_EXTERNAL</span>
        </div>
        <h1 class="Routine"><a name="C_854643309_106442"></a><a name="C_854643309_83646"></a><a name="C_854643309_65173"></a>CALL_EXTERNAL </h1>
        <p><a name="kanchor151"></a><a name="kanchor152"></a><a name="kanchor153"></a>The CALL_EXTERNAL function calls a function in an external sharable object and returns a scalar value. Parameters can be passed by reference (the default) or by value. See Chapter 3, “Using CALL_EXTERNAL” (<i>External Development Guide</i> in the <code>help/pdf</code> directory of your IDL installation) for examples.</p>
        <p><a name="kanchor154"></a>CALL_EXTERNAL is supported under all operating systems supported by IDL, although there are system specific details of which you must be aware. This function requires no interface routines and is much simpler and easier to use than the LINKIMAGE procedure. However, CALL_EXTERNAL performs no checking of the type and number of parameters. Programming errors are likely to cause IDL to crash or to corrupt your data.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Input and output actions should be performed within IDL code, using IDL’s built&#8209;in input/output facilities, or by using the internal IDL_Message() function. Performing input or output from external code, especially to the user console or tty (e.g. using <code>printf()</code> or equivalent functionality in other languages to send text to stdout) may create errors or generate unexpected results.</p>
        <p>CALL_EXTERNAL supports the IDL Portable Convention, a portable calling convention that works on all platforms. This convention passes two arguments to the called routine, an argument count (<code>argc</code>) and an array of arguments (<code>argv</code>).</p>
        <p>CALL_EXTERNAL also offers a feature called <a href="#C_854643309_1012529" class="selected">Auto Glue</a> that can greatly simplify use of the CALL_EXTERNAL portable convention if you have the appropriate C compiler installed on your system. Auto glue automatically writes the glue function required to convert the (argc, argv) arguments to the actual function call, and then compiles and loads the glue function transparently. If you want IDL to simply write the glue function for you, but not compile it, the WRITE_WRAPPER keyword can be used.</p>
        <p>The result of the CALL_EXTERNAL function is a scalar value returned by the external function. By default, this is a scalar long (32-bit) integer. This default can be changed by specifying one of the keywords described below that alter the result type.</p>
        <h2 class="API"><a name="C_854643309_905981_PageTOC_CALL_EXTERNAL_"></a>Examples</h2>
        <p>See Chapter 3, “Using CALL_EXTERNAL” (<i>External Development Guide</i> in the <code>help/pdf</code> directory of your IDL installation).</p>
        <h2 class="API"><a name="C_854643309_951344"></a><a name="C_854643309_951344_PageTOC_CALL_EXTERNAL_"></a>Syntax</h2>
        <p class="Syntax"><i>Result</i> = CALL_EXTERNAL(<i>Image</i>, <i>Entry</i> [,&#160;<i>P</i><sub class="italic">0</sub>, ..., <i>P</i><sub class="italic">N-1</sub>] [,&#160;/<a href="#C_854643309_905908" class="selected">ALL_VALUE</a>] [,&#160;/<a href="#C_854643309_951311" class="selected">B_VALUE</a> | ,&#160;/<a href="#C_854643309_905920" class="selected">D_VALUE</a> | ,&#160;/<a href="#C_854643309_905923" class="selected">F_VALUE</a> | ,&#160;/<a href="#C_854643309_905926" class="selected">I_VALUE</a> | ,&#160;/<a href="#C_854643309_951332" class="selected">L64_VALUE</a> | ,&#160;/<a href="#C_854643309_951354" class="selected">S_VALUE</a> | ,&#160;/<a href="#C_854643309_951320" class="selected">UI_VALUE</a> | ,&#160;/<a href="#C_854643309_965879" class="selected">UL_VALUE</a> | ,&#160;/<a href="#C_854643309_965882" class="selected">UL64_VALUE</a>] [,&#160;/<a href="#C_854643309_905911" class="selected">CDECL</a>] [,&#160;<a href="#C_854643309_1029187" class="selected">RETURN_TYPE</a>=<i>value</i>] [,&#160;/<a href="#C_854643309_993357" class="selected">UNLOAD</a>] [,&#160;<a href="#C_854643309_905936" class="selected">VALUE</a>=<i>byte_array</i>] [,&#160;<a href="#C_854643309_1029198" class="selected">WRITE_WRAPPER</a>=<i>wrapper_file</i>] [, /<a href="#C_854643309_1025677" class="selected">AUTO_GLUE</a>] [, <a href="#C_854643309_1012394" class="selected">CC</a>=<i>string</i>] [,&#160;<a href="#C_854643309_1012398" class="selected">COMPILE_DIRECTORY</a>=<i>string</i>] [, <a href="#C_854643309_1012436" class="selected">EXTRA_CFLAGS</a>=<i>string</i>] [,&#160;<a href="#C_854643309_1012440" class="selected">EXTRA_LFLAGS</a>=<i>string</i>] [, /<a href="#C_854643309_1012444" class="selected">IGNORE_EXISTING_GLUE</a>] [, <a href="#C_854643309_1012449" class="selected">LD</a>=<i>string</i>] [,&#160;/<a href="#C_854643309_1012453" class="selected">NOCLEANUP</a>] [, /<a href="#C_854643309_1012458" class="selected">SHOW_ALL_OUTPUT</a>] [, /<a href="#C_854643309_1012497" class="selected">VERBOSE</a>] )</p>
        <h2 class="API"><a name="C_854643309_1068689"></a><a name="C_854643309_74896"></a>Return Value </h2>
        <p>This function calls a function in an external sharable object and returns a scalar value.</p>
        <h2 class="API"><a name="C_854643309_905895"></a><a name="C_854643309_905895_PageTOC_CALL_EXTERNAL_"></a>Arguments</h2>
        <h3 class="Argument">Image</h3>
        <p>The name of the file, which must be a sharable library (UNIX), or DLL (Windows), which contains the routine to be called.</p>
        <h3 class="Argument">Entry</h3>
        <p>A string containing the name of the symbol in the library which is the entry point of the routine to be called.</p>
        <h3 class="Argument">P<sub>0</sub>, ..., P<sub>N-1</sub></h3>
        <p>The parameters to be passed to the external routine. All array and structure arguments are passed by reference (address). The default is to also pass scalars by reference, but the ALL_VALUE or VALUE keywords can be used to pass them by value. Care must be taken to ensure that the type, structure, and passing mechanism of the parameters passed to the external routine match what it expects. There are some restrictions on data types that can be passed by value, and the user needs to be aware of how IDL passes strings. Both issues discussed in further detail below.</p>
        <h2 class="API"><a name="C_854643309_905906"></a><a name="C_854643309_905906_PageTOC_CALL_EXTERNAL_"></a>Keywords</h2>
        <h3 class="Keyword"><a name="C_854643309_905908"></a><a name="C_854643309_905908_Keywords_CALL_EXTERNAL__"></a>ALL_VALUE</h3>
        <p>Set this keyword to indicate that all parameters are passed by value. There are some restrictions on data types that should be considered when using this keyword, as discussed below.</p>
        <h3 class="Keyword"><a name="C_854643309_951311"></a><a name="C_854643309_951311_Keywords_CALL_EXTERNAL__"></a>B_VALUE</h3>
        <p>If set, this keyword indicates that the called function returns a byte value.</p>
        <h3 class="Keyword"><a name="C_854643309_905911"></a><a name="C_854643309_905911_Keywords_CALL_EXTERNAL__"></a>CDECL</h3>
        <p>The Microsoft Windows operating system has two distinct system defined standards that govern how routines pass arguments: <code>stdcall</code>, which is used by much of the operating system as well as languages such as Visual Basic, and <code>cdecl</code>, which is used widely for programming in the C language. These standards differ in how and when arguments are pushed and removed from the system stack. The standard used by a given function is determined when the function is compiled, and can usually be controlled by the programmer. If you call a function using the wrong standard (e.g. calling a <code>stdcall</code> function as if it were <code>cdecl</code>, or the reverse), you could get incorrect results, corrupted memory, or you could crash IDL. Unfortunately, there is no way for IDL to know which convention a given function uses; this information must be supplied by the user of CALL_EXTERNAL. If the CDECL keyword is present, IDL will use the <code>cdecl</code> convention to call the function. Otherwise, <code>stdcall</code> is used.</p>
        <h3 class="Keyword"><a name="C_854643309_905920"></a><a name="C_854643309_905920_Keywords_CALL_EXTERNAL__"></a>D_VALUE</h3>
        <p>If set, this keyword indicates that the called function returns a double-precision floating value.</p>
        <h3 class="Keyword"><a name="C_854643309_905923"></a><a name="C_854643309_905923_Keywords_CALL_EXTERNAL__"></a>F_VALUE</h3>
        <p>If set, this keyword indicates that the called function returns a single-precision floating value.</p>
        <h3 class="Keyword"><a name="C_854643309_905926"></a><a name="C_854643309_905926_Keywords_CALL_EXTERNAL__"></a>I_VALUE</h3>
        <p>If set, this keyword indicates that the called function returns an integer value.</p>
        <h3 class="Keyword"><a name="C_854643309_951332"></a><a name="C_854643309_951332_Keywords_CALL_EXTERNAL__"></a>L64_VALUE</h3>
        <p>If set, this keyword indicates that the called function returns a 64-bit integer value.</p>
        <h3 class="Keyword"><a name="C_854643309_1029187"></a><a name="C_854643309_1029187_Keywords_CALL_EXTERNAL__"></a>RETURN_TYPE</h3>
        <p>The type code to set the type of the result. See the description of the <a href="../S/SIZE.htm#S_820040301_678885">SIZE </a>function for a list of the IDL type codes.</p>
        <h3 class="Keyword"><a name="C_854643309_951354"></a><a name="C_854643309_951354_Keywords_CALL_EXTERNAL__"></a>S_VALUE</h3>
        <p>If set, this keyword indicates that the called function returns a pointer to a null&#8209;terminated string.</p>
        <h3 class="Keyword"><a name="C_854643309_951320"></a><a name="C_854643309_951320_Keywords_CALL_EXTERNAL__"></a>UI_VALUE</h3>
        <p>If set, this keyword indicates that the called function returns an unsigned integer value.</p>
        <h3 class="Keyword"><a name="C_854643309_965879"></a><a name="C_854643309_965879_Keywords_CALL_EXTERNAL__"></a>UL_VALUE</h3>
        <p>If set, this keyword indicates that the called function returns an unsigned long integer value.</p>
        <h3 class="Keyword"><a name="C_854643309_965882"></a><a name="C_854643309_965882_Keywords_CALL_EXTERNAL__"></a>UL64_VALUE</h3>
        <p>If set, this keyword indicates that the called function returns an unsigned 64-bit integer value.</p>
        <h3 class="Keyword"><a name="C_854643309_993357"></a><a name="C_854643309_993357_Keywords_CALL_EXTERNAL__"></a>UNLOAD</h3>
        <p>Normally, IDL keeps <i>Image</i> loaded in memory after the call to CALL_EXTERNAL completes. This is done for efficiency—loading a sharable object can be a slow operation. Setting the UNLOAD keyword will cause IDL to unload <i>Image</i> after the call to it is complete. This is useful if you are debugging code in <i>Image</i>, as it allows you to iterate on your code without having to exit IDL between tests. It can also be a good idea if you do not intend to make any subsequent calls to routines within <i>Image</i>.</p>
        <p>If IDL is unable to unload the sharable object, it will issue an error to that effect. In addition to any operating system reported problem that might occur, IDL cannot perform the UNLOAD operation if the sharable library has been used for any other purpose in addition to CALL_EXTERNAL (e.g. LINKIMAGE).</p>
        <h3 class="Keyword"><a name="C_854643309_905936"></a><a name="C_854643309_905936_Keywords_CALL_EXTERNAL__"></a>VALUE</h3>
        <p>A byte array, with as many elements as there are optional parameters, indicating the method of parameter passing. Arrays are always passed by reference. If parameter P<sub class="italic">i </sub>is a scalar, it is passed by reference if VALUE[<i>i</i>] is 0; and by value if it is non-zero. There are some restrictions on data types that should be considered when using this keyword, as discussed below.</p>
        <h3 class="Keyword"><a name="C_854643309_1029198"></a><a name="C_854643309_1029198_Keywords_CALL_EXTERNAL__"></a>WRITE_WRAPPER</h3>
        <p>If set, WRITE_WRAPPER supplies the name of a file for CALL_EXTERNAL to create containing the C function required to convert the (<code>argc</code>, <code>argv</code>) interface used by the CALL_EXTERNAL portable calling convention to the interface of the target function. If WRITE_WRAPPER is specified, CALL_EXTERNAL writes the specified file, but does not attempt to actually call the function specified by Entry. The result from CALL_EXTERNAL is an integer 0 in this case, and has no special meaning. Use of WRITE_WRAPPER implies the PORTABLE keyword.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>This is similar to Auto Glue only in that CALL_EXTERNAL writes a function on your behalf. Unlike Auto Glue, WRITE_WRAPPER does not attempt to compile the resulting function or to use it. You might want to use WRITE_WRAPPER to generate IDL interfaces for an external library in cases where you intend to combine the interfaces with other code or otherwise modify it before using it with IDL. </p>
        <h3><a name="C_854643309_1012385_Keywords_CALL_EXTERNAL__"></a><a name="C_854643309_1012385_PageTOC_CALL_EXTERNAL_"></a>Auto Glue Keywords</h3>
        <p>Auto Glue, discussed in the section <a href="#C_854643309_1012529" class="selected">Auto Glue</a>, offers a simplified way to use the CALL_EXTERNAL portable calling convention. The following keywords control its use. Many of these keywords correspond to the same keywords to the MAKE_DLL procedure, and are covered in more detail in the documentation for that routine.</p>
        <h3 class="Keyword"><a name="C_854643309_1025677"></a><a name="C_854643309_1025677_Keywords_CALL_EXTERNAL__"></a>AUTO_GLUE </h3>
        <p>Set this keyword to enable the CALL_EXTERNAL Auto Glue feature.</p>
        <h3 class="Keyword"><a name="C_854643309_1012394"></a><a name="C_854643309_1012394_Keywords_CALL_EXTERNAL__"></a>CC</h3>
        <p>If present, a template string to be used in generating the C compiler command(s) to compile the automatically generated glue function. For a more complete description of this keyword, see <a href="../M/MAKE_DLL.htm#M_824365677_960427">MAKE_DLL</a>.</p>
        <h3 class="Keyword"><a name="C_854643309_1012398"></a><a name="C_854643309_1012398_Keywords_CALL_EXTERNAL__"></a>COMPILE_DIRECTORY</h3>
        <p>Specifies the directory to use for creating the necessary intermediate files and the final glue function sharable library. For a more complete description of this keyword, see <a href="../M/MAKE_DLL.htm#M_824365677_960427">MAKE_DLL</a>.</p>
        <h3 class="Keyword"><a name="C_854643309_1012436"></a><a name="C_854643309_1012436_Keywords_CALL_EXTERNAL__"></a>EXTRA_CFLAGS</h3>
        <p>If present, a string supplying extra options to the command used to execute the C compiler. For a more complete description of this keyword, see <a href="../M/MAKE_DLL.htm#M_824365677_960427">MAKE_DLL</a>.</p>
        <h3 class="Keyword"><a name="C_854643309_1012440"></a><a name="C_854643309_1012440_Keywords_CALL_EXTERNAL__"></a>EXTRA_LFLAGS</h3>
        <p>If present, a string supplying extra options to the command used to execute the linker. For a more complete description of this keyword, see <a href="../M/MAKE_DLL.htm#M_824365677_960427">MAKE_DLL</a>.</p>
        <h3 class="Keyword"><a name="C_854643309_1012444"></a><a name="C_854643309_1012444_Keywords_CALL_EXTERNAL__"></a>IGNORE_EXISTING_GLUE </h3>
        <p>Normally, if Auto Glue finds a pre-existing glue function, it will use it without attempting to build it again. Set IGNORE_EXISTING_GLUE to override this caching behavior and force CALL_EXTERNAL to rebuild the glue function sharable library. </p>
        <h3 class="Keyword"><a name="C_854643309_1012449"></a><a name="C_854643309_1012449_Keywords_CALL_EXTERNAL__"></a>LD</h3>
        <p>If present, a template string to be used in generating the linker command to build the glue function sharable library. For a more complete description of this keyword, see <a href="../M/MAKE_DLL.htm#M_824365677_960427">MAKE_DLL</a>.</p>
        <h3 class="Keyword"><a name="C_854643309_1012453"></a><a name="C_854643309_1012453_Keywords_CALL_EXTERNAL__"></a>NOCLEANUP</h3>
        <p>If set, CALL_EXTERNAL will not remove intermediate files generated in order to build the glue function sharable library after the library has been built. This keyword can be used to preserve information for debugging in case of error, or for additional information on how Auto Glue works. For a more complete description of this keyword, see <a href="../M/MAKE_DLL.htm#M_824365677_960427">MAKE_DLL</a>.</p>
        <h3 class="Keyword"><a name="C_854643309_1012458"></a><a name="C_854643309_1012458_Keywords_CALL_EXTERNAL__"></a>SHOW_ALL_OUTPUT</h3>
        <p>Auto Glue normally produces no output unless an error prevents successful building of the glue function sharable library. Set SHOW_ALL_OUTPUT to see all output produced by the process of building the library. For a more complete description of this keyword, see <a href="../M/MAKE_DLL.htm#M_824365677_960427">MAKE_DLL</a>.</p>
        <h3 class="Keyword"><a name="C_854643309_1012497"></a><a name="C_854643309_1012497_Keywords_CALL_EXTERNAL__"></a>VERBOSE</h3>
        <p>If set, VERBOSE causes CALL_EXTERNAL to issue informational messages as it carries out the task of locating, building, and executing the glue function. For a more complete description of this keyword, see <a href="../M/MAKE_DLL.htm#M_824365677_960427">MAKE_DLL</a>.</p>
        <h2 class="API"><a name="C_854643309_905938_PageTOC_CALL_EXTERNAL_"></a>String Parameters</h2>
        <p>IDL represents strings internally as IDL_STRING descriptors, which are defined in the C language as:</p>
        <p class="Code">typedef struct {</p>
        <p class="Code">  unsigned short slen;</p>
        <p class="Code">  unsigned short stype;</p>
        <p class="Code">  char *s;</p>
        <p class="Code">} IDL_STRING;</p>
        <p>To pass a string by reference, IDL passes the address of its IDL_STRING descriptor. To pass a string by value the string pointer (the <code>s</code> field of the descriptor) is passed. Programmers should be aware of the following when manipulating IDL strings:</p>
        <ul>
            <li value="1">Called code should treat the information in the passed IDL_STRING descriptor and the string itself as read-only, and should not modify these values.</li>
            <li value="2">The <code>slen</code> field contains the length of the string without including the NULL termination that is required at the end of all C strings.</li>
            <li value="3">The <code>stype</code> field is used internally by IDL to know keep track of how the memory for the string was obtained, and should be ignored by CALL_EXTERNAL users.</li>
            <li value="4"><code>s</code> is the pointer to the actual C string represented by the descriptor. If the string is NULL, IDL represents it as a NULL (0) pointer, not as a pointer to an empty null terminated string. Hence, called code that expects a string pointer should check for a NULL pointer before dereferencing it.</li>
        </ul>
        <p>These issues are examined in greater detail in the IDL <i>External Development Guide</i>  in the <code>help/pdf</code> directory of your IDL installation.</p>
        <h2 class="API"><a name="C_854643309_905952_PageTOC_CALL_EXTERNAL_"></a><a name="C_854643309_11962"></a>Calling Convention</h2>
        <p>CALL_EXTERNAL uses the IDL Portable convention for calling user-supplied routines. The IDL Portable calling convention can be simplified by using the Auto Glue extension, described below.</p>
        <p>The portable interface convention passes all arguments as elements of an array of C void pointers (void *). The C language prototype for a user function called this way looks like one of the following:</p>
        <p class="Code">RET_TYPE xxx(int argc, void *argv[])</p>
        <p>Where RET_TYPE is one of the following: <code>UCHAR</code>, <code>short</code>, <code>IDL_UINT</code>, <code>IDL_LONG</code>, <code>IDL_ULONG</code>, <code>IDL_LONG64</code>, <code>IDL_ULONG64</code>, <code>float</code>, <code>double</code>, or <code>char *</code>. The return type used must agree with the type assumed by CALL_EXTERNAL as specified via the keywords described above.</p>
        <p><code>Argc</code> is the number of arguments, and the vector <code>argv</code> contains the arguments themselves, one argument per element. Arguments passed by reference map directly to these (<code>void *</code>) pointers, and can be cast to the proper type and then dereferenced directly by the called function. Passing arguments by value is allowed, but since the values are passed in (<code>void *</code>) pointers, there are some limitations and restrictions on what is possible:</p>
        <ul>
            <li value="1">Types that are larger than a pointer cannot be passed by value, and CALL_EXTERNAL will issue an error if this is attempted. This limitation applies only to the standard portable calling convention. Auto Glue does not have this limitation, and is able to pass such variables by value.</li>
            <li value="2">Integer values can be easily passed by value. IDL widens any of the integer types to the C int type and they are then converted to a (void *) pointer using a C cast operation.</li>
            <li value="3">There is no C language-defined conversion between pointers and floating point types, so IDL copies the data for the value directly into the pointer element. Although such values can be retrieved by the called routine with the correct C casting operations, this is inconvenient and error prone. It is best to pass non-integer data by reference.</li>
        </ul>
        <h2 class="API"><a name="C_854643309_1012529"></a><a name="C_854643309_1012529_PageTOC_CALL_EXTERNAL_"></a><a name="C_854643309_41118"></a>Auto Glue</h2>
        <p>Auto Glue is an extension to the IDL Portable Calling Convention that makes it easier to use. </p>
        <p>The portable calling convention requires your function to use the IDL defined (<code>argc</code>, <code>argv</code>) interface for passing arguments. However, functions not explicitly written for use with CALL_EXTERNAL may not have this interface. A common solution using the portable convention is for the IDL user to write a <i>glue</i> function that serves as an interface between IDL and the called function. The entire purpose of this glue function, which is usually very simple, is to convert the IDL (argc, argv) method of passing parameters to a form acceptable to the called function. Writing this wrapper function is easy for programmers who understand the C language, the system C compiler and linker, and how sharable libraries work on their target operating system. However, it is also tedious and error prone, and can be difficult for users that do not already have these skills. </p>
        <p>Auto Glue uses the MAKE_DLL procedure to automate the process of using glue code to call functions via the CALL_EXTERNAL portable calling convention. Since it depends so closely on MAKE_DLL, an understanding of how MAKE_DLL works is necessary to fully understand Auto Glue. As with MAKE_DLL, Auto Glue requires that your system have a suitable C compiler installed. Please refer to the documentation for MAKE_DLL. </p>
        <p>Auto Glue maintains a cache of previously built glue functions, and will reuse them on subsequent requests, even between IDL sessions. Glue function libraries can be recognized by their name, which starts with the prefix <code>idl_ce</code>, and ends with the proper suffix for a sharable library on the target system (most UNIX: <code>.so</code>, Windows: <code>.dll</code>). CALL_EXTERNAL finds a suitable glue function by performing the following steps in order, stopping after the first one that works:</p>
        <ol>
            <li value="1">
                <p>Look for a <code>ce_glue</code> subdirectory within the IDL distribution <code>bin</code> subdirectory for the current platform. (For example, on a Windows system the subdirectory could be located in <code>&lt;IDL_DEFAULT&gt;\bin\bin.x86</code>.) If this directory exists, it looks there for a sharable library containing the appropriate glue function. </p>
                <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>For customer security reasons, the <code>ce_glue</code> subdirectory does not exist in the distribution shipped with IDL, and IDL does not use it to create glue functions. However, if an individual site creates this directory and places glue library files within it, IDL will use them. Multiple IDL sessions on a given system can all share these same glue files, even when run by different users on a multi-user system. If you keep your IDL distribution on a network based file server shared by multiple clients, and if you provide a sufficient selection of glue files, it is possible that your users will not require a locally installed C compiler to use Auto Glue. </p>
                <p>If you do create the <code>ce_glue</code> subdirectory on a multi-user system, we recommend that you make it along with all files contained within belong to the owner of the IDL distribution, and apply file protections that prevent non-privileged users from creating files in the directory or modifying them. </p>
            </li>
            <li value="2">Look in the directory given by the COMPILE_DIRECTORY keyword, or if COMPILE_DIRECTORY is not present, in the directory given by the !MAKE_DLL.COMPILE_DIRECTORY system variable for the appropriate glue function. </li>
            <li value="3">If this step is reached, there is no pre-existing glue function available. CALL_EXTERNAL will create one in the same directory searched in the previous step by generating a C language file containing the needed glue function, and then compiling and linking it into a sharable library using the functionality of the MAKE_DLL procedure. </li>
            <ul>
                <li value="1">IDL loads the sharable library containing the glue function found in the previous step, as well as the library you specified with the Image argument. </li>
                <li value="2">CALL_EXTERNAL calls the glue function, causing your function to be called with the correct parameters. </li>
            </ul>
        </ol>
        <p>The first time CALL_EXTERNAL encounters the need for a glue function that does not already exist, it will automatically build it, and then use it without any external indication that this has happened. You may notice a brief hesitation in IDL’s execution as it waits for this process to occur. Once a glue function exists, IDL can load it immediately on subsequent calls (even in unrelated later IDL sessions), and no delay will occur. </p>
        <h3><a name="C_854643309_1012580_Keywords_CALL_EXTERNAL__"></a>Example: Using Auto Glue To Call System Library Routines </h3>
        <p>Under Sun Solaris, there is a function in the system math library called hypot() that computes the length of the hypotenuse of a right-angled triangle: </p>
        <p class="Code">sqrt(x*x + y*y)</p>
        <p>This function has the C prototype: </p>
        <p class="Code">double hypot(double x, double y)</p>
        <p>The following IDL function uses Auto Glue to call this routine: </p>
        <p class="Code">FUNCTION HYPOT, X, Y</p>
        <p class="Code">&#160;&#160;&#160;; Use the 32-bit or the 64-bit math library?</p>
        <p class="Code">&#160;&#160;&#160;LIBM=(!VERSION.MEMORY_BITS EQ 64) $</p>
        <p class="Code">&#160;&#160;&#160;&#160;&#160;&#160;? ’/usr/lib/sparcv9/libm.so’ : ’/usr/lib/libm.so’</p>
        <p class="Code">&#160;&#160;&#160;RETURN, CALL_EXTERNAL(LIBM, ’hypot’, double(x), double(y), $</p>
        <p class="Code">&#160;&#160;&#160;&#160;&#160;&#160;/ALL_VALUE, /D_VALUE, /AUTO_GLUE)</p>
        <p class="Code">END</p>
        <h2 class="API"><a name="C_854643309_905976_PageTOC_CALL_EXTERNAL_"></a>Important Changes Since IDL 5.0</h2>
        <p>The current version of CALL_EXTERNAL differs from IDL versions up to and including IDL 5.0 in a few ways that are important to users moving code to the current version:</p>
        <ul>
            <li value="1">Under Windows, CALL_EXTERNAL would pass IDL strings by value no matter how the ALL_VALUE or VALUE keywords were set. This was inconsistent with all the other platforms and created unnecessary confusion. IDL now uses these keywords to decide how to pass strings on all platforms. Windows users with existing code that expects strings to be passed by value without having specified it via one of these keywords will need to adjust their use of CALL_EXTERNAL or their code. </li>
            <li value="2">Older versions of IDL would quietly pass by value arguments that are larger than a pointer without issuing an error when using the portable calling convention. Although this might work on some hardware, it is error prone and can cause IDL to crash. IDL now issues an error in this case. Programmers with existing code moving to a current version of IDL should change their code to pass such data by reference.</li>
        </ul>
        <h2 class="API"><a name="C_854643309_905983"></a><a name="C_854643309_905983_PageTOC_CALL_EXTERNAL_"></a>Version History</h2>
        <table style="mc-table-style: url('../../Resources/TableStyles/VersionTable.css');margin-left: 0;margin-right: auto;caption-side: top;" cellspacing="0" class="TableStyle_VersionTable">
            <col />
            <col />
            <tbody>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_ColSep">
                        <p>Pre 4.0</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_ColEnd">
                        <p>Introduced</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">
                        <p>Pre 6.1</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">
                        <p>Deprecated the DEFAULT, PORTABLE, and VAX_FLOAT keywords</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <h2 class="API"><a name="C_854643309_1052034"></a><a name="C_854643309_1052034_PageTOC_CALL_EXTERNAL_"></a>See Also</h2>
        <p><a href="../L/LINKIMAGE.htm#L_826528365_840842">LINKIMAGE</a>
        </p>
        <div class="mp_footer">© <span class="DocumentTitleCopyrightYear">2015</span>&#160;<span class="DocumentTitleCopyrightCompanyName">Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation</span>. All Rights Reserved. This information is not subject to the controls of the International Traffic in Arms Regulations (ITAR) or the Export Administration Regulations (EAR). However, this information may be restricted from transfer to various embargoed countries under U.S. laws and regulations.</div>
    </body>
</html>