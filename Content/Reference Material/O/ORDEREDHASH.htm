<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-US" xml:lang="en-US" data-mc-search-type="Stem" data-mc-help-system-file-name="idl.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="Routines (alphabetical)|Routines: O">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>ORDEREDHASH</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/Doc_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix"> </span><a class="MCBreadcrumbsLink" href="../../images/ref_part1.htm">Routines (alphabetical)</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="O_list.htm">Routines: O</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">ORDEREDHASH</span>
        </div>
        <h1 class="Routine"><a name="kanchor1992"></a>ORDEREDHASH</h1>
        <p>The ORDEREDHASH function creates a new ordered hash. An <i>ordered hash</i> is a compound data type that contains key-value pairs of different data types, including any mixture of scalars, arrays, structures, pointers, object references, <a href="../D/DICTIONARY.htm">dictionaries</a>, <a href="../L/LIST.htm">lists</a>, <a href="../H/HASH.htm">hashes</a>, and other ordered hashes. Unlike <a href="../H/HASH.htm">HASH</a>, the keys in an ordered hash are kept in the same order in which they are inserted. </p>
        <p>Ordered hashes have the following properties:</p>
        <ul>
            <li value="1">Elements in an ordered hash are kept in their insert order and are indexed by a scalar key.</li>
            <li value="2">The key can be a scalar string or number. String keys are case sensitive unless the FOLD_CASE keyword is set.</li>
            <li value="3">You can retrieve elements using the bracket array notation.</li>
            <li value="4">Ordered hashes can change their size, growing and shrinking as elements are added or deleted.</li>
            <li value="5">Unlike structures, with an ordered hash you can change the data type of a value without a performance penalty.</li>
        </ul>
        <h3>Methods and Additional Information</h3>
        <ul>
            <li value="1">ORDEREDHASH( )</li>
            <li value="2"><a href="#OrdCount" class="selected">OrderedHash::Count</a>
            </li>
            <li value="3"><a href="#OrdFilter" class="selected">OrderedHash::Filter</a>
            </li>
            <li value="4"><a href="#OrdHasKey" class="selected">OrderedHash::HasKey</a>
            </li>
            <li value="5"><a href="#OrdIsEmpty" class="selected">OrderedHash::IsEmpty</a>
            </li>
            <li value="6"><a href="#OrdKeys" class="selected">OrderedHash::Keys</a>
            </li>
            <li value="7"><a href="#OrdMap" class="selected">OrderedHash::Map</a>
            </li>
            <li value="8"><a href="#OrdReduce" class="selected">OrderedHash::Reduce</a>
            </li>
            <li value="9"><a href="#OrdRemove" class="selected">OrderedHash::Remove</a>
            </li>
            <li value="10"><a href="#OrdToStruct" class="selected">OrderedHash::ToStruct</a>
            </li>
            <li value="11"><a href="#OrdValues" class="selected">OrderedHash::Values</a>
            </li>
            <li value="12"><a href="#OrdWhere" class="selected">OrderedHash::Where</a>
            </li>
        </ul>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Since the ORDEREDHASH is so similar to HASH, most of the documentation can be found under <a href="../H/HASH.htm">HASH</a>. Here we provide some examples of the differences between the two data types.</p>
        <h2 class="API">Examples</h2>
        <h4>Create an ordered hash containing all of the elements of a list.</h4>
        <p class="Code">keys = ['A', 'B', 'C', 'D', 'E', 'F', 'G']</p>
        <p class="Code">values = LIST('one', 2.0, 3, 4l, PTR_NEW(5), {n:6}, COMPLEX(7,0))</p>
        <p class="Code">hash = ORDEREDHASH(keys, values)</p>
        <p class="Code">PRINT, hash</p>
        <p>IDL prints:</p>
        <p class="Code">A: one</p>
        <p class="Code">B:       2.00000</p>
        <p class="Code">C:        3</p>
        <p class="Code">D:            4</p>
        <p class="Code">E: &lt;PtrHeapVar79&gt;</p>
        <p class="Code">F: {       6}</p>
        <p class="Code">G: (      7.00000,     0.000000)</p>
        <h4>Create a regular hash containing the same elements.</h4>
        <p class="Code">keys = ['A', 'B', 'C', 'D', 'E', 'F', 'G']</p>
        <p class="Code">values = LIST('one', 2.0, 3, 4l, PTR_NEW(5), {n:6}, COMPLEX(7,0))</p>
        <p class="Code">hash = HASH(keys, values)</p>
        <p class="Code">PRINT, hash</p>
        <p>IDL prints:</p>
        <p class="Code">A: one</p>
        <p class="Code">F: {       6}</p>
        <p class="Code">C:        3</p>
        <p class="Code">D:            4</p>
        <p class="Code">G: (      7.00000,     0.000000)</p>
        <p class="Code">B:       2.00000</p>
        <p class="Code">E: &lt;PtrHeapVar31&gt;</p>
        <p>Notice that the regular hash returns the elements in an arbitrary order while the ordered hash preserves the original element order.</p>
        <h4>Create an ordered hash from a structure, and also convert any substructures into ordered hashes.</h4>
        <p class="Code">struct = {FIELD1: 4.0, FIELD2: {SUBFIELD1: "hello", SUBFIELD2: 3.14}}</p>
        <p class="Code">hash = ORDEREDHASH(struct, /EXTRACT)</p>
        <p class="Code">PRINT, hash</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Use array syntax to retrieve the "substructure" hash.</p>
        <p class="Code">PRINT, hash['FIELD2']</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Use special array syntax to access a key within the "substructure".</p>
        <p class="Code">PRINT, 'SUBFIELD1 = ', hash['FIELD2', 'SUBFIELD1']</p>
        <p>IDL prints:</p>
        <p class="Code">FIELD1:       4.00000</p>
        <p class="Code">FIELD2: ORDEREDHASH  &lt;ID=4  NELEMENTS=2&gt;</p>
        <p class="Code">&#160;</p>
        <p class="Code">SUBFIELD1: hello</p>
        <p class="Code">SUBFIELD2:       3.14000</p>
        <p class="Code">&#160;</p>
        <p class="Code">SUBFIELD1 = hello</p>
        <h2 class="API">Syntax</h2>
        <p>For details on the input arguments and keywords see <a href="../H/HASH.htm#L_826528365_1077842">HASH</a>.</p>
        <p class="Syntax"><i>Result</i> = ORDEREDHASH( <i>Key</i><sub class="italic">1</sub>, <i>Value</i><sub class="italic">1</sub>, <i>Key</i><sub class="italic">2</sub>,
		<i>Value</i><sub class="italic">2</sub>, ... <i>Key</i><sub class="italic">n</sub>, <i>Value</i><sub class="italic">n</sub> ,&#160;/EXTRACT,&#160;/FOLD_CASE, /NO_COPY )</p>
        <p>or</p>
        <p class="Syntax"><i>Result</i> = ORDEREDHASH( <i>Keys</i>, <i>Values</i>,&#160;/EXTRACT,&#160;/FOLD_CASE )</p>
        <p>or</p>
        <p class="Syntax"><i>Result</i> = ORDEREDHASH( <i>Keys</i>,&#160;/FOLD_CASE)</p>
        <p>or</p>
        <p class="Syntax"><i>Result</i> = ORDEREDHASH( <i>Structure</i>,&#160;/EXTRACT,&#160;/FOLD_CASE, /LOWERCASE)</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Key<sub>n</sub></h3>
        <h3 class="Argument">Value<sub>n</sub></h3>
        <h3 class="Argument">Structure</h3>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">EXTRACT</h3>
        <h3 class="Keyword">FOLD_CASE</h3>
        <h3 class="Keyword">LOWERCASE</h3>
        <h3 class="Keyword">NO_COPY</h3>
        <h1 class="ObjMethod"><a name="OrdCount"></a>OrderedHash::Count</h1>
        <p>See <a href="../H/HASH.htm#CountMethod">Hash::Count</a> for detailed documentation.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= orderedhash.Count( [<i>Value</i>] )</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Value</h3>
        <h1 class="ObjMethod"><a name="OrdFilter"></a>OrderedHash::Filter</h1>
        <p>See <a href="../H/HASH.htm#FilterMethod">Hash::Filter</a> for detailed documentation.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= orderedhash.Filter(<i>Function</i>, <i>Args</i>)</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Function</h3>
        <h3 class="Argument">Args</h3>
        <h1 class="ObjMethod"><a name="OrdHasKey"></a>OrderedHash::HasKey</h1>
        <p>See <a href="../H/HASH.htm#HasKeyMethod">Hash::HasKey</a> for detailed documentation.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = orderedhash.HasKey( <i>Keys</i> )</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Keys</h3>
        <h1 class="ObjMethod"><a name="OrdIsEmpty"></a>OrderedHash::IsEmpty</h1>
        <p>See <a href="../H/HASH.htm#IsEmptyMethod">Hash::IsEmpty</a> for detailed documentation.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= orderedhash.IsEmpty( )</p>
        <h1 class="ObjMethod"><a name="OrdKeys"></a>OrderedHash::Keys</h1>
        <p>See <a href="../H/HASH.htm#KeysMethod">Hash::Keys</a> for detailed documentation.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax" style="font-style: normal;"><i>Result</i> = orderedhash.Keys( )</p>
        <h1 class="ObjMethod"><a name="OrdMap"></a>OrderedHash::Map</h1>
        <p>See <a href="../H/HASH.htm#MapMethod">Hash::Map</a> for detailed documentation.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= orderedhash.Map(<i>Function</i>, <i>Args</i>)</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Function</h3>
        <h3 class="Argument">Args</h3>
        <h1 class="ObjMethod"><a name="OrdReduce"></a>OrderedHash::Reduce</h1>
        <p>See <a href="../H/HASH.htm#ReduceMethod">Hash::Reduce</a> for detailed documentation.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= orderedhash.Reduce(<i>Function</i>, <i>Args</i>, /CUMULATIVE, VALUE=<i>value</i>)</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Function</h3>
        <h3 class="Argument">Args</h3>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">CUMULATIVE</h3>
        <p>If this keyword is set, then the <i>Result</i> will be a hash containing all of the intermediate cumulative results instead of just the final result.</p>
        <h3 class="Keyword">VALUE</h3>
        <h1 class="ObjMethod"><a name="OrdRemove"></a>OrderedHash::Remove</h1>
        <p>See <a href="../H/HASH.htm#RemoveMethod">Hash::Remove</a> for detailed documentation.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax">ordered hash.Remove [,&#160;<i>Keys</i>] [,&#160;/ALL]</p>
        <p>or</p>
        <p class="Syntax"><i>Result</i> = orderedhash.Remove( [, <i>Keys</i>] [,&#160;/ALL] )</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Keys</h3>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">ALL</h3>
        <h1 class="ObjMethod"><a name="OrdToStruct"></a>OrderedHash::ToStruct</h1>
        <p>See <a href="../H/HASH.htm#ToStructMethod">Hash::ToStruct</a> for detailed documentation.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = orderedhash.ToStruct(&#160;[, MISSING=<i>value</i>] [, /NO_COPY] [, /RECURSIVE] [, SKIPPED=<i>variable</i>] )</p>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword">MISSING</h3>
        <h3 class="Keyword">NO_COPY</h3>
        <h3 class="Keyword">RECURSIVE</h3>
        <h3 class="Keyword">SKIPPED</h3>
        <h1 class="ObjMethod"><a name="OrdValues"></a>OrderedHash::Values</h1>
        <p>See <a href="../H/HASH.htm#ValuesMethod">Hash::Values</a> for detailed documentation.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = orderedhash.Values( )</p>
        <h1 class="ObjMethod"><a name="OrdWhere"></a>OrderedHash::Where</h1>
        <p>See <a href="../H/HASH.htm#WhereMethod">Hash::Where</a> for detailed documentation.</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result </i>= orderedhash.Where( <i>Value </i>[, <a href="#COMPLEME" class="selected">COMPLEMENT</a>=<i>variable</i>] [, <a href="#COUNT" class="selected">COUNT</a>=<i>variable</i>] [, <a href="#NCOMPLEM" class="selected">NCOMPLEMENT</a>=<i>variable</i>] )\</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Value</h3>
        <h2 class="API">Keywords</h2>
        <h3 class="Keyword"><a name="COMPLEME"></a>COMPLEMENT</h3>
        <h3 class="Keyword"><a name="COUNT"></a>COUNT</h3>
        <h3 class="Keyword"><a name="NCOMPLEM"></a>NCOMPLEMENT</h3>
        <h1>Additional Information on Ordered Hashes</h1>
        <p>See the following sections in HASH for additional information on using ordered hashes:</p>
        <ul>
            <li value="1"><a href="../H/HASH.htm#Concatenating">Concatenating Hashes</a>
            </li>
            <li value="2"><a href="../H/HASH.htm#Comparing">Comparing Hashes</a>
            </li>
            <li value="3"><a href="../H/HASH.htm#HashAccess">Hash Access</a>
            </li>
            <li value="4"><a href="../H/HASH.htm#HashInformation">Information about Hashes</a>
            </li>
        </ul>
        <h3>Iterating over an OrderedHash</h3>
        <p>Just like HASH, you can use the FOREACH operator to iterate over the ordered hash.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>While iterating through an ordered hash you should avoid adding or removing elements. If the ordered hash is changed during the FOREACH, the behavior  is undefined.</p>
        <h2 class="API">Version History</h2>
        <table style="caption-side: top;mc-table-style: url('../../Resources/TableStyles/VersionTable.css');" cellspacing="0" class="TableStyle_VersionTable">
            <col style="width: 40px;" />
            <col style="width: 299px;" />
            <tbody>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_ColSep">
                        <p>8.3</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_ColEnd">
                        <p>Introduced</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">
                        <p>8.4</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">
                        <p>Added Filter, Map, Reduce methods</p>
                        <p>Added FOLD_CASE keyword</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <h2 class="API">See Also</h2>
        <p><a href="../../Creating IDL Programs/Components of the IDL Language/The_Null_Variable.htm">!NULL</a>, <a href="../D/DICTIONARY.htm">DICTIONARY</a>, <a href="../H/HASH.htm">HASH</a>, <a href="../L/LIST.htm#L_826528365_1077832">LIST</a>, <a href="../../Creating IDL Programs/Components of the IDL Language/Logical_Operators.htm">Logical Operators</a>, <a href="../../Creating IDL Programs/Components of the IDL Language/Relational_Operators.htm">Relational Operators</a>, <a href="../L/LAMBDA.htm">LAMBDA</a></p>
        <div class="mp_footer">Â© <span class="DocumentTitleCopyrightYear">2015</span>&#160;<span class="DocumentTitleCopyrightCompanyName">Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation</span>. All Rights Reserved. This information is not subject to the controls of the International Traffic in Arms Regulations (ITAR) or the Export Administration Regulations (EAR). However, this information may be restricted from transfer to various embargoed countries under U.S. laws and regulations.</div>
    </body>
</html>