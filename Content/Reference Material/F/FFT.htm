<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-US" xml:lang="en-US" data-mc-search-type="Stem" data-mc-help-system-file-name="idl.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="Routines (alphabetical)|Routines: F">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>FFT </title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/Doc_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix"> </span><a class="MCBreadcrumbsLink" href="../../images/ref_part1.htm">Routines (alphabetical)</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="F_list.htm">Routines: F</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">FFT</span>
        </div>
        <h1 class="Routine"><a name="F_848155245_676828"></a><a name="kanchor885"></a><a name="kanchor886"></a><a name="kanchor887"></a><a name="kanchor888"></a><a name="F_848155245_24646"></a>FFT </h1>
        <p>The FFT function returns a result equal to the complex, discrete Fourier transform of <i>Array</i>. The result of this function is a single- or double-precision complex array.</p>
        <p>FFT uses a multivariate complex Fourier transform, computed in place with a mixed-radix Fast Fourier Transform algorithm.</p>
        <p>The FFT function uses original Fortran code authored by:</p>
        <p class="indent">RC Singleton, Stanford Research Institute, September 1968</p>
        <p class="indent"><i>NIST Guide to Available Math Software</i>
        </p>
        <p class="indent">Source for module FFT from package GO.</p>
        <p>This code was retrieved from NETLIB on Wednesday, July 5, 1995, at 11:50:07.</p>
        <p>This code was translated by f2c (version 19950721) and modified to resemble C by:</p>
        <p class="indent">MJ Olesen, Queen's University at Kingston, 1995-97</p>
        <p>This code was retrieved from NETLIB (<code>http://www.netlib.org/go/</code>) in January 2000. A significant portion (approximately one-third) of the code has been rewritten or extended for the FFT function.</p>
        <p>The discrete Fourier transform, <i>F</i>(<i>u</i>), of an <i>N</i>-element, one-dimensional function, <i>f</i>(<i>x</i>), is defined as:</p>
        <p>
            <img src="../../images/12_8.jpg" />
        </p>
        <p>And the inverse transform, (<i>Direction</i> &gt; 0), is defined as:</p>
        <p>
            <img src="../../images/12_9.jpg" />
        </p>
        <p>If the keyword OVERWRITE is set, the transform is performed in-place, and the result overwrites the original contents of the array.</p>
        <p>See <a href="../../GuideMe/ImageProcessing/BackgroundFastFourierTransform.htm">Fast Fourier Transform Background</a> for more information on how FFT is used to reduce background noise in imagery.</p>
        <h2 class="API">Example</h2>
        <p>
            <img src="../images/fft_ex1.gif" />
        </p>
        <p>The following code plots the logarithm of the power spectrum of a 100-element index array:</p>
        <p class="Code">p = PLOT(ABS(FFT(FINDGEN(100), -1)), /YLOG)</p>
        <h3>Additional Examples</h3>
        <p>See <a href="#Additional" class="selected">Additional Examples</a> and <a href="../../GuideMe/ImageProcessing/FFTReduceBackgroundNoise.htm">Fast Fourier Transform</a> for more code examples using the FFT function.</p>
        <h2 class="API">Running Time</h2>
        <p>For a one-dimensional FFT, running time is roughly proportional to the total number of points in <i>Array</i> times the sum of its prime factors. Let <i>N</i> be the total number of elements in <i>Array</i>, and decompose <i>N</i> into its prime factors:</p>
        <p>
            <img src="../../images/12_1.jpg" />
        </p>
        <p>Running time is proportional to:</p>
        <p>
            <img src="../../images/12_2.jpg" />
        </p>
        <p>where <i>T</i><sub class="italic">3</sub> ~ <i>4T</i><sub class="italic">2</sub>. For example, the running time of a 263 point FFT is approximately 10 times longer than that of a 264 point FFT, even though there are fewer points. The sum of the prime factors of 263 is 264 (1 + 263), while the sum of the prime factors of 264 is 20 (2 + 2 + 2 + 3 + 11).</p>
        <h2 class="API">Syntax</h2>
        <p class="Syntax"><i>Result</i> = FFT( <i>Array</i> [,&#160;<i>Direction</i>] [,&#160;/<a href="#F_848155245_975127" class="selected">CENTER</a>] [,&#160;<a href="#F_848155245_37862" class="selected">DIMENSION</a>=<i>scalar</i>] [,&#160;/<a href="#F_848155245_882851" class="selected">DOUBLE</a>] [,&#160;/<a href="#F_848155245_37868" class="selected">INVERSE</a>] [,&#160;/<a href="#F_848155245_676843" class="selected">OVERWRITE</a>] )</p>
        <h2 class="API">Return Value</h2>
        <p>FFT returns a complex array that has the same dimensions as the input array. The output array is ordered in the same manner as almost all discrete Fourier transforms. Element 0 contains the zero frequency component, F<sub>0</sub>. The array element F<sub>1</sub> contains the smallest, nonzero positive frequency, which is equal to 1/(N<sub class="italic">i</sub> T<sub class="italic">i</sub>), where N<sub class="italic">i</sub> is the number of elements and T<sub class="italic">i</sub> is the sampling interval of the <i>i</i><sup class="italic">th</sup> dimension. F<sub>2</sub> corresponds to a frequency of 2/(N<sub class="italic">i</sub> T<sub class="italic">i</sub>). Negative frequencies are stored in the reverse order of positive frequencies, ranging from the highest to lowest negative frequencies. </p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>The FFT function can be performed on functions of up to eight (8) dimensions. If a function has <i>n</i> dimensions, IDL performs a transform in each dimension separately, starting with the first dimension and progressing sequentially to dimension <i>n</i>. For example, if the function has two dimensions, IDL first does the FFT row by row, and then column by column. </p>
        <p>For an even number of points in the i<sup class="italic">th</sup> dimension, the frequencies corresponding to the returned complex values are:</p>
        <p class="indent">0, 1/(N<sub class="italic">i</sub>T<sub class="italic">i</sub>), 2/(N<sub class="italic">i</sub>T<sub class="italic">i</sub>), ..., (N<sub class="italic">i</sub>/2–1)/(N<sub class="italic">i</sub>T<sub class="italic">i</sub>), 1/(2T<sub class="italic">i</sub>), –(N<sub class="italic">i</sub>/2–1)/(N<sub class="italic">i</sub>T<sub class="italic">i</sub>), ..., –1/(N<sub class="italic">i</sub>T<sub class="italic">i</sub>)</p>
        <p>where 1/(2T<sub class="italic">i</sub>) is the Nyquist critical frequency.</p>
        <p>For an odd number of points in the i<sup class="italic">th </sup>dimension, the frequencies corresponding to the returned complex values are:</p>
        <p class="indent">0, 1/(N<sub class="italic">i</sub>T<sub class="italic">i</sub>), 2/(N<sub class="italic">i</sub>T<sub class="italic">i</sub>), ..., (N<sub class="italic">i</sub>–1)/2)/(N<sub class="italic">i</sub>T<sub class="italic">i</sub>), –(N<sub class="italic">i</sub>–1)/2)/(N<sub class="italic">i</sub>T<sub class="italic">i</sub>), ..., –1/(N<sub class="italic">i</sub>T<sub class="italic">i</sub>)</p>
        <p>In IDL code, these frequencies may be computed as follows:</p>
        <p class="Code">; N is an integer giving the number of elements in a particular dimension</p>
        <p class="Code">; T is a floating-point number giving the sampling interval</p>
        <p class="Code">X = FINDGEN((N - 1)/2) + 1</p>
        <p class="Code">is_N_even = (N MOD 2) EQ 0</p>
        <p class="Code">if (is_N_even) then $</p>
        <p class="Code_Indented">freq = [0.0, X, N/2, -N/2 + X]/(N*T) $</p>
        <p class="Code">else $</p>
        <p class="Code_Indented">freq = [0.0, X, -(N/2 + 1) + X]/(N*T)</p>
        <h2 class="API">Arguments</h2>
        <h3 class="Argument">Array</h3>
        <p>The array to which the Fast Fourier Transform should be applied. If <i>Array</i> is not of complex type, it is converted to complex type. The dimensions of the result are identical to those of <i>Array</i>. The size of each dimension may be any integer value and does not necessarily have to be an integer power of 2, although powers of 2 are certainly the most efficient.</p>
        <h3 class="Argument">Direction</h3>
        <p><i>Direction</i> is a scalar indicating the direction of the transform, which is negative by convention for the forward transform, and positive for the inverse transform. If <i>Direction</i> is not specified, the forward transform is performed.</p>
        <p>A normalization factor of 1/<i>N</i>, where <i>N</i> is the number of points, is applied during the forward transform.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>When transforming from a real vector to complex and back, it is slightly faster to set <i>Direction</i> to 1 in the real to complex FFT.</p>
        <p>Note also that the value of <i>Direction</i> is ignored if the INVERSE keyword is set.</p>
        <h2 class="API"><a name="F_848155245_676842"></a><a name="F_848155245_676842_PageTOC_FFT_"></a>Keywords</h2>
        <h3 class="Keyword"><a name="F_848155245_975127"></a><a name="F_848155245_975127_Keywords_FFT__"></a>CENTER</h3>
        <p>Set this keyword to shift the zero-frequency component to the center of the spectrum. In the forward direction, when CENTER is set, the resulting Fourier transform has the zero-frequency component shifted to the center of the array. In the reverse direction, when CENTER is set, the input is assumed to be a centered Fourier transform, and the coefficients are shifted back before performing the inverse transform.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>For an odd number of points the zero-frequency component will be in the center. For an even number of points the first element will correspond to the Nyquist frequency component, followed by the remaining frequency components - the zero-frequency component will then be in the center of the remaining components.</p>
        <h3 class="Keyword"><a name="F_848155245_37862"></a>DIMENSION</h3>
        <p>Set this keyword to a scalar indicating the dimension across which to calculate the FFT. If this keyword is not present or is zero, then the FFT is computed across all dimensions of the input array. If this keyword is present, then the FFT is only calculated only across a single dimension. For example, if the dimensions of <i>Array</i> are N1, N2, N3, and DIMENSION is 2, the FFT is calculated only across the second dimension.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If the CENTER keyword is also set, then only the dimension given by the DIMENSION keyword is shifted to the center. The other dimensions remain unshifted.</p>
        <h3 class="Keyword"><a name="F_848155245_882851"></a>DOUBLE</h3>
        <p>Set this keyword to a value other than zero to force the computation to be done in double-precision arithmetic, and to give a result of double-precision complex type. If DOUBLE is set equal to zero, computation is done in single-precision arithmetic and the result is single-precision complex. If DOUBLE is not specified, the data type of the result will match the data type of <i>Array</i>.</p>
        <h3 class="Keyword"><a name="F_848155245_37868"></a>INVERSE</h3>
        <p>Set this keyword to perform an inverse transform. Setting this keyword is equivalent to setting the <i>Direction</i> argument to a positive value. Note, however, that setting INVERSE results in an inverse transform even if <i>Direction</i> is specified as negative.</p>
        <h3 class="Keyword"><a name="F_848155245_676843"></a>OVERWRITE</h3>
        <p>If this keyword is set, and the <i>Array</i> parameter is a variable of complex type, the transform is done “in-place”. The result overwrites the previous contents of the variable. </p>
        <p>For example, to perform a forward, in-place FFT on the variable a:</p>
        <p class="Code">a = FFT(a, -1, /OVERWRITE)</p>
        <h3>Thread Pool Keywords</h3>
        <p>This routine is written to make use of IDL’s <i>thread pool</i>, which can increase execution speed on systems with multiple CPUs. The values stored in the !CPU system variable control whether IDL uses the thread pool for a given computation. In addition, you can use the thread pool keywords TPOOL_MAX_ELTS, TPOOL_MIN_ELTS, and TPOOL_NOTHREAD to override the defaults established by !CPU for a single invocation of this routine. See <a href="../../Creating IDL Programs/Appendices/tpoolkeyw.htm#tpoolkeyw_2501860834_317209">Thread Pool Keywords</a> for details.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Specifically, FFT will use the thread pool to overlap the inner loops of the computation when used on data with dimensions which have factors of 2, 3, 4, or 5. The prime-number DFT does not use the thread pool, as doing so would yield a relatively small benefit for the complexity it would introduce. Our experience shows that the improvement in performance from using the thread pool for FFT is highly dependent upon many factors (data length and dimensions, single <i>vs.</i> double precision, operating system, and hardware) and can vary between platforms.</p>
        <h2 class="API"><a name="Additional"></a>Additional Examples</h2>
        <h3>Example 1</h3>
        <p>
            <img src="../images/fft_ex2.gif" />
        </p>
        <p>In this example we display the power spectrum of a 100-element vector sampled at a rate of 0.1 seconds per point. The 0 frequency component is displayed at the center of the plot, and frequency is plotted on the x-axis:</p>
        <p class="Code">; Define the number of points and the interval:<br />N = 100<br />T = 0.1<br /><br />; Midpoint+1 is the most negative frequency subscript:<br />N21 = N/2 + 1<br />; The array of subscripts:<br />F = INDGEN(N)<br />; Insert negative frequencies in elements F(N/2 +1), ..., F(N-1):<br />F[N21] = N21 -N + FINDGEN(N21-2)<br /><br />; Compute T0 frequency:<br />F = F/(N*T)<br /><br />; Shift so that the most negative frequency is plotted first:<br />p = PLOT(SHIFT(F, -N21), SHIFT(ABS(FFT(F, -1)), -N21), /YLOG)<br /></p>
        <h3>Example 2</h3>
        <p>
            <img src="../images/fft_ex3.gif" />
        </p>
        <p>In this example we compute the FFT of two-dimensional images:</p>
        <p class="Code">; Create a cosine wave damped by an exponential<br /></p>
        <p class="Code">n = 256</p>
        <p class="Code">x = FINDGEN(n)</p>
        <p class="Code">y = COS(x*!PI/6)*EXP(-((x - n/2)/30)^2/2)</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Construct a two-dimensional image of the wave</p>
        <p class="Code">z = REBIN(y, n, n)</p>
        <p class="Code">; Add two different rotations to simulate a crystal structure</p>
        <p class="Code">z = ROT(z, 10) + ROT(z, -45)</p>
        <p class="Code">LOADCT, 39</p>
        <p class="Code">p = IMAGE(BYTSCL(z), LAYOUT = [2, 2, 1])</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Compute the two-dimensional FFT</p>
        <p class="Code">f = FFT(z)</p>
        <p class="Code">logpower = ALOG10(ABS(f)^2) ; log of Fourier power spectrum</p>
        <p class="Code">p = IMAGE(BYTSCL(logpower), LAYOUT = [2, 2, 2], /CURRENT)</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Compute the FFT only along the first dimension</p>
        <p class="Code">f = FFT(z, DIMENSION=1)</p>
        <p class="Code">logpower = ALOG10(ABS(f)^2) ; log of Fourier power spectrum</p>
        <p class="Code">p = IMAGE(BYTSCL(logpower), LAYOUT = [2, 2, 3], /CURRENT)</p>
        <p class="Code">&#160;</p>
        <p class="Code">; Compute the FFT only along the second dimension.</p>
        <p class="Code">f = FFT(z, DIMENSION=2)</p>
        <p class="Code">logpower = ALOG10(ABS(f)^2) ; log of Fourier power spectrum</p>
        <p class="Code">p = IMAGE(BYTSCL(logpower), LAYOUT = [2, 2, 4], /CURRENT)</p>
        <h2 class="API">Version History</h2>
        <table style="caption-side: top;mc-table-style: url('../../Resources/TableStyles/VersionTable.css');" cellspacing="0" class="TableStyle_VersionTable">
            <col />
            <col />
            <tbody>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_ColSep">
                        <p>Original</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_ColEnd">
                        <p>Introduced</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowSep_ColSep">
                        <p>7.1</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowSep_ColEnd">
                        <p>Added CENTER keyword</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">8.4.1</td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">Bug fix: When both DIMENSION and CENTER are set, only the dimension given by DIMENSION is shifted to the center; all other dimensions remain unshifted.</td>
                </tr>
            </tbody>
        </table>
        <h2 class="API">See Also</h2>
        <p><a href="FFT_PowerSpectrum.htm">FFT_POWERSPECTRUM</a>, <a href="../H/HILBERT.htm#H_835179117_36176">HILBERT</a></p>
        <div class="mp_footer">© <span class="DocumentTitleCopyrightYear">2015</span>&#160;<span class="DocumentTitleCopyrightCompanyName">Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation</span>. All Rights Reserved. This information is not subject to the controls of the International Traffic in Arms Regulations (ITAR) or the Export Administration Regulations (EAR). However, this information may be restricted from transfer to various embargoed countries under U.S. laws and regulations.</div>
    </body>
</html>