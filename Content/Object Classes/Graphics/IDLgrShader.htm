<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-US" xml:lang="en-US" data-mc-search-type="Stem" data-mc-help-system-file-name="idl.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="Routines (alphabetical)|Object Classes|Graphics Object Classes">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>IDLgrShader</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/TableStyles/Description.css" rel="stylesheet" />
        <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/Doc_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix"> </span><a class="MCBreadcrumbsLink" href="../../images/ref_part1.htm">Routines (alphabetical)</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="../ObjectClasses.htm">Object Classes</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="objects_gr.htm">Graphics Object Classes</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">IDLgrShader</span>
        </div>
        <h1 class="ObjClass"><a name="objects_gr_2157407275_1789376"></a><a name="objects_gr_2157407275_19117"></a>IDLgrShader</h1>
        <p>
            <MadCap:conditionalText data-mc-conditions="Reference Material.Online_Help_Only"><a href="#objects_gr_2157407275_1807305" class="selected">Superclasses</a> | <a href="#objects_gr_2157407275_1789397" class="selected">Creation</a> | <a href="#objects_gr_2157407275_1789403" class="selected">Properties</a> | <a href="#objects_gr_2157407275_1795196" class="selected">Methods</a> | <a href="#objects_gr_2157407275_1789683" class="selected">Examples</a> | <a href="#objects_gr_2157407275_1794416" class="selected">Version History</a> | <a href="#objects_gr_2157407275_1807112" class="selected">See Also</a></MadCap:conditionalText>
        </p>
        <p>A <a name="kanchor3792"></a><i>shader object</i> provides access to the hardware-based processing power available on some modern graphics cards. This allows computationally intensive image processing operations to be delegated to the Graphics Processing Unit (GPU) of a suitable graphics card, dramatically increasing performance and interactivity. A shader program can perform image filtering operations, complex lighting and shading calculations, interactive blending of multiple textures, animation of object vertices, or any combination of these. </p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Setting IDLgrImage <a href="IDLgrImage_Properties.htm#objects_gr_2157407275_1665804">RENDER_METHOD</a>=1 (do <i>not</i> render image as texture-mapped polygon) disables all shader functionality including the software-based alternative. </p>
        <h2 class="API">OpenGL Conversion of Im<a name="kanchor3793"></a>age Data to Texture Data</h2>
        <p>It is important to understand how OpenGL converts a high precision image to a texture map before writing a shader program. The graphics card vendor ultimately decides what formats are supported. Using the IDLgrImage <a href="IDLgrImage_Properties.htm#objects_gr_2157407275_1801217">INTERNAL_DATA_TYPE</a> property, you tell OpenGL in what format you would like the texture stored. The following table describes the relationship between OpenGL types and the INTERNAL_DATA_TYPE property value. </p>
        <table style="mc-table-style: url('../../Resources/TableStyles/Description.css');margin-left: 0;margin-right: auto;caption-side: bottom;" cellspacing="0" class="TableStyle_Description">
            <col />
            <col />
            <col />
            <thead>
                <tr>
                    <td class="TableStyle_Description_Head_0_0_RowSep_ColSep">
                        <p>OpenGL </p>
                    </td>
                    <td class="TableStyle_Description_Head_0_0_RowSep_ColSep">
                        <p> INTERNAL_DATA_TYPE Setting</p>
                    </td>
                    <td class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
                        <p>Description</p>
                    </td>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>RGBA8</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>1</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>8-bit unsigned bytes per channel, widely supported</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>RGBA16F</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>2</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p>16-bit floating point with 1 sign bit, 5 exponent bits and 10 mantissa bits</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep">
                        <p>RGBA32F</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep">
                        <p>3</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowEnd_ColEnd">
                        <p>32-bit floating point, which is standard IEEE float format</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>An IDLgrImage will accept data of type BYTE, UINT, INT and FLOAT. When the texture map is created the data from IDLgrImage is converted to the type specified in <a href="IDLgrImage_Properties.htm#objects_gr_2157407275_1801217">INTERNAL_DATA_TYPE</a>.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>If your image data is floating point, your fragment shader must scale it to the range 0.0 to 1.0 before writing it to <code>gl_FragColor</code> or you need to scale it to the range of 0.0 to 1.0 before setting it on the IDlgrImage. </p>
        <p>If INTERNAL_DATA_TYPE is set to floating point (INTERNAL_DATA_TYPE equals 2 or 3), image data conversion is performed by OpenGL as follows where <i>c</i> is the color component being converted:</p>
        <table style="mc-table-style: url('../../Resources/TableStyles/Description.css');margin-left: 0;margin-right: auto;caption-side: bottom;" cellspacing="0" class="TableStyle_Description">
            <col />
            <col />
            <thead>
                <tr>
                    <td class="TableStyle_Description_Head_0_0_RowSep_ColSep">
                        <p>Image Data Type</p>
                    </td>
                    <td class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
                        <p>Floating Point Conversion</p>
                    </td>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>BYTE</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p><i>c</i>/(2<sup>8</sup>-1)</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>UINT</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p><i>c</i>/(2<sup>16</sup>-1)</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>INT</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>(2<i>c</i>+1)/(2<sup>16</sup>-1)</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
                        <p>FLOAT</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowEnd_ColEnd">
                        <p><i>c</i>
                        </p>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>If INTERNAL_DATA_TYPE is 1 (8-bit unsigned byte), then the image data is scaled to unsigned byte. This is equivalent to a linear BYTSCL from the entire type range (for example, 0-65535) to unsigned byte (0-255). </p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>INTERNAL_DATA_TYPE of 0, the default, maintains backwards compatibility by converting the image data to byte without scaling.</p>
        <p>To avoid data loss during conversion, you should choose an internal data type with sufficient precision to hold your image data. For example, with a 16-bit UINT image that uses the full range of 0-65535, if you set INTERNAL_DATA_TYPE to 2 (16-bit floating point), your image will still be converted to the range of 0.0 to 1.0, but some precision will be lost (due to the mantissa of a 16-bit float being only 10 bits). If you need a higher level of precision, set INTERNAL_DATA_TYPE to 3 (32-bit floating point). However, on some cards there may be a performance penalty associated with the higher level of precision, and requesting 32-bit floating point will certainly require more memory.</p>
        <p>Once the image has been converted to a texture map it can be sampled by the shader. The GLSL procedure, <code>texture2D</code>, returns the sampled texel in floating point (0.0 to 1.0). Therefore, if the INTERNAL_DATA_TYPE is 1 (unsigned byte) the texel is converted to floating point, using <i>c</i>/(2<sup>8</sup> - 1), before being returned.</p>
        <h2 class="API"><a name="objects_gr_2157407275_1807305"></a>Superclasses</h2>
        <p>None</p>
        <h2 class="API"><a name="objects_gr_2157407275_1789397"></a>Creation</h2>
        <p>See <a href="IDLgrShader__Init.htm#objects_gr_2157407275_1795439">IDLgrShader::Init</a>.</p>
        <h2 class="API"><a name="objects_gr_2157407275_1789403"></a>Properties</h2>
        <p>Objects of this class have the following properties. See <a href="IDLgrShader_Properties.htm#objects_gr_2157407275_1794432">IDLgrShader Properties</a> for details on individual properties.</p>
        <ul>
            <li value="1"><a href="IDLgrShader_Properties.htm#objects_gr_2157407275_1807662">CACHE_RESULT</a>
            </li>
            <li value="2"><a href="IDLgrShader_Properties.htm#objects_gr_2157407275_1794789">FORCE_FILTER</a>
            </li>
            <li value="3"><a href="IDLgrShader_Properties.htm#objects_gr_2157407275_1812474">FRAGMENT_PROGRAM_FILENAME</a>
            </li>
            <li value="4"><a href="IDLgrShader_Properties.htm#objects_gr_2157407275_1794830">FRAGMENT_PROGRAM_STRING</a>
            </li>
            <li value="5"><a href="IDLgrShader_Properties.htm#objects_gr_2157407275_1807807">OUTPUT_DATA_TYPE</a>
            </li>
            <li value="6"><a href="IDLgrShader_Properties.htm#objects_gr_2157407275_1794920">VERTEX_PROGRAM_FILENAME</a>
            </li>
            <li value="7"><a href="IDLgrShader_Properties.htm#objects_gr_2157407275_1794890">VERTEX_PROGRAM_STRING</a>
            </li>
        </ul>
        <p>In addition, objects of this class inherit the properties of all superclasses of this class, if any.</p>
        <h2 class="API"><a name="objects_gr_2157407275_1795196"></a><a name="kanchor3794"></a>Methods</h2>
        <p>This class has the following methods:</p>
        <ul>
            <li value="1"><a href="IDLgrShader__Cleanup.htm#objects_gr_2157407275_1795215">IDLgrShader::Cleanup</a>
            </li>
            <li value="2"><a href="IDLgrShader__Filter.htm#objects_gr_2157407275_1795293">IDLgrShader::Filter</a>
            </li>
            <li value="3"><a href="IDLgrShader__GetProperty.htm#objects_gr_2157407275_1795604">IDLgrShader::GetProperty</a>
            </li>
            <li value="4"><a href="IDLgrShader__GetUniformV.htm#objects_gr_2157407275_1795988">IDLgrShader::GetUniformVariable</a>
            </li>
            <li value="5"><a href="IDLgrShader__Init.htm#objects_gr_2157407275_1795439">IDLgrShader::Init</a>
            </li>
            <li value="6"><a href="IDLgrShader__SetProperty.htm#objects_gr_2157407275_1795508">IDLgrShader::SetProperty</a>
            </li>
            <li value="7"><a href="IDLgrShader__SetUniformV.htm#objects_gr_2157407275_1796144">IDLgrShader::SetUniformVariable</a>
            </li>
        </ul>
        <p>In addition, this class inherits the methods of its superclasses, if any.</p>
        <h2 class="API"><a name="objects_gr_2157407275_1789683"></a>Examples </h2>
        <h3><a name="kanchor3795"></a>Altering RGB Levels Using a Shader</h3>
        <p>This shader program example lets you interactively apply color level correction to an image when you view it. This does not modify the image data itself. This example places the original image data in an IDLgrImage object and attaches the custom shader object using the SHADER property. It then creates a simple user interface that lets you alter the color levels and passes these values to the shader program in a named uniform variable. The Filter method implements the software fallback. When the correct graphics hardware is unavailable, IDL automatically calls the Filter method. </p>
        <p class="ExampleCode">See <code>shader_rgb_doc__define<a name="kanchor3796"></a>.pro</code>, located in the <code>examples/doc/shaders</code> subdirectory of the IDL distribution, for the complete, working example. Run the example by creating an instance of the object at the IDL command prompt using <code>orgbshader=OBJ_NEW('shader_rgb_doc')</code> or view the file in an IDL Editor window by entering <code>.EDIT shader_rgb_doc__define.pro</code>. </p>
        <h3><a name="kanchor3797"></a>Applying Lookup Tables Using Shaders</h3>
        <p>The IMAGE_1D property on the IDLgrImage object lets you load color lookup table (LUT) values into a texture map and pass the LUT to a shader program. LUTs are useful for a number of tasks including:</p>
        <ul>
            <li value="1">Displaying palletized images. </li>
            <li value="2">Adding color to greyscale images. </li>
            <li value="3">Optimizing the evaluation of expensive functions. For example, if your image is 8-bit greyscale and you need to apply an expensive function to each pixel it is normally more efficient to pass each of the 256 greyscale values to the function and store the result in a 256 entry LUT used for drawing.</li>
            <li value="4">Adjusting image brightness, gamma, contrast, color balance and other settings.</li>
            <li value="5">Adjusting data ranges such as converting an 11-bit image to 8-bit for display. </li>
        </ul>
        <p class="ExampleCode">See <code>shader_lut_doc__define<a name="kanchor3798"></a>.pro</code>, located in the <code>examples/doc/shaders</code> subdirectory of the IDL distribution, for the complete, working example. Run the example by creating an instance of the object at the IDL command prompt using <code>oLUTshader=OBJ_NEW('shader_lut_doc')</code> or view the file in an IDL Editor window by entering <code>.EDIT shader_lut_doc__define.pro</code>. </p>
        <h3>Displaying a 16-bit UINT Image</h3>
        <p>In this example, the input image (<i>uiImageData</i>) is a 16-bit unsigned integer greyscale image that uses the full range of 0 to 65535. The goal is to display the entire range using a linear byte scale. Traditionally we'd use the BYTSCL function in IDL prior to loading data into the IDLgrImage object:</p>
        <p class="Code">ScaledImData = BYTSCL(uiImageData, MIN=0, MAX=65535)</p>
        <p class="Code">oImage = OBJ_NEW('IDLgrImage', ScaledImData, /GREYSCALE)</p>
        <p>To have the GPU do the scaling, load the unscaled image data into the IDLgrImage and set INTERNAL_DATA_TYPE to 3 (32-bit floating point):</p>
        <p class="Code">oImage = OBJ_NEW('IDLgrImage', uiImageData, $</p>
        <p class="Code">    INTERNAL_DATA_TYPE=3, /GREYSCALE, SHADER=oShader)</p>
        <p>The fragment shader is extremely simple. Here, the reserved uniform variable, <code>_IDL_ImageTexture</code>, represents the base image in IDL:</p>
        <p class="Code">uniform sampler2D _IDL_ImageTexture;</p>
        <p class="Code">&#160;</p>
        <p class="Code">void main(void) </p>
        <p class="Code">{</p>
        <p class="Code">gl_FragColor = texture2D(_IDL_ImageTexture, gl_TexCoord[0].xy);</p>
        <p class="Code">}</p>
        <p>All we are doing is reading the texel with <code>texture2D</code> and setting it in <code>gl_FragColor</code>. You will notice that there is no explicit conversion to byte because this is handled by OpenGL. The value written into <code>gl_FragColor</code> is a GLSL type <code>vec4</code> (4 floating point values, RGBA). OpenGL clamps each floating point value to the range 0.0 to 1.0 and converts it to unsigned byte where 0.0 maps to 0 and 1.0 maps to 255. So all we have to do is read the texel value from <code>_IDL_ImageTexture</code> and set it into <code>gl_FragColor</code>.</p>
        <h3>Displaying an 11-bit UINT Image</h3>
        <p>An 11-bit unsigned integer image is usually stored in a 16-bit UINT array, but with only 2048 (2<sup>11</sup>) values used. For this example, let's say the minimum value is 0 and the max is 2047. Traditionally this would be converted to byte as follows: </p>
        <p class="Code">ScaledImData = BYTSCL(uiImageData, MIN=0, MAX=2047)</p>
        <p class="Code">oImage = OBJ_NEW('IDLgrImage', ScaledImData, /GREYSCALE)</p>
        <p>To scale on the GPU we again load the image with the original data. This time INTERNAL_DATA_TYPE can be set to 2 (16-bit float) as this can hold 11-bit unsigned integer data without loss of precision:</p>
        <p class="Code">oImage = OBJ_NEW('IDLgrImage', uiImageData, $</p>
        <p class="Code">&#160;&#160;&#160;INTERNAL_DATA_TYPE=2, /GREYSCALE, SHADER=oShader)</p>
        <p>The fragment shader looks like the following where <code>_IDL_ImageTexture</code> represents the base image in IDL:</p>
        <p class="Code">uniform sampler2D <code>_IDL_ImageTexture</code>;</p>
        <p class="Code">&#160;</p>
        <p class="Code">void main(void) </p>
        <p class="Code">{</p>
        <p class="Code">gl_FragColor = texture2D(<code>_IDL_ImageTexture</code>, gl_TexCoord[0].xy) * </p>
        <p class="Code">&#160;&#160;&#160;(65535.0 / 2047.0);</p>
        <p class="Code">}</p>
        <p>The only difference between this 11-bit example and the previous 16-bit example is the scaling of each texel. When the 16-bit UINT image is converted to floating point, the equation <i>c</i>/(2<sup>16</sup> - 1) is used so 65535 maps to 1.0. However, the maximum value in the 11-bit image is 2047, which is 0.031235 when converted to floating point. This needs scaled to 1.0 before being assigned to <code>gl_FragColor</code> if we want 2047 (image maximum) to map to 255 (maximum intensity) when the byte conversion is done. (Remember a value of 1.0 in <code>gl_FragColor</code> is mapped to 255.)</p>
        <p>It's possible to implement the full byte scale functionality on the GPU, and let the user interactively specify the input min/max range by passing them as uniform variables. There is a performance advantage to doing this on the GPU as the image data only needs to be loaded once and the byte scale parameters are changed simply by modifying uniform variables. See <a href="IDLgrShaderBytscl.htm#objects_gr_2157407275_1796318">IDLgrShaderBytscl</a> and the associated example to see how this can be achieved.</p>
        <h3>Displaying an 11-bit UINT Image with Contrast Adjustment</h3>
        <p>The previous example applied a linear scaling to the 11-bit data to convert it to 8-bit for display purposes. Sometimes it's useful to apply a non-linear function when converting to 8-bit to perform contrast adjustments to compensate for the non-linear response of the display device (monitor, LCD, projector. and so on).</p>
        <p>For an 11-bit image this can be achieved using a LUT with 2048 entries where each entry contains an 8-bit value. This is sometimes referred to as an 11-bit in, 8-bit out LUT, which uses an 11-bit value to index the LUT and returns an 8-bit value.</p>
        <p>This is relatively simple to implement on the GPU. First create the 2048 entry contrast enhancement LUT and load it into an IDLgrImage which will be passed to the shader as a texture map.</p>
        <p class="Code">x = 2*!PI/256 * FINDGEN(256) ;; 0 to 2 pi    </p>
        <p class="Code">lut = BYTE(BINDGEN(256) - sin(x)*30)</p>
        <p class="Code">; Stretch to 2048 entry LUT.</p>
        <p class="Code">lut = CONGRID(lut, 2048)</p>
        <p class="Code">oLUT = OBJ_NEW('IDLgrImage', lut, /IMAGE_1D, /GREYSCALE)</p>
        <p class="Code">oShader-&gt;SetUniformVariable, 'lut', oLUT</p>
        <p>The image is created as before:</p>
        <p class="Code">oImage = OBJ_NEW('IDLgrImage', uiImageData, $</p>
        <p class="Code">&#160;&#160;&#160;INTERNAL_DATA_TYPE=2, /GREYSCALE, SHADER=oShader)</p>
        <p>The fragment shader looks like the following where <code>_IDL_ImageTexture</code> represents the base image in IDL and <i>lut</i> is the lookup table.:</p>
        <p class="Code">uniform sampler2D <code>_IDL_ImageTexture</code>;</p>
        <p class="Code">uniform sampler1D lut;</p>
        <p class="Code">&#160;</p>
        <p class="Code">void main(void) </p>
        <p class="Code">{</p>
        <p class="Code">    float i = texture2D(<code>_IDL_ImageTexture</code>, gl_TexCoord[0].xy).r * </p>
        <p class="Code">           (65535.0/2048.0);</p>
        <p class="Code">    gl_FragColor = texture1D(lut, i);</p>
        <p class="Code">}</p>
        <p>As you can see the texel value is scaled before being used as an index into the LUT. </p>
        <p>The following figure shows how the 11-bit to 8-bit LUT is indexed. Only a fraction of the input data range is used (0-2047 out of a possible 0-65535). As 2047 (0.0312 when converted to float) is the maximum value, this should index to the top entry in the LUT. So we need to scale it to 1.0 by multiplying by 32.015. Now the range of values in the image (0-2047) index the entire range of entries in the LUT. </p>
        <p>
            <img src="../../images/shader_11to8lut.gif" style="margin-left: 3.2724px;margin-top: 1.4544px;margin-right: 2.728088px;margin-bottom: 0.726493px;" />
        </p>
        <p>Although this could be done on the CPU, it is much more efficient to do it on the GPU since the image data only needs to be loaded once and the display compensation curve can be modified simply by changing data in the IDLgrImage holding the LUT.</p>
        <h3>Use an Attribute Variable to Replicate the Effect of Wind on a Set of Particles</h3>
        <p>The following example uses an attribute variable to replicate the effect of wind on a set of particles. Each particle has an initial position and a velocity assigned to it. The initial position of the particle can be easily represented by the already-familiar vertex [<i>x</i>, <i>y</i>, <i>z</i>] information. </p>
        <p class="ExampleCode">See <code>shader_vertexwinds_doc<a name="kanchor3799"></a>.pro</code>, located in the <code>examples/doc/shaders</code> subdirectory of the IDL distribution, for the complete, working example. Run the example procedure by entering <code>shader_vertexwinds_doc</code> at the IDL command prompt or view the file in an IDL Editor window by entering <code>.EDIT shader_vertexwinds_doc.pro</code>. </p>
        <h3>Adding LIghting and Shading to a Surface</h3>
        <p>This example displays an IDLgrSurface, and uses the vertex shader to displace part of it up and down in an animation sequence. It also changes the color of the displaced part slightly for additional emphasis. An ambient light and a positional light illuminate the surface. </p>
        <p class="ExampleCode">See <code>shader_lightsurf_doc<a name="kanchor3800"></a>.pro</code>, located in the <code>examples/doc/shaders</code> subdirectory of the IDL distribution, for the complete, working example. Run the example procedure by entering <code>shader_lightsurf_doc</code> at the IDL command prompt or view the file in an IDL Editor window by entering <code>.EDIT shader_lightsurf_doc.pro</code>. </p>
        <h3>Manipulating Multiple Textures Using Shaders</h3>
        <p>The following multi-texturing shader program example provides the ability to interactively scrape away the section of clouds under the mouse cursor to see the earth below. Because this requires blending only a<i> section </i>of the image, using a shader program in this case is far easier than duplicating the outcome using only IDL. </p>
        <p class="ExampleCode">See <code>shader_multitexture_doc<a name="kanchor3801"></a>.pro</code>, located in the <code>examples/doc/shaders</code> subdirectory of the IDL distribution, for the complete, working example. Run the example procedure by entering <code>shader_multitexture_doc</code> at the IDL command prompt or view the file in an IDL Editor window by entering <code>.EDIT shader_multitexture_doc.pro</code>. </p>
        <h3>Rotating Earth with Multiple Textures</h3>
        <p>This example loads three images into textures: a base day image of the earth, a night image, and an image of clouds. It then draws the rotating earth showing a day scene on one side and a night scene (lights of big cities) on the other. </p>
        <p>
            <img src="../../images/shader_earthdaynight.gif" style="margin-left: 1.90872px;margin-right: 0.545763px;margin-bottom: 0.5457681px;" />
        </p>
        <p>In the IDL code:</p>
        <ul>
            <li value="1">Create three IDLgrImage objects to hold the daytime, nighttime, and cloud textures. Assign the object references for these image objects to uniform variables, using the IDLgrShader::SetUniformVariable method.</li>
        </ul>
        <p class="Code_Indented">; Tell the shader program about our textures.</p>
        <p class="Code_Indented">oShader-&gt;SetUniformVariable, 'EarthDay', oDay</p>
        <p class="Code_Indented">oShader-&gt;SetUniformVariable, 'EarthNight', oNight</p>
        <p class="Code_Indented">oShader-&gt;SetUniformVariable, 'EarthCloudGloss', oClouds</p>
        <ul>
            <li value="1">Use the SetMultiTextureCoord method for IDLgrPolygon to set texture coordinates (<i>tc</i>) for the textures.</li>
        </ul>
        <p class="Code_Indented">oEarth-&gt;SetMultiTextureCoord, 0, tc</p>
        <p class="NoteIndented">If the textures did not share the same coordinates, you could call SetMultiTextureCoord multiple times.</p>
        <p>In the Shader Program:</p>
        <ul>
            <li value="1">In the vertex program (<code>earthVert.txt</code>), fetch the texture coordinates for both the daytime and nighttime textures from the predefined GLSL uniform variable <code>gl_MultiTexCoord[</code><code><i>n</i></code><code>]</code>, where <code><i>n</i></code> corresponds to the numbers used in the IDLgrPolygon::SetMultiTextureCoord method calls. These texture coordinates are passed to the fragment shader with varying variables.</li>
            <li value="2">The fragment shader (<code>earthFrag.txt</code>) then decides on what side of the earth the fragment is on, and chooses the appropriate texture and texture coordinates to use to look up the texel value to use as the fragment color.</li>
        </ul>
        <p>This shader program was taken directly from Chapter 10 of the “Orange Book” (“OpenGL Shading Language”, Second Edition, by Randi J. Rost) and required no modifications to work with the IDL application, <code>shader_earthmulti.pro</code>.</p>
        <p class="ExampleCode">See <code>shader_earthmulti<a name="kanchor3802"></a>.pro</code>, located in the <code>examples/doc/shaders</code> subdirectory of the IDL distribution, for the complete, working example. Run the example procedure by entering <code>shader_earthmulti</code> at the IDL command prompt or view the file in an IDL Editor window by entering <code>.EDIT shader_earthmulti.pro</code>. The associated shader program files<code> earthVert.txt</code> and <code>earthFrag.txt</code> are located in the same directory. </p>
        <h2 class="API"><a name="objects_gr_2157407275_1794416"></a>Version History</h2>
        <table style="mc-table-style: url('../../Resources/TableStyles/VersionTable.css');margin-left: 0;margin-right: auto;caption-side: top;" cellspacing="0" class="TableStyle_VersionTable">
            <col />
            <col />
            <tbody>
                <tr>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">
                        <p>6.4</p>
                    </td>
                    <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">
                        <p>Introduced</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <h2 class="API"><a name="objects_gr_2157407275_1807112"></a>See Also </h2>
        <p><a href="IDLgrShaderBytscl.htm#objects_gr_2157407275_1796318">IDLgrShaderBytscl</a>, <a href="IDLgrShaderConvol3.htm#objects_gr_2157407275_1810150">IDLgrShaderConvol3</a>, <a href="IDLgrFilterChain.htm#objects_gr_2157407275_1808615">IDLgrFilterChain</a></p>
        <div class="mp_footer">© <span class="DocumentTitleCopyrightYear">2015</span>&#160;<span class="DocumentTitleCopyrightCompanyName">Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation</span>. All Rights Reserved. This information is not subject to the controls of the International Traffic in Arms Regulations (ITAR) or the Export Administration Regulations (EAR). However, this information may be restricted from transfer to various embargoed countries under U.S. laws and regulations.</div>
    </body>
</html>