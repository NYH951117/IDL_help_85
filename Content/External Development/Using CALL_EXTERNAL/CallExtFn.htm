<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-US" xml:lang="en-US" data-mc-search-type="Stem" data-mc-help-system-file-name="idl.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="Additional Topics|External Development Guide|Using CALL_EXTERNAL">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>The CALL_EXTERNAL Function</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/Stylesheets/Doc_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix"> </span><a class="MCBreadcrumbsLink" href="../../OtherTopics.htm">Additional Topics</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="../EDG.htm">External Development Guide</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="CALL_EXTERNAL.htm">Using CALL_EXTERNAL</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">The CALL_EXTERNAL Function</span>
        </div>
        <h1><a name="kanchor5427"></a>The CALL_EXTERNAL Function</h1>
        <p>IDL allows you to integrate programs written in other languages with your IDL code, either by calling a compiled function from an IDL program or by linking a compiled function into IDL’s internal system routine table:</p>
        <ul>
            <li value="1">The <b>CALL_EXTERNAL</b> function allows you to call external functions (written in C/C++ or Fortran, for example) from your IDL programs. </li>
            <li value="2">An alternative to <b>CALL_EXTERNAL</b> is to write an IDL system routine and merge it with IDL at runtime. Routines merged in this fashion are added to IDL’s internal system routine table and are available in the same manner as IDL built-in routines. This technique is discussed in <a href="../Adding System Routines/AddingSystRoutines.htm">Adding System Routines</a>. To write a system routine, you will need to understand the IDL internals.</li>
        </ul>
        <p>This topic covers the basics of using <b>CALL_EXTERNAL</b> from IDL, then discusses platform-specific options for the UNIX and Windows versions of IDL. It can be helpful to refer to the documentation for <a href="../../Reference Material/C/CALL_EXTERNAL.htm">CALL_EXTERNAL</a> when reading this material.</p>
        <p>The <b>CALL_EXTERNAL</b> function loads and calls routines contained in shareable object libraries. Arguments passed to IDL are passed to this external code, and returned data from the external code is automatically presented as the result from <b>CALL_EXTERNAL</b> as an IDL variable. IDL and the called routine share the same process address space. Because of this, <b>CALL_EXTERNAL</b> avoids the overhead of process creation of the SPAWN routine. In addition, the shareable object library is only loaded the first time it is referenced, saving overhead on subsequent calls.</p>
        <p><b>CALL_EXTERNAL</b> is much easier to use than writing a system routine. Unlike a system routine, however, <b>CALL_EXTERNAL</b> does not check the type or number of parameters. Programming errors in the external routine are likely to result in corrupted data (either in the routine or in IDL) or to cause IDL to crash. See <a href="#Common" class="selected">Common CALL_EXTERNAL Pitfalls</a>  for help in avoiding some of the more common mistakes.</p>
        <h2>Example Code in the IDL Distribution</h2>
        <p>This chapter contains examples of <b>CALL_EXTERNAL</b> use. All of the code for these examples, along with additional examples, can be found in the <code>call_external</code> subdirectory of the <code>external</code> directory of the IDL distribution. The C language examples use the <a href="../../Reference Material/M/MAKE_DLL.htm">MAKE_DLL</a> procedure, and can therefore be easily run on any platform supported by IDL. To build the sharable library containing the external C code and then run all of the provided examples, execute the following IDL statements:</p>
        <p class="Code">PUSHD, FILEPATH(’’,SUBDIRECTORY=[’external’,’call_external’,’C’]) ALL_CALLEXT_EXAMPLES</p>
        <p class="Code">POPD</p>
        <p>Additional information on these examples, including details on running the individual examples, can be found in the README file located in that directory.</p>
        <h2>CALL_EXTERNAL Compared to UNIX Child Process</h2>
        <p>In many situations, a UNIX IDL user has a choice of using the <b>SPAWN</b> procedure to start a child process that executes external code and communicates with IDL via a pipe connecting the two processes. The advantages of this approach are:</p>
        <ul>
            <li value="1">Simplicity.</li>
            <li value="2">The processes do not share address space, and are therefore protected from each other’s mistakes.</li>
        </ul>
        <p>The advantages of <b>CALL_EXTERNAL</b> are:</p>
        <ul>
            <li value="1">IDL and the called routine share the same memory and data space. Although this can be a disadvantage (as noted above) there are times where sharing address space is advantageous. For example, large data can be easily and cheaply shared in this manner.</li>
            <li value="2"><b>CALL_EXTERNAL</b> avoids the overhead of process creation and parameter passing.</li>
            <li value="3">The shareable object library containing the called routine is only loaded the first time it is referenced, whereas a <a href="../../Reference Material/S/SPAWN.htm">SPAWN</a>ed process must be created for each use of the external code.</li>
        </ul>
        <h2>Compilation and Linking of External Code</h2>
        <p>Each operating system requires different compilation and link statements for producing a shareable object suitable for usage with <a href="../../Reference Material/C/CALL_EXTERNAL.htm">CALL_EXTERNAL</a>. This is even true between different implementations of a common operating system family. For example, most UNIX systems require unique options despite their shared heritage. You must consult your system and compiler documentation to find the appropriate options for your system.</p>
        <p>The IDL <a href="../../Reference Material/M/MAKE_DLL.htm">MAKE_DLL</a> procedure provides a portable, high-level mechanism for building sharable libraries from code written in the C language. In many situations, this procedure can completely handle the task of building sharable libraries to be used with <b>CALL_EXTERNAL</b>. <b>MAKE_DLL</b> requires that you have a C compiler installed on your system that is compatible with the compiler described by the IDL <b>!MAKE_DLL</b> system variable.</p>
        <p>The <b>!MAKE_DLL</b> system variable is used by the <b>MAKE_DLL</b> procedure to construct C compiler and linker commands appropriate for the target platform. If you do not use <b>MAKE_DLL</b> to compile and link your code, you may find the contents of !<b>MAKE_DLL.CC</b> and <b>!MAKE_DLL.LD</b> helpful in determining which options to specify to your compiler and linker, in conjunction with your system and compiler documentation. For the C language, the options in !MAKE_DLL should be very close to what you need. For other languages, the !MAKE_DLL options should be helpful in determining which options to use, as on most systems, all the language compilers accept similar options.</p>
        <h2>AUTO_GLUE</h2>
        <p>As described in <a href="PassingParameters.htm">Passing Parameters</a> , <b>CALL_EXTERNAL</b> uses the IDL Portable Calling Convention to call external code. This convention uses an (<b>argc</b>, <b>argv</b>) style interface to allow <b>CALL_EXTERNAL</b> to call routines with arbitrary numbers and types of arguments. Such an interface is necessary, because IDL, like any compiled program, cannot generate arbitrary function calls at runtime.</p>
        <p>Of course, most C functions are not written to the IDL portable convention. Rather, they are written using the natural form of argument passing used in compiled programs. It is therefore common for IDL programmers to write so-called glue functions to match the IDL calling interface to that of the target function. On systems that have a C compiler installed that is compatible with the one described by the IDL <b>!MAKE_DLL</b> system variable, the <b>AUTO_GLUE</b> keyword to <b>CALL_EXTERNAL</b> can be used to instruct IDL to automatically write, compile, and load this glue code on demand, and using a cache to preserve this glue code for future invocations of functions with the same interface.</p>
        <p><b>AUTO_GLUE</b> thus allows <b>CALL_EXTERNAL</b> to call functions with a natural interface, without requiring the user to write or compile additional code. AUTO_GLUE is described in the documentation for “CALL_EXTERNAL” , as well as in <a href="UsingAutoGlue.htm">Using Auto Glue</a>. The examples given in <a href="BasicCExamples.htm">Basic C Examples</a>  show <b>CALL_EXTERNAL</b> used with and without <b>AUTO_GLUE</b>.</p>
        <h2>Input and Output</h2>
        <p>Input and output actions should be performed within IDL code, using IDL’s built-in input/output facilities, or by using <b>IDL_Message()</b>. Performing input/output from code external to IDL, especially to the user console or tty (e.g. <b>stdin</b> or <b>stdout</b>), may generate unexpected results.</p>
        <h2>Memory Cleanup</h2>
        <p>IDL has a strict internal policy that it never performs memory cleanup on memory that it did not allocate. This policy is necessary so that external code which allocates memory can use any memory allocation package it desires, and so that there is no confusion about which code is responsible for releasing allocated memory.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>The code that allocates memory is always responsible for freeing it. IDL allocates and frees memory for its internal needs, and external code is not allowed to release such memory except through a proper IDL function documented for that purpose. Similarly, IDL will never intentionally free memory that it did not allocate. As such, IDL does not perform any memory cleanup calls on the values returned from external code called via the CALL_EXTERNAL routine. Because of this, any dynamic memory returned to IDL will not be returned to the system, which will result in a memory leak. Users should be aware of this behavior and design their <b>CALL_EXTERNAL</b> routines in such a manner as not to return dynamically allocated memory to IDL. The discussion in “Passing String Data” on page 64 contains an example of doing this with strings.</p>
        <h2>Memory Access</h2>
        <p>IDL and your external code share the same address space within the same running program. This means that mistakes common in compiled languages, such as a wild pointer altering memory that it does not own, can cause problems elsewhere. In particular, external code can easily corrupt IDL’s data structures and otherwise cause IDL to fail. Authors of such code must be especially careful to guard against such errors.</p>
        <h2><a name="Argument"></a>Argument Data Types</h2>
        <p>When using <b>CALL_EXTERNAL</b> to call external code, IDL passes its arguments to the called code using the data types that were passed to it. It has no way to verify independently that these types are the actual types expected by the external routine. If the data types passed are not of the types expected by the external code, the results are undefined, and can easily include memory corruption or even crashing of the IDL program.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>You must ensure that the arguments passed to external code are of the exact type expected by that routine. Failure to do so will result in undefined behavior.</p>
        <h2>Mapping IDL Data Types to External Language Types</h2>
        <p>When writing external code for use with <b>CALL_EXTERNAL</b>, your code must use data types that are compatible with the C data types used internally by IDL to represent the IDL data types. This mapping is covered in the topic  <a href="../IDLInternals - Types/Types.htm">IDL Internals: Types</a>.</p>
        <h2><a name="By-Value"></a>By-Value and By-Reference Arguments</h2>
        <p>There are two basic forms in which arguments can be passed between functions in compiled languages such as C/C++ and Fortran. To use <b>CALL_EXTERNAL</b> successfully, you should be comfortable with these terms and their meanings. In particular, Fortran programmers are often unaware that Fortran code passes everything by reference, and that C code defaults to passing everything by value. </p>
        <p>By default, <b>CALL_EXTERNAL</b> passes arguments by reference (unless this behavior is explicitly altered by the use of the <b>ALL_VALUE</b> or <b>VALUE</b> keywords), so no special action is typically required to call Fortran code via <b>CALL_EXTERNAL</b>.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>You must ensure that the arguments passed to external code are passed using the correct method — by value, or by reference. Failure to do so will result in undefined behavior.</p>
        <h3>Arguments Passed by Value</h3>
        <p>A copy of the value of the argument is passed to the called routine. Any changes made to such a value by the called routine are local to that routine, and do not change the original value of the variable in the calling routine. C/C++ pass everything by value, but have an explicit address-of operator (&amp;) that is used to pass addresses of variables and get by-reference behavior.</p>
        <h3>Arguments Passed by Reference</h3>
        <p>The machine address of the argument is passed to the called routine. Any changes made to such a value by the called routine are immediately visible to the caller, because both routines are actually modifying the same memory addresses. Fortran passes everything by reference, but most Fortran implementations support intrinsic operators that allow the programmer control over this (sometimes called <b>%LOC</b> and <b>%VAL</b>, or just <b>LOC</b> and <b>VAL</b>). Consult your compiler documentation for details.</p>
        <h2><a name="Microsof"></a>Microsoft Windows Calling Conventions</h2>
        <p>All operating system/hardware combinations define an inter-routine calling convention. A calling convention defines the rules used for passing arguments between routines, and specifies such details as how arguments of different types are passed (i.e. in registers or on the system stack) and how and when such arguments are cleaned up.</p>
        <p>A stable and efficient calling convention is critical to the stability of an operating system, and can affect most aspects of the system:</p>
        <ul>
            <li value="1">The efficiency of the entire system depends on the efficiency of the core calling convention.</li>
            <li value="2">Backwards compatibility, and thus the longevity of binary software written for the platform depends on the stability of the calling convention.</li>
            <li value="3">Calling routines from different languages within a single program depends on all the language compilers adhering to the same calling convention. Even within the same language, the ability to mix code compiled by different compilers requires those compilers to adhere to the same conventions. For example, at the time of this writing, the C++ language standard lacks an Application Binary Interface (ABI) that can be targeted by all C++ compilers. This can lead to situations in which the same compiler must be used to build all of the code within a given program.</li>
        </ul>
        <p>Microsoft Windows is unique among the platforms supported by IDL in that it has two distinct calling conventions in common use, whereas other systems define a single convention. On single-convention systems, the calling convention is unimportant to application programmers, and of concern only to hardware designers and the authors of compilers, and operating systems. On a multiple convention system, application programmers sometimes need to be aware of the issue, and ensure that their code is compiled to use the proper convention and that calls to that code use the same convention. The Microsoft Calling Conventions are:</p>
        <h3>STDCALL</h3>
        <p><b>STDCALL</b> is the calling convention used by the majority of the Windows operating system API. In a <b>STDCALL</b> call, the calling routine places the arguments in the proper registers and/or stack locations, and the called routine is responsible for cleaning them up and unwinding the stack.</p>
        <h3>CDECL</h3>
        <p><b>CDECL</b> is the calling convention used by C/C++ code by default. This default can be changed via compiler switches, declspec declarations, or <b>#pragmas</b>. With <b>CDECL</b>, the caller is responsible for both setup and cleanup of the arguments. <b>CDECL</b> is able to call functions with variable numbers of arguments (<b>varargs</b> functions) because the caller knows the actual number of arguments passed at runtime, whereas <b>STDCALL</b> cannot call such functions. This is because the <b>STDARGS</b> routine cannot know efficiently at compile time how many arguments it will be passed at runtime in these situations.</p>
        <p>The inconvenience of having two distinct and incompatible calling conventions is usually minor, because the header files that define functions for C/C++ programs include the necessary definitions such that the compiler knows to generate the proper code to call them and the programmer is not required to be aware of the issue. However, <b>CALL_EXTERNAL</b> does have a problem: Unlike a C/C++ program, IDL determines how to call a function solely by the arguments passed to <b>CALL_EXTERNAL</b>, and not from a header file.</p>
        <p>IDL therefore has no way to know how your external code was compiled. It uses the <b>STDARG</b> convention by default, and the <b>CDECL</b> keyword can be used to change the default. <b>CALL_EXTERNAL</b> therefore relies on the IDL user to tell it which convention to use. If IDL calls your code using the correct convention, it will work correctly. If it calls using the wrong convention, the results are undefined, including memory corruption and possible crashing of the IDL program.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>The default calling convention for <b>CALL_EXTERNAL</b> is <b>STDCALL</b>, whereas the default convention for the Microsoft C compiler is <b>CDECL</b>. Hence, Windows users must usually specify the <b>CDECL</b> keyword when calling such code from IDL. Non- Windows versions of IDL ignore the <b>CDECL</b> keyword, so it is safe to always include it in cross platform code.</p>
        <p>Here is what happens when external code is called via the wrong calling convention:</p>
        <p>•	If a <b>STDARG</b> call is made to a <b>CDECL</b> function, the caller places the arguments in the proper registers/stack locations, and relies on the called routine to cleanup and unwind the stack. The called routine, however, does not do these things because it is a <b>CDECL</b> routine. Hence, cleanup does not happen.</p>
        <p>•	If a <b>CDECL</b> call is made to a <b>STDARG</b> function, the caller places the arguments in the proper register/stack locations. The called routine cleans up on exit, and then the caller cleans up again.</p>
        <p>Either combination is bad, and can corrupt or kill the program. Sometimes this happens, and sometimes it doesn’t, so the results can be random and mysterious to programmers who are not aware of the issue.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>When the wrong calling convention is used, it is common for the process stack to become confused. A “smashed stack” visible from the C debugger following a <b>CALL_EXTERNAL</b> is usually indicative of having used the wrong calling convention.</p>
        <h2><a name="Common"></a>Common CALL_EXTERNAL Pitfalls</h2>
        <p>Following are a list of common errors and mistakes commonly seen when using <b>CALL_EXTERNAL</b>.</p>
        <ul>
            <li value="1">The number of arguments and their types, as passed to <b>CALL_EXTERNAL</b>, must be the exact types expected by the external routine. In particular, it is common for programmers to forget that the default IDL integer is a 16-bit value and that most C compilers define the int type as being a 32-bit value. You should be careful to use IDL LONG integers, which are 32-bit, in such cases. See <a href="#Argument" class="selected">Argument Data Types</a> for additional details.</li>
            <li value="2">Passing data using the wrong form: Using by-value to pass an argument to a function expecting it by-reference, or the reverse. See<a href="#By-Value" class="selected">By-Value and By- Reference Arguments</a>  for additional details.</li>
            <li value="3">Under Microsoft Windows, using the incorrect calling convention for a given external function. See <a href="#Microsof" class="selected">Microsoft Windows Calling Conventions</a> for additional details.</li>
            <li value="4">Failure to understand that IDL uses IDL_STRING descriptors to represent strings, and not just a C style NULL terminated string. Passing a string value by reference passes the address of the IDL_STRING descriptor to the external code. See  <a href="../IDLInternals - String Processing/StringProcessing.htm">IDL Internals: String Processing</a> for additional details.</li>
            <li value="5">Attempting to make IDL data structures use memory allocated by external code rather than using the proper IDL API for creating such data structures. For instance, attempting to give an <b>IDL_STRING</b> descriptor a different value by using C <b>malloc()</b> to allocate memory for the string and then storing the address of that memory in the <b>IDL_STRING</b> descriptor is not supported, and can easily crash or corrupt IDL. Although IDL uses <b>malloc()/free()</b> internally on most platforms, you should be aware that this is not part of IDL’s public interface, and that we can change this at any time and without notice. Even on platforms where IDL does use these functions, its use of them is not directly compatible with similar calls made by external code because IDL allocates additional memory for bookkeeping that is generally not present in memory allocations from other sources. See <a href="../IDLInternals - String Processing/StringProcessing.htm">IDL Internals: String Processing</a> for information on changing the value of an IDL_STRING descriptor using supported IDL interfaces. See “Memory Cleanup” for more on memory allocation and cleanup.</li>
            <li value="6">IDL is written in the C language, and when IDL starts, any necessary runtime initialization code required by C programs is automatically executed by the system before the IDL <b>main()</b> function is called. Hence, calling C code from IDL usually does not require additional runtime initialization. However, when calling external code written in languages other than C, you may find that your code does not run properly unless you arrange for the necessary runtime support for that language to run first. Such details are highly system specific, and you must refer to your system and compiler documentation for details. Code that is largely computational rarely encounters this issue. It is more common for code that performs Input/Output directly.</li>
            <li value="7">Programming errors in the external code. It is easy to make mistakes in compiled languages that have bad global consequences for unrelated code within the same program. For example, a wild memory pointer can lead to the corruption of unrelated data. If you are lucky, such an error will immediately kill your program, making it easy to locate and fix. Less fortunate is the situation in which the program dies much later in a seemingly unrelated part of the program. Finding such problems can be difficult and time consuming. When IDL crashes following a call to external code, an error in the external code or in the call to <b>CALL_EXTERNAL</b> is the cause in the vast majority of cases.</li>
            <li value="8">Some compilers and operating systems have a convention of adding leading or trailing underscore characters to the names of functions they compile. These conventions are platform specific, and as they are of interest only to system linker and compiler authors, not generally well documented. This is usually transparent to the user, but can sometimes be an issue with inter language function calls. If you find that a function you expect to call from a library is not being found by <b>CALL_EXTERNAL</b>, and the obvious checks do not uncover the error (usually a simple misspelling), this might be the cause. Under UNIX, the nm command can be helpful in diagnosing such problems.</li>
            <li value="9">C++ compilers use a technique commonly called name munging to encode the types of method arguments and return values into the name of the routine as written to their binary object files. Such names often have only a passing resemblance to the name seen by the C++ programmer in their source code. IDL can only call C++ code that has C linkage, as discussed in “C++”. C linkage code does not use name munging.</li>
            <li value="10">When calling external code written in other languages, there are sometimes platform and language specific hidden arguments that must be explicitly supplied. Such arguments are usually provided by the compiler when you work strictly within the target language, but become visible in inter-language calls. An example of this can be found in “Hidden Arguments”. In this example, the Fortran compiler provides an extra hidden length argument when a NULL terminated string is passed to a function.</li>
        </ul>
        <h2>See Also</h2>
        <p><a href="../../Reference Material/C/CALL_EXTERNAL.htm#C_854643309_1012385_Keywords_CALL_EXTERNAL__">AUTO_GLUE</a>, <a href="../../Reference Material/C/CALL_EXTERNAL.htm">CALL_EXTERNAL</a><a href="../../Reference Material/M/MAKE_DLL.htm">, MAKE_DLL</a>, <a href="../../Reference Material/S/SPAWN.htm">SPAWN</a>, <a href="../Miscellaneous EDG Topics/UsingSpawnAndPipes.htm">Using SPAWN and Pipes</a>, <a href="../../Creating IDL Programs/Appendices/IDL_Environment_System_V.htm#sysvars_272074529_1009307">!MAKE_DLL</a>, <a href="UsingAutoGlue.htm">Using AUTO_GLUE</a>, </p>
        <p>&#160;</p>
        <div class="mp_footer">© <span class="DocumentTitleCopyrightYear">2015</span>&#160;<span class="DocumentTitleCopyrightCompanyName">Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation</span>. All Rights Reserved. This information is not subject to the controls of the International Traffic in Arms Regulations (ITAR) or the Export Administration Regulations (EAR). However, this information may be restricted from transfer to various embargoed countries under U.S. laws and regulations.</div>
    </body>
</html>