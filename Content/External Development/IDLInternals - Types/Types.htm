<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-US" xml:lang="en-US" data-mc-search-type="Stem" data-mc-help-system-file-name="idl.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="Additional Topics|External Development Guide">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Types</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/TableStyles/Description.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/Doc_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix"> </span><a class="MCBreadcrumbsLink" href="../../OtherTopics.htm">Additional Topics</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="../EDG.htm">External Development Guide</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">IDLInternals - Types</span>
        </div>
        <h1><a name="kanchor5442"></a>Types</h1>
        <p>Every IDL variable has a data type. The possible type codes and their mapping to C language types are listed in the following table. The undefined type code <b>(IDL_TYP_UNDEF</b>) will always have the value zero.</p>
        <p>Although it is rare, the number of types could change. Therefore, you should always use the symbolic names when referring to any type except <b>IDL_TYP_UNDEF</b>. Even in the case of <b>IDL_TYP_UNDEF</b>, using the symbolic name will add clarity to your code. Note that all IDL structures are considered to be of a single type (<b>IDL_TYP_STRUCT</b>).</p>
        <p>Clearly, distinctions must be made between various structures, but such distinctions are made at a different level. There are a few constants that can be used to make your code easier to read and less likely to break if/when the idl_export.h file changes. These are:</p>
        <ul>
            <li value="1"><b>IDL_MAX_TYPE</b>—The value of the largest type.</li>
            <li value="2"><b>IDL_NUM_TYPES</b>—The number of types. Since the types are numbered starting at zero, IDL_NUM_TYPES is one greater than IDL_MAX_TYPE.</li>
        </ul>
        <table style="mc-table-style: url('../../Resources/TableStyles/Description.css');" class="TableStyle_Description" cellspacing="0">
            <col class="Column-Column1" />
            <col class="Column-Column1" />
            <col class="Column-Column1" />
            <thead>
                <tr class="Head-Header1">
                    <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
                        <p>Name</p>
                    </th>
                    <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
                        <p>Type</p>
                    </th>
                    <th class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
                        <p>C Type</p>
                    </th>
                </tr>
            </thead>
            <tbody>
                <tr class="Body-Body1">
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>IDL_TYP_UNDEF</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>Undefined</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>None</p>
                    </td>
                </tr>
                <tr class="Body-Body2">
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>IDL_TYP_BYTE	</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>Unsigned byte</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p>UCHAR</p>
                    </td>
                </tr>
                <tr class="Body-Body1">
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>IDL_TYP_INT</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>16–bit integer</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>IDL_INT</p>
                    </td>
                </tr>
                <tr class="Body-Body2">
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>IDL_TYP_LONG</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>32–bit integer</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p>IDL_LONG</p>
                    </td>
                </tr>
                <tr class="Body-Body1">
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>IDL_TYP_FLOAT</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>Single precision floating</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>Float</p>
                    </td>
                </tr>
                <tr class="Body-Body2">
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>IDL_TYP_DOUBLE</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>Double precision floating	</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p>Double</p>
                    </td>
                </tr>
                <tr class="Body-Body1">
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>IDL_TYP_COMPLEX</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>Single precision complex</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>IDL_COMPLEX</p>
                    </td>
                </tr>
                <tr class="Body-Body2">
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>IDL_TYP_STRING</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>String</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p>IDL_STRING</p>
                    </td>
                </tr>
                <tr class="Body-Body1">
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>IDL_TYP_STRUCT</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>Structure</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>See <a href="../IDLInternals - Variables/StructureVariables.htm">Structure Variables</a></p>
                    </td>
                </tr>
                <tr class="Body-Body2">
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>IDL_TYP_DCOMPLEX</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>Double precision complex</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p>IDL_DCOMPLEX</p>
                    </td>
                </tr>
                <tr class="Body-Body1">
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>IDL_TYP_PTR</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>32–bit integer	</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>IDL_ULONG</p>
                    </td>
                </tr>
                <tr class="Body-Body2">
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>IDL_TYP_OBJREF</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>32–bit integer</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p>IDL_ULONG</p>
                    </td>
                </tr>
                <tr class="Body-Body1">
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>IDL_TYP_UINT</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>Unsigned 16-bit integer</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>&#160;</p>
                    </td>
                </tr>
                <tr class="Body-Body2">
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>IDL_TYP_ULONG</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>Unsigned 32-bit integer</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p>IDL_ULONG</p>
                    </td>
                </tr>
                <tr class="Body-Body1">
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>IDL_TYP_LONG64	</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>64-bit integer	</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>IDL_LONG64</p>
                    </td>
                </tr>
                <tr class="Body-Body2">
                    <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
                        <p>IDL_TYP_ULONG64</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
                        <p>Unsigned 64-bit integer</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowEnd_ColEnd">
                        <p>IDL_ULONG64</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <h2>Type Masks</h2>
        <p>There are some situations in which it is necessary to specify types in the form of a bit mask rather than the usual type codes, for example when a single argument to a function can represent more than a single type. For any given type, the bit mask value can be computed as: Mask = 2TypeCode</p>
        <p>The <b>IDL_TYP_MASK</b> preprocessor macro is provided to calculate these masks. Given a type code, it returns the bit mask. For example, to specify a bit mask for all the integer types:</p>
        <p class="Code">IDL_TYP_MASK(IDL_TYP_BYTE)|IDL_TYP_MASK(IDL_TYP_INT)| </p>
        <p class="Code">&#160;&#160;&#160;IDL_TYP_MASK(IDL_TYP_LONG)</p>
        <p>Specifying all the possible types would require a long statement similar to the one above. To avoid having to type so much for this common case, the <b>IDL_TYP_B_ALL</b> constant is provided.</p>
        <h2><a name="Mapping"></a>Mapping of Basic Types</h2>
        <p>Within IDL, the IDL data types are mapped into data types supported by the C language. Most of the types map directly into C primitives, while <b>IDL_TYP_COMPLEX</b>, <b>IDL_TYP_DCOMPLEX</b>, and <b>IDL_TYP_STRING</b> are defined as C structures. The mappings are given in the following table. Structures are built out of the basic types by laying them out in memory in the specified order using the same alignment rules used by the C compiler for the target machine.</p>
        <h3>Unsigned Byte Data</h3>
        <p><b>UCHAR</b> is defined to be unsigned char in <code>idl_export.h</code>.</p>
        <h3>Integer Data</h3>
        <p><b>IDL_INT</b> represents the signed 16-bit data type and is defined in <code>idl_export.h</code>.</p>
        <h3>Unsigned Integer Data</h3>
        <p><b>IDL_UINT</b> represents the unsigned 16-bit data type and is defined in</p>
        <p><code>idl_export.h</code>.</p>
        <h3>Long Integer Data</h3>
        <p>IDL long integers are defined to be 32-bits in size. The C long data type is not correct on all systems because C compilers for 64-bit architectures usually define long as 64- bits. Hence, the <b>IDL_LONG</b> typedef, declared in <code>idl_export.h</code> is used instead.</p>
        <h3>Unsigned Long Integer Data</h3>
        <p><b>IDL_ULONG</b> represents the unsigned 32-bit data type and is defined in <code>idl_export.h</code>.</p>
        <h3>64-bit Integer Data</h3>
        <p><b>IDL_LONG64</b> represents the 64-bit data type and is defined in <code>idl_export.h</code>.</p>
        <h3>Unsigned 64-bit Integer Data</h3>
        <p><b>IDL_ULONG64</b> represents the unsigned 64-bit data type and is defined in <code>idl_export.h</code>.</p>
        <h3>Complex Data</h3>
        <p>The <b>IDL_TYP_COMPLEX</b> and <b>IDL_TYP_DCOMPLEX</b> data types are defined by the following C declarations:</p>
        <p class="Code">typedef struct { float r, i; } IDL_COMPLEX;</p>
        <p class="Code">typedef struct { double r, i; } IDL_DCOMPLEX;</p>
        <p>This is the same mapping used by Fortran compilers to implement their complex data types, which allows sharing binary data with such programs.</p>
        <h3>String Data</h3>
        <p>The <b>IDL_TYP_STRING</b> data type is implemented by a string descriptor:</p>
        <p class="Code">typedef struct {</p>
        <p class="Code_Indented">IDL_STRING_SLEN_T slen;	/* Length of string */</p>
        <p class="Code_Indented">short stype;	/* Type of string */</p>
        <p class="Code_Indented">char *s;	/* Pointer to string */</p>
        <p class="Code">} IDL_STRING;</p>
        <p>The fields of the <b>IDL_STRING</b> struct are defined as follows:</p>
        <h3>slen</h3>
        <p>The length of the string, not counting the null termination. For example, the string “Hello” has 5 characters.</p>
        <h3>stype</h3>
        <p>If stype is zero, the string pointed at by s (if any) was not allocated from dynamic memory, and should not be freed. If non-zero, s points at a string allocated from dynamic memory, and should be freed before being replaced. For information on dynamic memory, see <a href="../IDLInternals - Miscellaneous/DynamicMemory.htm">Dynamic Memory</a>.</p>
        <h3>s</h3>
        <p>If slen is non-zero, s is a pointer to a null-terminated string of slen characters. If slen is zero, s should not be used. The use of a string pointer to memory located outside the IDL_STRING structure itself allows IDL strings to have dynamically-variable lengths.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Strings are the most complicated basic data type, and as such, are at the root of more coding errors than the other types. See <a href="../IDLInternals - String Processing/StringProcessing.htm">IDL Internals: String Processing</a>.</p>
        <h2>IDL_MEMINT and IDL_FILEINT Types</h2>
        <p>Some of the IDL-supported operating systems limit memory and file lengths to a signed 32-bit integer (approximately 2.3 GB). Some systems have 64-bit memory capabilities and others allow files longer than 231-1 bytes despite being 32-bit memory limited. To gracefully handle these differences without using conditional code, IDL internals use two special types, I<b>DL_TYP_MEMINT</b> (data type <b>IDL_MEMINT</b>) and <b>IDL_TYP_FILEINT</b> (data type <b>IDL_FILEINT</b>) to represent memory and file length limits.</p>
        <p><b>IDL_MEMINT</b> and <b>IDL_FILEINT</b> are not separate and distinct types; they are actually mappings to the IDL types discussed in <a href="#Mapping" class="selected">Mapping of Basic Types</a>. Specifically, they will be <b>IDL_LONG</b> for 32-bit quantities, and <b>IDL_LONG64</b> for 64-bit quantities.</p>
        <p>As an IDL internals programmer, you should not write code that depends on the actual machine type represented by these abstract types. To ensure that your code runs properly on all systems, use <b>IDL_MEMINT</b> and <b>IDL_FILEINT</b> in place of more specific types. These types can be used anywhere that a normal IDL type can be used, such as in keyword processing. Their systematic use for these purposes will ensure that your code is correct on any IDL platform.</p>
        <p>Programmers should be aware of the <b>IDL_MEMINTScalar()</b> and <b>IDL_FILEINTScalar()</b> functions, described in <a href="../IDLInternals - Type Conversion/ConvertingArgumentsToCScalars.htm">Converting Arguments to C Scalars</a>.</p>
        <div class="mp_footer">© <span class="DocumentTitleCopyrightYear">2015</span>&#160;<span class="DocumentTitleCopyrightCompanyName">Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation</span>. All Rights Reserved. This information is not subject to the controls of the International Traffic in Arms Regulations (ITAR) or the Export Administration Regulations (EAR). However, this information may be restricted from transfer to various embargoed countries under U.S. laws and regulations.</div>
    </body>
</html>