<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-US" xml:lang="en-US" data-mc-search-type="Stem" data-mc-help-system-file-name="idl.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="Language|Data Types">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Data Type and Structure of Expressions</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/TableStyles/Description.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/Doc_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix"> </span><a class="MCBreadcrumbsLink" href="../../IDL Programming.htm">Language</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="IDL_Data_Types.htm">Data Types</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">Data Type and Structure of Expressions</span>
        </div>
        <h1><a name="constants_818058343_699867"></a><a name="constants_818058343_29281"></a>Data Type and Structure of Expressions</h1>
        <p>Every entity in IDL has an associated <i>data type</i> and <i>structure</i>. The <i>structure of an expression</i> determines whether the expression can represent a single value or multiple values. IDL expressions can be either <i><a name="kanchor4492"></a>scalars</i> (with exactly one value) or <i>arrays</i> (with one or more values). The data type and structure of an expression depend on the data type and structure of its operands. </p>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>You can determine the data type of an expression by returning the type code of the expression.</p>
        <h2 class="API"><a name="constants_818058343_699874"></a><a name="constants_818058343_49574"></a>Hierarchy of IDL Data Types</h2>
        <p>Unlike many other languages, the data type and structure of most expressions in IDL cannot be determined until the expression is evaluated. Because of this, care must be taken when writing programs. For example, a variable can be a scalar byte variable at one point in a program while at a later point the same variable can hold a complex array. The twelve atomic data types in decreasing order of precedence are as follows:</p>
        <ul>
            <li value="1">Double-precision complex floating-point (DCOMPLEX)</li>
            <li value="2">Complex floating-point (COMPLEX)</li>
            <li value="3">Double-precision floating-point (DOUBLE)</li>
            <li value="4">Floating-point (FLOAT)</li>
            <li value="5">Signed and unsigned 64-bit integers (LONG64 and ULONG64)</li>
            <li value="6">Signed and unsigned 32-bit integer (LONG and ULONG)</li>
            <li value="7">Signed and unsigned 16-bit integer (INT and UINT)</li>
            <li value="8">Byte/Boolean</li>
            <li value="9">String</li>
        </ul>
        <h2 class="API"><a name="constants_818058343_699909"></a><a name="constants_818058343_32859"></a>Expression Type</h2>
        <p>IDL attempts to evaluate expressions containing operands of different data types in the most accurate manner possible. The result of an operation becomes the same data type as the operand with the greatest precedence or potential precision. For example, when adding a byte variable to a floating-point variable, the byte variable is first converted to floating-point, then added to the floating-point variable, yielding a floating-point result. When adding a double-precision variable to a complex variable, the result is double-precision complex, because the double-precision complex type has a higher position in the hierarchy of data types. See <a href="#constants_818058343_699874" class="selected">Hierarchy of IDL Data Types</a> for the order of precedence.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Signed and unsigned integers of a given width have the same precedence. In an expression involving a combination of such types, the result is given the type of the <i>leftmost</i> operand.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Boolean variables are treated just like byte variables. The result of any math expression using boolean variables will be a byte variable.</p>
        <p>When writing expressions with mixed data types, care must be taken to obtain the desired results. For example, assume the variable A is an integer variable with a value of 5. The following expressions yield the indicated results:</p>
        <table style="margin-left: 0;margin-right: auto;mc-table-style: url('../../Resources/TableStyles/Description.css');" class="TableStyle_Description" cellspacing="0">
            <col />
            <col />
            <col />
            <thead>
                <tr>
                    <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
                        <p>Operation</p>
                    </th>
                    <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
                        <p>Result</p>
                    </th>
                    <th class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
                        <p>Notes</p>
                    </th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>A/2</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>2 (int)</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>Integer division is performed. The remainder is discarded.</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>A/2.0</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>2.5 (float)</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p>The value of A is first converted to floating.</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>A/2 + 1.0</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>3.0 (float)</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>Integer division is done first because of operator precedence.</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>A/2.0 + 1</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>3.5 (float)</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p>Division is done in floating, then the 1 is converted to float and added.</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>A + 5u</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>10 (int)</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>Signed and unsigned integer operands have the same precedence, so the left-most operand determines the result type.</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>5u + A</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>10 (uint)</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p>The left-most operand determines the result type between types with the same precedence.</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>A &lt; 65535u</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>–1 (int)</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>Again, left operand determines the type. 65535 converted to int gives –1, which is smaller than A.</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
                        <p>65535u &lt; A</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
                        <p>5 (uint)</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowEnd_ColEnd">
                        <p>Again, left operand determines the type. A=5 is converted to uint, which is smaller than A.</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>When other data types are converted to complex type, the real part is set equal to the original value and the imaginary part is set to zero.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>When a string type appears as an operand with a numeric data type, the string is converted to the type of the numeric term. For example: '123' + 123.0 is 246.0, while '123.333' + 33 gives the result 156 because 123.333 is first converted to integer type. In the same manner, 'ABC' + 123 also causes a conversion error.</p>
        <h2 class="API"><a name="constants_818058343_699945"></a><a name="constants_818058343_33167"></a>Expression Structure</h2>
        <p>IDL expressions &gt;<a name="kanchor4493"></a>can contain operands that are either scalars or arrays, just as they can contain operands with different types. Conversion of variables between the scalar and array forms is independent of data type conversion. An expression will yield an array result if any of its operands is an array, as shown in the following table:</p>
        <table style="mc-table-style: url('../../Resources/TableStyles/Description.css');margin-left: 0;margin-right: auto;" cellspacing="0" class="TableStyle_Description">
            <col />
            <col />
            <thead>
                <tr>
                    <td class="TableStyle_Description_Head_0_0_RowSep_ColSep">
                        <p>Operands</p>
                    </td>
                    <td class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
                        <p>Result</p>
                    </td>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>Scalar : Scalar</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>Scalar</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p>Array : Array</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p>Array</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p>Scalar : Array</p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>Array</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
                        <p>Array : Scalar</p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowEnd_ColEnd">
                        <p>Array</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>See Operations on Array Expressions for more information on working with arrays as operands in an expression.</p>
        <div class="mp_footer">© <span class="DocumentTitleCopyrightYear">2015</span>&#160;<span class="DocumentTitleCopyrightCompanyName">Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation</span>. All Rights Reserved. This information is not subject to the controls of the International Traffic in Arms Regulations (ITAR) or the Export Administration Regulations (EAR). However, this information may be restricted from transfer to various embargoed countries under U.S. laws and regulations.</div>
    </body>
</html>