<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-US" xml:lang="en-US" data-mc-search-type="Stem" data-mc-help-system-file-name="idl.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="Language|Arrays">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Understanding Array Subscripts</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Resources/TableStyles/Description.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/Doc_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix"> </span><a class="MCBreadcrumbsLink" href="../../IDL Programming.htm">Language</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="../Arrays.htm">Arrays</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">Understanding Array Subscripts</span>
        </div>
        <h1><a name="arrays_3727706888_515270"></a><a name="arrays_3727706888_55211"></a>Understanding Array Subscripts</h1>
        <p><a name="kanchor4462"></a> You can use subscripts to either to retrieve the value of one or more array elements or to designate array elements to receive new values. The expression <code>arr[12]</code> denotes the value of the 13th element of <code>arr</code> (because subscripts start at 0), while the statement <code>arr[12] = 5</code> stores the number 5 in the 13th element of <code>arr</code> without changing the other elements.</p>
        <p>Specify the elements of multidimensional arrays  by using one subscript for each dimension. IDL’s convention is that for generic arrays and images, the first subscript denotes the column and the second subscript denotes the row. In standard mathematical representation (linear algebra, for example), the convention is reversed: the first subscript denotes the row and the second subscript denotes the column.</p>
        <p>If <code>A</code> is a 2-element by 3-element array (using [<i>column</i>, <i>row</i>] notation), the elements are stored in memory as follows: </p>
        <table style="mc-table-style: url('../../Resources/TableStyles/Description.css');margin-left: 0;margin-right: auto;caption-side: bottom;" cellspacing="0" class="TableStyle_Description">
            <col />
            <col />
            <col />
            <thead>
                <tr>
                    <td class="TableStyle_Description_Head_0_0_RowSep_ColSep">
                        <p>&#160;</p>
                    </td>
                    <td class="TableStyle_Description_Head_0_0_RowSep_ColSep">
                        <p>&#160;</p>
                    </td>
                    <td class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
                        <p>Stored in Memory</p>
                    </td>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p><i>A</i><sub>0,0</sub>
                        </p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
                        <p><i>A</i><sub>1,0</sub>
                        </p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
                        <p>Lowest memory address</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p><i>A</i><sub>0,1</sub>
                        </p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
                        <p><i>A</i><sub>1,1</sub>
                        </p>
                    </td>
                    <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
                        <p>.<br />.<br />.</p>
                    </td>
                </tr>
                <tr>
                    <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep">
                        <p><i>A</i><sub>0,2</sub>
                        </p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep">
                        <p><i>A</i><sub>1,2</sub>
                        </p>
                    </td>
                    <td class="TableStyle_Description_Body_0_0_RowEnd_ColEnd">
                        <p>Highest memory address</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>The elements are ordered in memory as: A<sub>0,0</sub>, A<sub>1,0</sub>, A<sub>0,1</sub>, A<sub>1,1</sub>, A<sub>0,2</sub>, A<sub>1,2</sub>. This ordering is like Fortran. It is the opposite of the order used by C/C++. For more information on how IDL arranges multidimensional data in memory, see <a href="Columns__Rows__and_Array.htm#arrays_3727706888_737332">Columns, Rows, and Array Majority</a>. For a discussion of how the ordering of such data relates to IDL mathematics routines, see <a href="Manipulating_Arrays.htm#arrays_3727706888_752335">Manipulating Arrays</a>.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>When comparing IDL’s memory layout to other languages, remember that those languages usually use a mathematical [<i>row</i>, <i>column</i>] notation for array dimensions, which is the reverse of the array notation used for the example above. See <a href="Columns__Rows__and_Array.htm#arrays_3727706888_737332">Columns, Rows, and Array Majority</a> for more on comparing IDL’s array layout to that of other languages.</p>
        <p><a name="kanchor4463"></a>Arrays that contain image data are usually displayed in graphics displays with row zero at the bottom of the screen, matching the display’s coordinate system (although this order can be reversed by setting the system variable !ORDER to a nonzero value). <a name="kanchor4464"></a>Array data are printed to standard text output (such as the IDL output log or console window) with the first row on top.</p>
        <p>Arrays with multiple dimensions are addressed by specifying a subscript expression for each dimension. A two-dimensional array with <i>n</i> columns and <i>m</i> rows, is addressed with a subscript of the form <i>[i, j]</i>, where 0 ≤<i> i </i>&lt;<i> n</i> and 0 ≤<i> j </i>&lt;<i> m</i>. The first subscript, <i>i</i>, is the column index; the second subscript, <i>j</i>, is the row index. For example, the following statements select and print the element in the first column of the second row of <code>array</code>:</p>
        <p class="Code">array = [[1, 2, 3], [4, 5, 6]]</p>
        <p class="Code">PRINT, array[0,1]</p>
        <p>IDL prints:</p>
        <p class="Code">4</p>
        <p>Elements of multidimensional arrays also can be specified using only one subscript, in which case the array is treated as a vector with the same number of points. </p>
        <p>&#160;&#160;&#160;&#160;&#160;A<sub>0,0</sub> &#160;&#160;&#160;&#160;&#160;A<sub>0,1</sub></p>
        <p>&#160;&#160;&#160;&#160;&#160;A<sub>0,1</sub> &#160;&#160;&#160;&#160;&#160;A<sub>1,1</sub></p>
        <p>&#160;&#160;&#160;&#160;&#160;A<sub>0,2</sub> &#160;&#160;&#160;&#160;&#160;A<sub>1,2</sub></p>
        <p>In the 2 by 3 element array, <code>A</code>, element <code>A[2]</code> is the same element as <code>A[0, 1]</code>, and <code>A[5]</code> is the same element as <code>A[1, 2]</code>.</p>
        <p>If an attempt is made to reference a nonexistent element of an array using a scalar subscript (a subscript that is negative or larger than the size of the dimension minus&#160;1), an error occurs and program execution stops.</p>
        <p>Subscripts can be any type of vector or scalar expression. If a subscript expression is not integer, a signed integer copy is made and used to evaluate the subscript. </p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>When floating-point numbers are converted to longword integers, they are truncated, not rounded. Thus, specifying <code>A[1.99]</code> is the same as specifying <code>A[1]</code>.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Subscripts are converted to the signed integer type used for addressing memory for your system (for example, on a 32-bit architecture, subscripts are converted to signed 32-bit integers). Using subscripts that are outside of the range for that integer type may produce unexpected results.</p>
        <h2 class="API"><a name="arrays_3727706888_96053"></a>Extra Dimensions</h2>
        <p>When creating arrays, IDL eliminates all size 1, or “degenerate”, trailing dimensions. Thus, the statements</p>
        <p class="Code">A = INTARR(10, 1)</p>
        <p class="Code">HELP, A</p>
        <p>print the following:</p>
        <p class="Code">A               INT       = Array[10]</p>
        <p>This removal of extra dimensions is usually convenient, but it can cause problems when attempting to write fully general procedures and functions. Therefore, IDL allows you to specify “extra” dimensions for an array as long as the extra dimensions are all zero. </p>
        <p>For example, consider a vector defined as follows:</p>
        <p class="Code">arr = INDGEN(10)</p>
        <p>The following are all valid references to the sixth element of <code>arr</code>:</p>
        <p class="Code">X = arr[5]</p>
        <p class="Code">X = arr[5, 0]</p>
        <p class="Code">X = arr[5, 0, 0, *, 0]</p>
        <p>Thus, the automatic removal of degenerate trailing dimensions does not cause problems for routines that attempt to access the resulting array.</p>
        <p>Use the REFORM function to add degenerate trailing dimensions to an array if needed. For example, the following statements create a 10 element integer vector, and then alter the dimensions to be [10, 1]:</p>
        <p class="Code">A = INTARR(10)</p>
        <p class="Code">A = REFORM(A, 10, 1, /OVERWRITE)</p>
        <h2 class="API"><a name="arrays_3727706888_737171"></a><a name="arrays_3727706888_21833"></a>Array Subscript <a name="kanchor4465"></a>Syntax: [ ] vs. ( )</h2>
        <p>Versions of IDL prior to version 5.0 used parentheses to indicate array subscripts. Function calls use parentheses in a visually identical way to specify argument lists. As a result, the IDL compiler was not able to distinguish between arrays and functions by looking at the statement syntax. For example, the IDL statement</p>
        <p class="Code">value = fish(5)</p>
        <p>could either set the variable value equal to the sixth element of an array named fish, or set value equal to the result of passing the argument 5 to a function called fish.</p>
        <p>To determine if it is compiling an array subscript or a function call, IDL checks its internal table of known functions. If it finds a function name that matches the unknown element in the command (fish, in the above example), it calls that function with the argument specified. If IDL does not find a function with the correct name in its table of known functions, it assumes that the unknown element is an array, and attempts to return the value of the designated element of that array. This rule generally gives the desired result, but it can be fooled into the wrong choice under certain circumstances, and can produce either a syntax or runtime error.</p>
        <p>For this reason, versions of IDL beginning with version 5.0 use square brackets rather than parentheses for array subscripting. An array subscripted in this way is unambiguously interpreted as an array under all circumstances. In IDL 5.0 and later:</p>
        <p class="Code">value = fish[5]</p>
        <p>sets value to the sixth element of an array named fish.</p>
        <p>Due to the large amount of existing IDL code written in the older syntax, IDL continues to allow the old syntax to be used, subject to the ambiguity mentioned above. That is, while </p>
        <p class="Code">value = fish[5]</p>
        <p>is unambiguous, </p>
        <p class="Code">value = fish(5)</p>
        <p>is still subject to the same ambiguity—and rules—that applied in IDL versions prior to version 5.0.</p>
        <p>Since the older syntax has been used widely, you should not be surprised to see it from time to time. However, square brackets are the preferred form, and should be used for new code.</p>
        <p class="Tip" data-mc-autonum="&lt;b&gt;Tip: &lt;/b&gt;"><span class="autonumber"><span><b>Tip: </b></span></span>To ensure that you only use square brackets, it is strongly recommended that you use <code>COMPILE_OPT strictarr</code> (or <code>COMPILE_OPT IDL2</code>) at the top of your routine. This will avoid any confusion in the IDL compiler between the use of parentheses for array indexing and the use of parentheses for function calls. See <a href="../../Reference Material/C/COMPILE_OPT.htm">COMPILE_OPT</a> for details.</p>
        <p class="Note" data-mc-autonum="&lt;b&gt;Note: &lt;/b&gt;"><span class="autonumber"><span><b>Note: </b></span></span>Note that using the <a href="../../Reference Material/C/COMPILE_OPT.htm">COMPILE_OPT</a> statement with the <code>idl2</code> option will enforce the use of square brackets within the scope of a routine. This is the recommended technique. Alternately, the <a href="../../Reference Material/F/FORWARD_FUNCTION.htm">FORWARD_FUNCTION</a> statement can be used to declare a function before it is used in a routine.</p>
        <div class="mp_footer">© <span class="DocumentTitleCopyrightYear">2015</span>&#160;<span class="DocumentTitleCopyrightCompanyName">Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation</span>. All Rights Reserved. This information is not subject to the controls of the International Traffic in Arms Regulations (ITAR) or the Export Administration Regulations (EAR). However, this information may be restricted from transfer to various embargoed countries under U.S. laws and regulations.</div>
    </body>
</html>